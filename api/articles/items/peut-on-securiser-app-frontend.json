{"slug":"peut-on-securiser-app-frontend","filename":"2020-03-27-peut-on-securiser-une-application-frontend","title":"Est-il possible de sécuriser une application front-end ?","date":"Thu, 02 Apr 2020 00:00:00 GMT","draft":false,"meta":{"date":"2020-04-02T00:00:00.000Z","title":"Est-il possible de sécuriser une application front-end ?","author":"Aschen","slug":"peut-on-securiser-app-frontend"},"body":"<p>Je suis toujours très surpris d'entendre parler de la sécurité des applications frontend parce que précisément une application frontend s'exécute sur le périphérique de l'utilisateur et ne peut donc pas être sécurisée. Elle doit même être considérée comme un <strong>client potentiellement malveillant</strong>.</p>\n<p>En effet, le code source de l'application étant à la disposition de l'utilisateur, <strong>il est possible de l'étudier et de le modifier à volonté</strong> afin d'en comprendre les mécanismes internes ou de récupérer toutes les données stockées sur le périphérique.</p>\n<p>Je suis tombé sur de nombreux articles de diverses sources (<a href=\"https://callstack.com/blog/secure-your-react-native-app/\">Callstack</a>, <a href=\"https://blog.jscrambler.com/protecting-your-react-js-source-code-with-jscrambler/\">Jscrambler</a>, <a href=\"https://tabris.com/securing-your-mobile-application-in-javascript/\">Tabris</a>, <a href=\"https://www.nativescript.org/blog/secure-your-mobile-app-securing-data-at-rest\">Nativescript</a>, <a href=\"https://reactnativecode.com/password-encryption-decryption-using-base64/\">Reactnativecode</a>) qui détaillaient les &quot;techniques&quot; pour sécuriser une application frontend en utilisant l'obfuscation, du chiffrement custom (XOR avec réutilisation de clé, etc...), et ainsi de suite.</p>\n<p>Ce n'est pas la première fois que j'entends parler de recettes sur &quot;l'écriture d'une application frontend sécurisée&quot;: <strong>Il peut être dangereux et contre-productif d'essayer de sécuriser une application avec des techniques inefficaces</strong>. Voici pourquoi.</p>\n<p><strong>TLDR;</strong></p>\n<ul>\n<li>Ne jamais faire confiance aux applications frontend</li>\n<li><a href=\"https://security.stackexchange.com/a/18198\">N'utilisez pas votre propre cryptographie</a></li>\n<li>N'utilisez pas de clé de chiffrement prédictibles</li>\n<li><a href=\"https://www.wikiwand.com/en/Stream_cipher_attacks#/Reused_key_attack\">Ne réutilisez pas une clé de chiffrement</a></li>\n<li><a href=\"https://security.stackexchange.com/questions/24449/how-valuable-is-secrecy-of-an-algorithm/24455#24455\">Obfusquer n'est pas sécuriser</a></li>\n<li>Sécurisez plutôt votre backend</li>\n</ul>\n<h2>Authentification</h2>\n<p>L’envoi des informations d’authentification se fait de manière sécurisée au travers d’une connexion SSL, la confidentialité des communications est donc assurée dans la plupart des cas.</p>\n<p>Ajouter une couche de chiffrement basique pour le mot de passe avec un simple XOR et une clé réutilisée pour chaque authentification de chaque client est inutile pour plusieurs raisons:</p>\n<ul>\n<li>la <strong>réutilisation de la clé</strong> pour chaque client et chaque requête <strong>rend le chiffrement vulnérable</strong> car il est possible de <a href=\"https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption/1135197#1135197\">deviner le message</a> avec une <a href=\"https://www.wikiwand.com/en/Frequency_analysis\">analyse de fréquence</a>.</li>\n<li>étant donné que <strong>la clé est stockée dans le device</strong>, il suffit de télécharger l’application pour la connaître</li>\n<li>si <strong>la clé était stockée dans le localstorage du navigateur</strong>, n'importe quel code Javascript executé sur la page pourrait y accéder</li>\n</ul>\n<p>Rajouter une couche de chiffrement peut s’avérer être une bonne idée pour éviter la compromission des données dans le cas d’une <a href=\"https://www.eff.org/deeplinks/2010/03/researchers-reveal-likelihood-governments-fake-ssl\">attaque Man In The Middle avec un faux certificat SSL</a>.</p>\n<p>Pour un chiffrement solide, il sera nécessaire à minima:</p>\n<ul>\n<li>D’utiliser une clé de la taille du mot de passe</li>\n<li>D’utiliser une clé différente pour chaque utilisateur et chaque requête</li>\n<li>De négocier cette clé avec un algorithme de chiffrement asymétrique de type <a href=\"https://www.wikiwand.com/en/Diffie%E2%80%93Hellman_key_exchange\">Diffie Helman</a></li>\n</ul>\n<p>Cela revient plus ou moins à implémenter une version custom de SSL dans son application et <a href=\"https://security.stackexchange.com/a/18198\">implémenter son propre système cryptographique n'est jamais une bonne idée</a>.</p>\n<p><img src=\"/public/images/articles/2020-03-27-peut-on-securiser-une-application-frontend/reinvent-the-wheel.png\" alt=\"trying to reinvent the wheel\" />\n<em>When you try to reinvent the wheel..</em></p>\n<p>Il est bien plus facile d’utiliser d’autres techniques de sécurisation tel que le <a href=\"https://security.stackexchange.com/a/29990\">SSL Pinning</a> pour se prévenir des attaque MITM.</p>\n<p>Dernier point, pour un maximum de sécurité, il est conseillé de générer des tokens ayant une durée de validitée courte pour limiter les dégats causés par une éventuelle compromission.</p>\n<h2>Stocker des données sensibles</h2>\n<p>Lorsqu’il est nécessaire de stocker des données sensibles dans une application frontend, il est préférable d’utiliser les mécanismes mis à disposition par les créateurs de l’environnement de développement.</p>\n<p>Par exemple, dans une application mobile avec React Native, nous pouvons utiliser la <a href=\"https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_keychain\">Keychain d’Apple</a> ou le <a href=\"https://developer.android.com/training/articles/keystore\">Keystore d’Android</a>. Ces <strong>mécanismes rendent plus difficile l’extraction de données</strong> sensibles depuis un device mais ils ne doivent <strong>pas non plus être considérés comme inviolables</strong>. (Eg: <a href=\"https://googleprojectzero.blogspot.com/2019/08/a-very-deep-dive-into-ios-exploit.html\">Apple Keychain exploit</a>)</p>\n<p>Dans tous les cas, il est inutile de rajouter une couche de chiffrement supplémentaire réalisée avec une clé prédictible car un <strong>attaquant peut faire du reverse engineering sur l’application</strong> pour retrouver la clé.\nOu encore plus facilement, simplement <strong>accéder à la clé stockée en mémoire</strong>.</p>\n<p>Cela est contre-productif va <strong>consommer inutilement des ressources CPU</strong> pour le chiffrement/déchiffrement et donc <strong>drainer la batterie</strong>.</p>\n<h2>Obfusquer le code source</h2>\n<p>Bien que je puisse comprendre que les développeurs puisse vouloir compliquer la tâche de reverse engineering d'une application, <strong>l’obfuscation de doit jamais être considérée comme une pratique de sécurisation</strong>.</p>\n<p>Elle peut au maximum décourager certains attaquants mais quelqu’un de motivé pourra toujours analyser et comprendre le fonctionnement de l'application.</p>\n<p>Surtout si un <a href=\"https://github.com/rapid7/jsobfu\">obfuscateur open-source</a> est utilisé car celui-ci est donc connu et des <a href=\"http://m1el.github.io/esdeobfuscate/\">dé-obfuscateurs</a> doivent certainement déjà exister.</p>\n<p>De plus, l'obfuscation va rendre le code très difficile à interpréter et optimiser par les différents moteurs Javascript et il en résultera une <strong>baisse significative des performances de l’application</strong>.</p>\n<p><img src=\"/public/images/articles/2020-03-27-peut-on-securiser-une-application-frontend/obfuscation-benchmark.png\" alt=\"obfuscation benchmark\" />\n<em><a href=\"http://jsben.ch/yiK3U\">Benchmark</a> réalisé avec l'<a href=\"https://obfuscator.io/\">obfuscateur</a> de <a href=\"https://github.com/javascript-obfuscator/react-native-obfuscating-transformer\">react-native-obfuscating-transformer</a></em></p>\n<h2>Sécurisez votre backend</h2>\n<p>Comme nous l’avons vu, <strong>une application frontend ne peut pas être sécurisée</strong>. Comme il est impossible d’avoir le contrôle sur le terminal du client, il est impossible de s’assurer que celui-ci n’est pas compromis.</p>\n<p>C’est sur le backend que la majeure partie des éléments de sécurité doivent être mis en place.\nIl n’y a pas de recette magique pour sécuriser un backend, c’est <strong>un ensemble de bonnes pratiques</strong> de programmation qui permettra d’arriver à un résultat optimal.</p>\n<h3>Ne jamais faire confiance à la saisie des utilisateurs</h3>\n<p>Depuis le <strong>corps d’une requête HTTP</strong>, en passant par les <strong>headers</strong> ou encore les <strong>cookies</strong>, toutes ces informations qui peuvent être manipulées par l’utilisateur doivent être considérées comme potentiellement malicieuses.</p>\n<p>L’utilisation naïve des saisies des utilisateurs peut amener à toutes sortes d’attaques:</p>\n<ul>\n<li><a href=\"https://www.w3schools.com/sql/sql_injection.asp\">SQL Injection</a> et <a href=\"https://nullsweep.com/a-nosql-injection-primer-with-mongo/\">NoSQL Injection</a></li>\n<li><a href=\"https://nodesecroadmap.fyi/chapter-1/threat-RCE.html\">Remote code execution</a></li>\n<li><a href=\"https://www.sourceclear.com/vulnerability-database/security/privilege-escalation/javascript/sid-7835\">Privilege escalation</a></li>\n</ul>\n<p>Il est toujours nécessaire de <strong>vérifier et sanitiser</strong> ces données avant de les utiliser dans une application.</p>\n<h3>Limiter les dénis de service (DoS)</h3>\n<p>Les attaques par déni de service tentent de rendre une application indisponible.</p>\n<p>Il est possible, par exemple, <strong>d'envoyer de très grandes requêtes en JSON</strong>, ce qui peut ralentir ou même rendre indisponible votre application.</p>\n<p><em><strong>Atténuer l'attaque</strong>: limiter la taille des requêtes dans les couches basses de votre application, de préférence directement dans les couches réseau.</em></p>\n<p>Si votre backend est écrit en Node.js, il est également nécessaire d'être vigilant lors de la <strong>création de nouvelles promesses</strong>.<br />\nEn effet, une Promesse est <strong>automatiquement envoyée à l'Event Loop</strong> et il est alors <strong>impossible de la retirer</strong> avant sa résolution ou son rejet.</p>\n<p>Un attaquant peut alors envoyer beaucoup de requêtes sur une route générant des promesses et donc <strong>saturer l'Event Loop</strong>.</p>\n<p><em><strong>Atténuer l'attaque</strong>: implémenter un <strong>système de limite de requêtes simultanées</strong> utilisant uniquement des callbacks. Développer avec des callbacks c'est plus compliqué, mais les callbacks ne sont que des pointeurs vers des fonctions n'utilisant aucune ressource jusqu'à ce qu'ils soient invoqués. N'utilisez les promesses <strong>qu'après le système de limite de requêtes</strong>.</em></p>\n<h3>Éviter le bruteforce</h3>\n<p>Afin d’éviter un bruteforce de l’authentification d’un utilisateur, il est nécessaire d’introduire une <strong>limite au nombre de tentative de connexion</strong>.</p>\n<p>Cette limite peut prendre la forme d’un blocage après X tentatives rajouté à la route d’authentification.</p>\n<h3>Stocker les mots de passe de façon sécurisée</h3>\n<p>En 2019, il y avait encore des entreprises qui <a href=\"https://krebsonsecurity.com/2019/03/facebook-stored-hundreds-of-millions-of-user-passwords-in-plain-text-for-years/\">stockent les mots de passes de leurs utilisateurs en clair</a>.</p>\n<p>Cette pratique doit être évitée à tout prix afin de protéger vos utilisateurs en cas de fuite de données de votre application. Pas seulement pour votre propre application : <a href=\"https://www.pandasecurity.com/mediacenter/security/password-reuse/\">la majorité des utilisateurs réutilisent le même mot de passe pour plusieurs comptes</a>. L'impact d'une fuite de mot de passe peut être catastrophique, tant pour vos utilisateurs que pour l'image de votre entreprise.</p>\n<p>Les mots de passe doivent être stockés à l'aide d'une <strong>fonction cryptographique unidirectionnelle</strong> (ou fonction de hachage).</p>\n<p>Le choix de la fonction de hachage doit être basé sur un <strong>algorithme robuste</strong> tel que <a href=\"https://github.com/kelektiv/node.bcrypt.js\">bcrypt</a> par exemple. Si vous le pouvez, renforcez les mots de passe faibles en utilisant du <a href=\"https://en.wikipedia.org/wiki/Key_stretching\">key stretching</a>, et pour une couche de sécurité supplémentaire, vous pouvez également utiliser un <a href=\"https://en.wikipedia.org/wiki/Salt_(cryptography)\">salt</a> et un <a href=\"https://en.wikipedia.org/wiki/Pepper_%28cryptography%29\">pepper</a> sur les mots de passes.</p>\n<h3>Et tellement d'autres!</h3>\n<p>Il y a énormément d’attaques possibles sur un backend, et la plupart sont peu ou pas connues. Certaines sont particulièrement difficiles à détecter et à prévenir :</p>\n<p>Une <strong>simple comparaison de deux chaînes de caractères</strong> peut se donner lieu à une <a href=\"https://www.wikiwand.com/fr/Attaque_temporelle\">attaque temporelle</a> et permettre à un attaquant de deviner un mot de passe ou un token.</p>\n<p>Mais encore l’utilisation d’une <strong>librairie d’expression régulières vulnérable</strong> à une <a href=\"https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\">attaque ReDoS</a>.</p>\n<p>C’est pourquoi la sécurisation d’un backend n’est pas une tâche à prendre à la légère et doit être confiée à des experts en sécurité pour former les développeurs mais aussi auditer le code afin de s’assurer d’avoir le minimum de failles possibles car la <a href=\"https://www.quora.com/Is-perfect-security-possible\">sécurité parfaite n’existe pas</a>.</p>\n<h2>Le mot de la fin</h2>\n<p>Lors du développement d'une application, la sécurité doit être prise en compte du début à la fin et la <strong>réflexion doit couvrir l'ensemble du périmètre de l'application</strong>, du backend au frontend, y compris les canaux de communication et l'hébergement.</p>\n<p>La sécurité coûte cher et est donc souvent négligée. C'est pourquoi il est préférable d'utiliser des frameworks et des backends conçus par des ingénieurs possédant les compétences et connaissances nécessaires pour assurer une sécurité suffisante aux utilisateurs finaux.</p>\n<p>J'aimerais remercier toute l'équipe de <a href=\"https://github.com/kuzzleio\">Kuzzle</a> qui m'a aidé à rédiger cet article et en particulier <a href=\"https://github.com/scottinet/\">Sébastien Cottinet</a> et <a href=\"http://github.com/shiranuit\">Yannick Combes</a> pour leur expertise en sécurité et cryptographie.</p>\n<hr />\n<p><a href=\"https://blog.kuzzle.io/why-you-cant-secure-a-frontend-application\">English version available on Kuzzle blog</a></p>\n"}