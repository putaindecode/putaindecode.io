{"slug":"flow-avance-part-1","filename":"2017-11-23-flow-avance-part-1","title":"Flow avancé - Première partie","date":"Thu, 23 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-23T00:00:00.000Z","title":"Flow avancé - Première partie","author":"zoontek","oldSlug":"js/flow/advanced-part-1","slug":"flow-avance-part-1"},"body":"<p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser\n<a href=\"https://flow.org/en/\">flow</a>, l'outil de Facebook vous permettant d'ajouter du\ntypage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez\nutilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript,\nRuby, Python…), et pour le moment vous vous contentez d'ajouter des annotations\nde types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous\nempêcher de crier sur tous les toits que le typage, c'est quand même chiant et\nlimite une perte de temps puisque flow continue de manquer un tas d'erreurs\npotentielles au sein de votre code. Cet article est là pour vous aider à\ncomprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez\npas flow, il peut servir de chouette introduction un peu poussée à son\nutilisation.</p>\n<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes,\nc'est à dire la 0.59. Pour l'ajouter au sein de votre projet, petit rappel:</p>\n<pre><code class=\"hljs language-sh\">npm install --save-dev flow-bin\nnpm install --save-dev flow-remove-types <span class=\"hljs-comment\"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>\nnpx flow init <span class=\"hljs-comment\"># pour créer le fichier .flowconfig</span>\n</code></pre>\n<p><em>Pour plus d'infos sur npx, c'est <a href=\"https://www.npmjs.com/package/npx\">par ici</a>.\nÀ noter que c'est livré de base avec npm maintenant.</em></p>\n<h2>Rappels sur l'inférence de type</h2>\n<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé\nsi celui-ci est évident à l'usage.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow &lt;- le pragma nécessaire pour indiquer à flow d&#x27;analyser votre fichier. À noter que si vous l&#x27;ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>\n\n<span class=\"hljs-keyword\">const</span> quote = <span class=\"hljs-string\">&quot;Thirouin rouin rouin rouin&quot;</span>;\n<span class=\"hljs-built_in\">Math</span>.round(quote); <span class=\"hljs-comment\">// erreur! le type attendu est un number</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) =&gt; string</span>\nsayHello(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello([<span class=\"hljs-string\">&quot;Mathieu&quot;</span>, <span class=\"hljs-string\">&quot;zoontek&quot;</span>]); <span class=\"hljs-comment\">// erreur: ne peut être un array</span>\n</code></pre>\n<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez\ncarrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une\nvariable peut se montrer plus efficace que d'utiliser des types &quot;génériques&quot;\ntels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le\nfaire).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello: <span class=\"hljs-built_in\">Function</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) =&gt; any</span>\n</code></pre>\n<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la\nsuivante :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\">(<span class=\"hljs-params\">name: string</span>) =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// (name: string) =&gt; string</span>\nsayHello(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<h2>Les types primitifs et litéraux</h2>\n<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous\navez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens\n(<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes\n(<code>void</code>). À noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier\nn'est pas encore supporté par flow.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> a: number = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">const</span> b: string = <span class=\"hljs-string\">&quot;Je ne suis pas Coluche, certes&quot;</span>;\n<span class=\"hljs-keyword\">const</span> c: boolean = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">const</span> d: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">const</span> e: <span class=\"hljs-keyword\">void</span> = <span class=\"hljs-literal\">undefined</span>;\n</code></pre>\n<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des\nvaleurs litérales comme type. Après tout <code>string</code>, ça peut être tout et\nn'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci\nsont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment\nperfectionné, commme vous le verrez par la suite.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-string\">&quot;x&quot;</span> = <span class=\"hljs-string\">&quot;x&quot;</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur! n&#x27;est pas égal à 2</span>\n</code></pre>\n<h2>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>\n<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable\npeut être de n'importe quel type et cela est bien sûr extrêmement dangereux.\nHeureusement, il existe 2 alternatives plus sûres à connaître :</p>\n<ul>\n<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction,\nl'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc\npas y appeler des méthodes spécifiques à un type de variable en particulier.</li>\n<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg);\n} <span class=\"hljs-comment\">// pas d&#x27;erreur: peu importe le type réel du paramètre arg, l&#x27;appel se fera correctement</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg.toUpperCase());\n} <span class=\"hljs-comment\">// erreur! arg pourrait ne pas être une string</span>\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Array</span>&lt;*&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// inféré en Array&lt;number&gt;</span>\nbaz.push(<span class=\"hljs-string\">&quot;Hello&quot;</span>); <span class=\"hljs-comment\">// &quot;foo&quot; est maintenant inféré en Array&lt;number | string&gt; (tableau de string ou de numbers)</span>\n</code></pre>\n<h2>Les types optionnels (ou maybe types)</h2>\n<p>Si vous avez déjà utilisé un langage qui essaye d'éviter\n<a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\">l'erreur à un milliard de dollars</a>,\nvous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la\npossible absence d'une valeur et sont ici symbolisés à l'aide d'un point\nd'interrogation.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">let</span> foo: ?string; <span class=\"hljs-comment\">// peut-être une string, null ou undefined</span>\nfoo = <span class=\"hljs-string\">&quot;foo&quot;</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur - number n&#x27;est ni une string, ni null, ni undefined</span>\n\ntype Bar = {\n  baz?: string, <span class=\"hljs-comment\">// baz sera forcément une string si elle est présente</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">wrongToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// erreur, str est possiblement nul, vous devez traiter ce cas</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">correctToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str === <span class=\"hljs-string\">&quot;string&quot;</span>) {\n    <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n  }\n}\n</code></pre>\n<h2>Les types génériques (generics)</h2>\n<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&lt;any&gt;</code>) croisée plus tôt?\nIl s'agit de ce qu'on appelle un type générique : un type construit depuis un\nautre type. Ainsi, si <code>Array&lt;any&gt;</code> symbolise un tableau de tout et n'importe\nquoi, <code>Array&lt;number&gt;</code> symbolisera un tableau de numbers, etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-comment\">// on crée un type Classement qui prend en &quot;paramètre&quot; un type générique qu&#x27;on nomme &quot;T&quot;</span>\ntype Classement&lt;T&gt; = {\n  <span class=\"hljs-attr\">first</span>: T,\n  <span class=\"hljs-attr\">second</span>: T,\n  <span class=\"hljs-attr\">third</span>: T,\n};\n\n<span class=\"hljs-keyword\">const</span> numberClassement: Classement&lt;number&gt; = {\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-number\">7</span>,\n  <span class=\"hljs-attr\">third</span>: <span class=\"hljs-number\">1</span>,\n};\n</code></pre>\n<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [];\n\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-built_in\">Map</span>&lt;number, string&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\nbar.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;one&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Set</span>&lt;number&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();\nbaz.add(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">const</span> p: <span class=\"hljs-built_in\">Promise</span>&lt;number&gt; = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">42</span>);\n</code></pre>\n<h2>La manipulation d'objets</h2>\n<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au\nsein de mes exemples (oui, c'était chiant)? C'est tout simplement car les\npossibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous\npropose un exemple fleuve histoire d'y voir plus clair.</p>\n<p>Un type objet se définit de la sorte :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  <span class=\"hljs-attr\">name</span>: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\n<span class=\"hljs-comment\">// Ce qui n&#x27;exclut pas de faire</span>\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {|\n  name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n|};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,\n}; <span class=\"hljs-comment\">// erreur! la propriété age n&#x27;existe pas</span>\n</code></pre>\n<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la\nnotation <code>+</code>. Un must-have pour vos reducers Redux.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  +name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\nuser.name = <span class=\"hljs-string\">&quot;Jean-Michel&quot;</span>; <span class=\"hljs-comment\">// erreur! la valeur de name ne peut-être modifiée</span>\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Jean-Michel&quot;</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<blockquote>\n<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>\n</blockquote>\n<p>Yep.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = {| a: number, <span class=\"hljs-attr\">b</span>: string |};\ntype Bar = {| a: string |};\ntype Baz = {| ...Foo, ...Bar |}; <span class=\"hljs-comment\">// {| a: string, b: string |}</span>\n</code></pre>\n<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser\ncomme maps :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: { [key: string]: number } = {\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&quot;whatever&quot;</span>, <span class=\"hljs-comment\">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>\n};\n</code></pre>\n<h2>Les unions et intersections de types</h2>\n<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la\nquestion de ce que ça représente. Il s'agit d'une union de types : la variable\naura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours\nune union de types litéraux à la place du simple <code>string</code> lorsque vous\nconnaissez à l'avance les possibles valeurs de celui-ci.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHelloOrRound</span>(<span class=\"hljs-params\">arg: string | number</span>) </span>{\n  <span class=\"hljs-comment\">// arg peut être une string ou un number</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> arg === <span class=\"hljs-string\">&quot;string&quot;</span> ? <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${arg}</span>`</span> : <span class=\"hljs-built_in\">Math</span>.round(arg);\n} <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n\ntype Color = <span class=\"hljs-string\">&quot;red&quot;</span> | <span class=\"hljs-string\">&quot;green&quot;</span> | <span class=\"hljs-string\">&quot;blue&quot;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toHexadecimal</span>(<span class=\"hljs-params\">color: Color</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span> (color) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;red&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#FF0000&quot;</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;green&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#00FF00&quot;</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;blue&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#0000FF&quot;</span>;\n  }\n}\n\ntoHexadecimal(<span class=\"hljs-string\">&quot;red&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;green&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;blue&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;pink&quot;</span>); <span class=\"hljs-comment\">// erreur! &quot;pink&quot; n&#x27;est pas une valeur possible</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;dog&quot;</span>); <span class=\"hljs-comment\">// erreur! &quot;dog&quot; n&#x27;est pas une valeur possible</span>\n</code></pre>\n<p>Parfois, une union de types se montre également bien plus efficace pour\nmodéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype ApiResponseBadlyTyped = {|\n  success: boolean,\n  value?: string, <span class=\"hljs-comment\">// value peut être présent</span>\n  error?: <span class=\"hljs-built_in\">Error</span>, <span class=\"hljs-comment\">// error peut être présent</span>\n|};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// pas d&#x27;erreur alors que j&#x27;attends une value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>) }; <span class=\"hljs-comment\">// pas d&#x27;erreur non plus</span>\n\ntype ApiResponseCorrectlyTyped =\n  | {| success: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: string |}\n  | {| success: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-built_in\">Error</span> |};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseCorrectlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// erreur! il manque value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseCorrectlyTyped = {\n  <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>),\n}; <span class=\"hljs-comment\">// erreur! si success est à true, on ne doit pas trouver d&#x27;error dans notre objet</span>\n<span class=\"hljs-keyword\">const</span> baz: ApiResponseCorrectlyTyped = {\n  <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>),\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les\nintersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&amp;</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = { <span class=\"hljs-attr\">a</span>: number };\ntype Bar = { <span class=\"hljs-attr\">b</span>: string };\ntype Baz = { <span class=\"hljs-attr\">c</span>: boolean };\n\n<span class=\"hljs-keyword\">const</span> test: Foo &amp; Bar &amp; Baz = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;whatever&quot;</span>,\n  <span class=\"hljs-attr\">c</span>: <span class=\"hljs-literal\">true</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n\n<span class=\"hljs-keyword\">let</span> impossible: number &amp; string; <span class=\"hljs-comment\">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span>\n</code></pre>\n<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la\nsurface de ce qui nous est offert par flow et les systèmes de typage fort en\ngénéral. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie\nvers la <a href=\"https://flow.org/en/docs/\">documentation de flow</a>, très bien foutue.\nPour les autres, on devrait sortir très prochainement un article sur le même\nsujet (on y parlera classes, interfaces et peut être même types opaques si vous\nêtes sages).</p>\n<p>Stay tuned! La bise.</p>\n"}