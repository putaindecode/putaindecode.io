{"slug":"la-programmation-reactive-avec-rxjs","filename":"2017-11-16-la-programmation-reactive-avec-rxjs","title":"La programmation reactive avec RxJS","date":"Thu, 16 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-16T00:00:00.000Z","title":"La programmation reactive avec RxJS","author":"wyeo","oldSlug":"js/observable/programmation-reactive","slug":"la-programmation-reactive-avec-rxjs"},"body":"<p>La <a href=\"https://www.reactivemanifesto.org/fr\">programmation réactive</a> est un\nparadigme de programmation dont le concept repose sur l'émission de données\ndepuis une ou plusieurs sources (producteurs) à destinations d'autres éléments\nappelés <em>consommateurs</em>. Elle repose sur le design pattern\n<a href=\"http://design-patterns.fr/observateur\">Observable - Observer</a>.</p>\n<p>Dans ce paradigme, on traite toutes les données, quelles qu'elles soient, de la\nmême façon: au travers de flux. Un flux, c'est en gros une structure qui balance\nune ou plusieurs données dans le temps au travers d'observables, comme on l'a vu\ndans le <a href=\"/fr/articles/js/observable/\">post précédent</a>.</p>\n<p><img src=\"https://i.imgur.com/NLqK4bF.png\" alt=\"Programmation Réactive\" /></p>\n<p>Un flux, pour résumer, c'est simplement de la donnée qui arrive de manière\nordonnée dans le temps. Comme expliqué précédemment, trois types de signaux\npeuvent être émis par un flux : une valeur, une erreur ou un signal de fin\nindiquant que le flux n'a plus de données à envoyer.</p>\n<p>L'idée des flux, c'est cool, mais comment on manipule ça ?</p>\n<h2>La bibliothèque RxJS</h2>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.md\">RxJS</a>\nest l'implémentation JavaScript de <a href=\"http://reactivex.io/\">ReactiveX</a>,\n<em>extensions-réactives</em> en français, un projet visant à implémenter sous la forme\nde bibliothèque les outils nécessaire pour utiliser le paradigme réactif dans de\nmultiples languages. Aussi appelé le <strong>Lodash</strong> des données asynchrones, il\nimplémente la notion d'observables-observer et fournit tout un panel\nd'opérateurs pour travailler avec les données qui y passent.</p>\n<p>Vous pourrez facilement intégrer progressivement Rx à votre codebase à l'aide\nd'opérateurs tels que <code>Rx.from</code> (qui crée un observable à partir d'une valeur\nsynchrone), <code>Rx.fromEvent</code> (qui va carrément écouter les évenement DOM d'un\nélement pour en faire un observable), <code>Rx.fromPromise</code>, <code>Rx.Ajax</code> et bien\nd'autres.</p>\n<p>Exemple tout simple : on va compter le nombre de clics sur un bouton.</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"hljs-keyword\">const</span> Rx = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;rxjs&#x27;</span>)\n\n<span class=\"hljs-comment\">// on écoute les clics</span>\n<span class=\"hljs-keyword\">const</span> button$ = Rx.Observable.fromEvent(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;button&quot;</span>), <span class=\"hljs-string\">&quot;click&quot;</span>)\n  <span class=\"hljs-comment\">// scan est l&#x27;équivalent de reduce ; il va garder l&#x27;accumulateur et retourner le nouveau à chaque clic</span>\n  .scan(<span class=\"hljs-function\"><span class=\"hljs-params\">count</span> =&gt;</span> count + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)\n  .subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">clickCount</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// on met ça dans le DOM à chaque changement</span>\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;count&quot;</span>).innerHTML = <span class=\"hljs-string\">&quot;You clicked &quot;</span> + clickCount + <span class=\"hljs-string\">&quot; times&quot;</span>\n  })\n</code></pre>\n<p>Si vous vous demandez pourquoi <code>button$</code> et pas <code>button</code>, c'est que le suffixe\n<strong>$</strong> est une convention montrant qu'il s'agit d'un flux.</p>\n<p>La programmation réactive peut être compliquée à se représenter, ainsi, pour\nmieux la visualiser, il existe les <a href=\"http://rxmarbles.com/\"><code>marbles diagrams</code></a>\nqui vous permettront de mettre en rapport entrée et sortie de chaque\ntransformation de la data avec une idée plus concrète que de simples bouts de\ncode.</p>\n<p>Le cœur de la programmation réactive, c'est de concevoir votre programme comme\nquelque chose qui est valable à n'importe quel point dans le temps, et c'est son\navantage principal. Si une donnée change, toutes les parties de votre programme\nl'utilisant en seront notifiées et pourront agir en conséquence.</p>\n<p>Si vos programmes récupèrent des données de manière asynchrone (et il y a de\nfortes chances pour que ce soit le cas), ça peut valoir le coup de jeter un œil\nà ce paradigme, vous pourrez peut-être vous enlever un paquet d'épines du pied.</p>\n<p>Dans le prochain chapitre, nous verrons les cas d'usages des Observables au sein\nd'une application React/Redux.</p>\n"}