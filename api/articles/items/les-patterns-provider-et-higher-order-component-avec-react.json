{"slug":"les-patterns-provider-et-higher-order-component-avec-react","filename":"2016-06-14-les-patterns-provider-et-higher-order-component-avec-react","title":"Les patterns Provider & Higher-Order Component avec React","date":"Tue, 14 Jun 2016 00:00:00 GMT","draft":false,"meta":{"date":"2016-06-14T00:00:00.000Z","title":"Les patterns Provider & Higher-Order Component avec React","author":"bloodyowl","oldSlug":"js/react/higher-order-component","slug":"les-patterns-provider-et-higher-order-component-avec-react"},"body":"<h2>Le pattern provider</h2>\n<p>Beaucoup de bibliotèques React ont besoin de faire passer des data au travers de\ntout l'arbre de composants de votre app. Par exemple Redux a besoin de passer\nson <em>store</em> et React Router doit passer l'objet <em>location</em>. Tout ça pourrait\npossiblement passer par du <em>shared mutable state</em> (état global mutable, ce qui\nest rarement une bonne idée). Le <em>shared mutable state</em> rend impossible une\napplication à plus d'un contexte. En d'autres mots, ça ne marcherait que sur le\nclient, où l'état global correspond à celui de l'utilisateur. Si vous décidez de\nrendre la page côté serveur, c'est impossible de reposer sur une telle\nimplémentation : cet état ne doit pas dépasser le scope de la requête courante\nau serveur.</p>\n<p>Coup de bol, l'API de React nous offre une solution à ce problème: le\n<a href=\"http://facebook.github.io/react/docs/context.html\"><code>context</code></a>. Si l'on résume\nsa nature, c'est comme l'objet global de votre arbre de composants.</p>\n<p>Le <code>context</code> fonctionne de la façon suivante:</p>\n<ul>\n<li>On définit haut dans notre app un <code>context</code> que l'on donne aux composants\ndescendants de l'app</li>\n<li>On récupère ce contexte dans les composants descendants.</li>\n</ul>\n<p>Du coup, pour <em>donner</em> ce <code>context</code>, on doit avoir un <code>Provider</code>. Son rôle est\nsimplement de fournir un <code>context</code> pour que les composants enfants y aient\naccès.</p>\n<p>On va illustrer ce pattern avec un use-case très simple : dans notre app, les\nutilisateurs peuvent customiser le thème.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component, PropTypes, Children } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThemeProvider</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// la méthode getChildContext est appelée pour fournir le `context`</span>\n  <span class=\"hljs-comment\">// dans notre cas, on le récupère des `props`</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-built_in\">this</span>.props.theme,\n    };\n  }\n  <span class=\"hljs-comment\">// on render l&#x27;enfant</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> Children.only(<span class=\"hljs-built_in\">this</span>.props.children);\n  }\n}\n\nThemeProvider.propTypes = {\n  <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired,\n};\n\n<span class=\"hljs-comment\">// pour que React prenne en compte le context fourni,</span>\n<span class=\"hljs-comment\">// on doit définir les types des propriétés que l&#x27;on passe</span>\nThemeProvider.childContextTypes = {\n  <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> ThemeProvider;\n</code></pre>\n<p>Pour utiliser le provider, il suffit de wrapper notre app avec:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom&quot;</span>;\n\n<span class=\"hljs-keyword\">import</span> ThemeProvider <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;ThemeProvider&quot;</span>;\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;App&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> theme = {\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;#cc3300&quot;</span>,\n  <span class=\"hljs-attr\">fontFamily</span>: <span class=\"hljs-string\">&quot;Georgia&quot;</span>,\n};\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeProvider</span> <span class=\"hljs-attr\">theme</span>=<span class=\"hljs-string\">{theme}</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeProvider</span>&gt;</span></span>,\n  <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&quot;#App&quot;</span>),\n);\n</code></pre>\n<p>Maintenant que notre <code>theme</code> est bien ajouté au <code>context</code>, on a besoin d'un\nmoyen simple pour que nos composants dans l'app puissent le consommer. Ça nous\namène au second pattern.</p>\n<h2>Le pattern Higher-Order Component</h2>\n<p>Afin de consommer le <code>context</code>, un component doit définir une propriété statique\n<code>contextTypes</code> stipulant quelles propriétés le composant souhaite récupérer. On\npourrait le définir sur chaque composant, mais cela serait une mauvaise idée\npour deux raisons :</p>\n<ul>\n<li><strong>La maintenabilité</strong> : si à un moment, on a besoin de refacto, avoir tous ces\n<code>contextTypes</code> éparpillés dans notre repository peut faire bien mal.</li>\n<li><strong>La complexité</strong>: L'API des <code>context</code> étant encore obscure pour beaucoup, il\nest préférable de faire une abstraction pour la masquer.</li>\n</ul>\n<p>Une autre solution serait d'utiliser l'héritage d'une sous-classe de\n<code>ReactComponent</code>. Ça ne marche pas pour deux raisons:</p>\n<ul>\n<li>Plus d'un niveau d'héritage est en général une idée de merde. Cela mène\nsouvent à des conflits entre méthodes, et force à vérifier toute la chaîne\nd'héritage à chaque fois que l'on souhaite modifier quelque chose. L'API des\n<code>mixins</code> de <code>React.createClass</code> réglait ce souci en définissant des\ncomportements de merge selon les méthodes, mais cela rend encore plus obscure\nla compréhension du fonctionnement de nos composants.</li>\n<li>Si l'on veut des APIs <strong>interopérables</strong>, on ne peut pas partir de l'héritage.\nReact offre trois moyens de définir un composant:\n<code>class extends React.Component {}</code>, <code>React.createClass({})</code> et\n<code>(props) =&gt; ReactElement</code>. Les deux derniers ne peuvent pas bénéficier de\nl'héritage.</li>\n</ul>\n<p>La meilleure façon de créer une fonctionnalité réutilisable est d'utiliser le\npattern du <strong>Higher Order Component</strong> (ou <em>HOC</em>). Ce que ça veut dire, c'est\nqu'on va simplement wrapper un composant dans un autre, lequel a pour unique\nrôle d'injecter la fonctionnalité et de la passer via les <code>props</code>. Il s'agit\ntout bêtement du principe de composition : au lieu d'exporter <code>A</code>, vous exportez\n<code>Wrapped(A)</code>, et ce dernier retourne un composant React qui va appeler <code>A</code> dans\nsa méthode <code>render</code>.</p>\n<p>Pour le voir simplement, il s'agit d'un point intermédiaire dans l'arbre de vos\ncomposants, qui injecte quelques <code>props</code>. Il existe beaucoup d'avantages\napportés par ce pattern :</p>\n<ul>\n<li><strong>Isolation</strong> : Il n'y a pas de risque de collision de propriétés au sein du\ncomposant.</li>\n<li><strong>Interopérabilité</strong> : Ce principe s'adapte à tout composant React, peu\nimporte la façon dont il a été défini.</li>\n<li><strong>Maintenabilité</strong> : Le wrapper n'aura qu'une seule fonctionnalité, ce qui le\nrend plus simple à comprendre. De plus, si l'on utilise le <code>context</code>, on ne\ntrouvera le mapping <code>contextTypes</code> qu'à un seul endroit dans l'app.</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component, PropTypes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> themed = <span class=\"hljs-function\">(<span class=\"hljs-params\">ComponentToWrap</span>) =&gt;</span> {\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThemeComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">const</span> { theme } = <span class=\"hljs-built_in\">this</span>.context\n      <span class=\"hljs-comment\">// le component va render `ComponentToWrap`</span>\n      <span class=\"hljs-comment\">// mais il va y ajouter la prop `theme`, qu&#x27;il récupère du `context`</span>\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentToWrap</span> {…<span class=\"hljs-attr\">this.props</span>} <span class=\"hljs-attr\">theme</span>=<span class=\"hljs-string\">{theme}</span> /&gt;</span></span>\n      )\n    }\n  }\n  <span class=\"hljs-comment\">// on définit ce qu&#x27;on veut consommer du `context`</span>\n  ThemeComponent.contextTypes = {\n    <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired,\n  }\n\n  <span class=\"hljs-comment\">// on retourne notre wrapper</span>\n  <span class=\"hljs-keyword\">return</span> ThemeComponent\n}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> themed\n</code></pre>\n<p>Pour utiliser notre HOC, il suffira d'exporter nos composants wrappés :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;React&quot;</span>;\n<span class=\"hljs-keyword\">import</span> themed <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;themed&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> MyStatelessComponent = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ text, theme }</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.color</span> }}&gt;</span>{text}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> themed(MyStatelessComponent);\n</code></pre>\n<p>Puisqu'il s'agit simplement d'une fonction, on peut y passer des options à\nl'aide d'une simple closure.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> defaultMergeProps = <span class=\"hljs-function\">(<span class=\"hljs-params\">ownProps, themeProps</span>) =&gt;</span> ({  ...ownProps, ...themeProps })\n\n<span class=\"hljs-keyword\">const</span> theme = <span class=\"hljs-function\">(<span class=\"hljs-params\">mergeProps = defaultMergeProps</span>) =&gt;</span>\n  <span class=\"hljs-function\">(<span class=\"hljs-params\">ComponentToWrap</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// …</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">const</span> { theme } = <span class=\"hljs-built_in\">this</span>.context\n      <span class=\"hljs-keyword\">const</span> props = mergeProps(<span class=\"hljs-built_in\">this</span>.props, { theme })\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentToWrap</span> {…<span class=\"hljs-attr\">props</span>} /&gt;</span></span>\n      )\n    }\n    <span class=\"hljs-comment\">// …</span>\n  }\n</code></pre>\n<p>et l'utiliser de cette façon :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> mergeProps = <span class=\"hljs-function\">(<span class=\"hljs-params\">ownProps, themeProps</span>) =&gt;</span> ({\n  ...themeProps,\n  <span class=\"hljs-attr\">color</span>: themeProps.theme.color,\n});\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> theme(mergeProps)(MyComponent);\n</code></pre>\n<p>Une astuce sympathique lorsque vous utilisez plusieurs HOC, c'est de les\ncomposer, puisque <code>compose(A, B, C)(props)</code> vaudra <code>A(B(C(props)))</code>, par exemple\n:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> composed = compose(\n  connect(mapStateToProps),\n  theme(),\n);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> composed(MyComponent);\n</code></pre>\n<p>Bisous bisous.</p>\n"}