{"slug":"du-css-evolutif","filename":"2015-03-10-du-css-evolutif","title":"Du CSS évolutif","date":"Tue, 10 Mar 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-03-10T00:00:00.000Z","title":"Du CSS évolutif","author":"magsout","oldSlug":"css/bem/maintenance-evolutivite","slug":"du-css-evolutif"},"body":"<p>Modulaire, maintenable, réutilisable, accessible. Ces termes sont au cœur de nos\nmétiers et on nous les rabâche toute la journée.</p>\n<p>Malgré la grossièreté de ces mots pour certains d'entre vous, il est tout à fait\npossible de pondre du CSS en utilisant tous ces principes.</p>\n<h2>Maintenable</h2>\n<p>L'un des trucs les plus chiants du CSS c'est bien la cascade, qui, malgré sa\nbonne volonté, n'apporte pas que des solutions. Pour pallier aux problèmes que\nl'on peut vite créer, <a href=\"/fr/articles/css/bem/\">la méthodologie BEM</a> a vu le jour\navec son\n<a href=\"http://blog.kaelig.fr/post/48196348743/fifty-shades-of-bem\">lot de variantes</a>.</p>\n<p>La grande majorité des membres de p! utilisent cette convention :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.MyComponent</span> {\n}\n<span class=\"hljs-selector-class\">.MyComponent</span><span class=\"hljs-selector-class\">.is-state</span> {\n}\n<span class=\"hljs-selector-class\">.MyComponent--modifier</span> {\n}\n\n<span class=\"hljs-selector-class\">.MyComponent-element</span> {\n}\n<span class=\"hljs-selector-class\">.MyComponent-anotherElement</span> {\n}\n</code></pre>\n<p>D'un coup d'œil, on devine la structure <code>HTML</code> qui en découle et l'utilité de\nchaque élément. Les états sont toujours les mêmes et clairement identifiables\ncar commençant par <code>is-*</code>, de même que les éléments définis par <code>-</code> ainsi que\nles modificateurs <code>--</code>.</p>\n<p>Avec cette méthodologie rares sont les sélecteurs dépassant :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.MyComponent-element</span> <span class=\"hljs-selector-class\">.MyComponent-anotherElement</span> {\n}\n</code></pre>\n<p>L'intérêt ? Apporter de la sémantique à notre code CSS, en utilisant des\nclasses, des classes et des classes afin de clairement s'abstraire de la\ncascade. Finis les <code>!important</code>, on évite ainsi les problèmes d'éléments et les\nsoudains changements de structure HTML qui te forcent à réécrire tes sélecteurs.</p>\n<p>Cette méthode est d'ailleurs, entre autres, utilisée par\n<a href=\"http://twitter.com\">Twitter</a> via <a href=\"http://suitcss.github.io/\">SUIT CSS</a>.</p>\n<h2>Modulaire</h2>\n<p>Partant de notre méthodologie, on va développer notre site web comme un gros\nLego. Chaque partie graphique de notre projet sera un composant, une brique.</p>\n<p>On pourrait imaginer des éléments comme <code>NavBar</code>, <code>Pagination</code>, <code>Article</code> que\nl'on va assembler au fur et à mesure de notre développement. Notre site sera\ncomposé de plusieurs dizaines de fichiers (<code>Composant</code>), mais aucun n'excèdera\nquelques centaines de lignes, grand maximum. Beaucoup plus facile à débugger et\ndonc sur le long terme plus maintenable.</p>\n<p>Il va de soi qu'on utilisera son outil préféré pour concaténer et minimiser le\ntout en un seul fichier, sinon on risque d'avoir quelques problèmes de\n<em>webperf</em>.</p>\n<h2>Accessible</h2>\n<p>Pour obtenir un design adaptatif ou accessible, il est nécessaire d'utiliser des\nunités dites relatives. C'est à ce moment qu'interviennent les unités stars du\nmoment que sont <code>em</code> et <code>rem</code>.</p>\n<p>Mais voilà que <code>em</code> rencontre un inconvénient majeur, encore et toujours notre\nfameuse cascade. Chaque élément dépend de son propre <code>font-size</code> ou de celui de\nson parent. Alors, vous imaginez l'élément de l'élément de l'élément. On peut\nvite perdre les pédales. Je vous vois venir avec l'unité <code>rem</code>. Effectivement on\nrésout complètement le problème de la cascade, mais on perd en modularité.</p>\n<p>Prenons notre exemple de <code>NavBar</code>, voici comment on pourrait commencer ce\ncomposant :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.NavBar</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n}\n<span class=\"hljs-selector-class\">.NavBar-item</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0.875em</span>;\n  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">1em</span>;\n}\n</code></pre>\n<p>Notre classe principale étant définie en <code>rem</code>, il devient alors très facile de\ncalculer l'ensemble de ces <code>-item</code> en <code>em</code>. On diminue ainsi de nouveau les\nproblèmes de cascade. De plus, on peut très facilement augmenter la taille\ngénérale de notre composant, en augmentant la taille de son <code>font-size</code> dans sa\nclasse principale. On atteint alors un double objectif : en plus d'être\naccessible en supprimant les pixels, on rend notre composant réutilisable sur\nd'autres projets en s'adaptant très facilement à son contexte.</p>\n<h2>Namespace</h2>\n<p>On utilise tous des scripts <code>vendors</code>. Pour éviter les collisions avec ceux-ci\net encore une fois à cause de cette maudite cascade, voici un petit truc qui\nvous évitera de modifier vos classes : l'ajout d'un namespace à nos composants.</p>\n<p>On va utiliser notre exemple de tout à l'heure avec <code>NavBar</code> :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.putainde-NavBar</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n}\n<span class=\"hljs-selector-class\">.putainde-NavBar-item</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0.875em</span>;\n  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">1em</span>;\n}\n</code></pre>\n<h2>Pour finir</h2>\n<p>C'est verbeux, on ne peut pas le nier. Par moment, on peut se dire qu'écrire une\nclasse seulement pour une propriété, est-ce si pertinent que ça ? Sauf qu'au\nmoment ou vous écrivez votre <code>css</code> vous ne pouvez pas dire qu'à la prochaine\nmise à jour, il vous faudra peut-être en rajouter 5, et donc votre classe sera\nfinalement bien utile.</p>\n<p>Toutes ces méthodes m'ont fait abandonner <code>Sass</code> et son framework <code>Compass</code>. Ce\nqu'apporte un langage comme <code>Sass</code> (au-delà de l'aspect programmation, mais\nc'est une autre histoire) vient principalement de ses features telles que\n<a href=\"http://sass-lang.com/documentation/file.SASS_REFERENCE.html#nested_rules\">nested</a>\net\n<a href=\"http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend\">@extend</a>.\nEt franchement, une bonne indentation, un bon nommage de classes et une\nutilisation intelligente de <code>BEM</code> vous feront vite oublier <code>Sass</code> sans regarder\nen arrière.</p>\n<p>Sur l'ensemble de mes projets, je n'écris plus que ce qu'on appelle communément\ndu <code>Vanilla CSS</code>. Petit bémol quand même, histoire de pouvoir utiliser des\nspécifications pas forcément encore compatibles sur tous les navigateurs, j'ai\najouté dans mon workflow l'outil <a href=\"https://github.com/postcss/postcss\">PostCSS</a>,\nle tout contrôlé par <a href=\"http://cssnext.github.io/\">cssnext</a> dont voici quelques\nexemples d'<a href=\"https://cssnext.github.io/cssnext-playground/\">utilisation</a>.</p>\n<p>Je vous encourage vivement à tester ces deux outils\n(<a href=\"https://github.com/postcss/postcss\">PostCSS</a> ou\n<a href=\"http://cssnext.github.io/\">cssnext</a>) qui vous apporteront variables,\nmanipulation des couleurs, etc, ainsi que concaténation des <code>@import</code> tout en\nconservant du CSS valide (selon les spécifications).</p>\n<h2>Le truc du moment</h2>\n<p>Avant de terminer cet article, je voulais mentionner l'idée/concept qui commence\nà faire son petit bout de chemin à savoir le <code>style inline</code>.</p>\n<p>Cela revient tout simplement à écrire directement le CSS dans son code <code>HTML</code></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;font-size:1rem&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;font-size:.875em; padding:1em&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Avant d'hurler au blasphème ou au scandale, il est nécessaire de mettre en\nadéquation cette idée avec les contraintes rencontrées lors du développement\nd'une application utilisant principalement du <code>JavaScript</code>.</p>\n<p>Si vous souhaitez un peu plus d'informations sur le sujet, je vous invite à lire\nla <a href=\"https://speakerdeck.com/vjeux/react-css-in-js\">présentation</a> de\n<a href=\"https://twitter.com/Vjeux\">@Vjeux</a>, front-end engineer chez Facebook. Il\nexplique les problèmes rencontrés avec le <code>CSS</code> et les solutions mises en place\npar les développeurs de Facebook ou plus exactement de <code>React</code>.</p>\n"}