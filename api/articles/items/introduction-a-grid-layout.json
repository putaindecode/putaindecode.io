{"slug":"introduction-a-grid-layout","filename":"2016-01-05-introduction-a-grid-layout","title":"Introduction à Grid Layout","date":"Tue, 05 Jan 2016 00:00:00 GMT","draft":false,"meta":{"date":"2016-01-05T00:00:00.000Z","title":"Introduction à Grid Layout","author":"magsout","oldSlug":"css/grilles/grid-layout","slug":"introduction-a-grid-layout"},"body":"<p>La mise en page d'un site ou d'une application est toujours quelque chose de\ncomplexe et fastidieux à développer/maintenir. Pour cela, de nombreux designs\nsont élaborés à partir d'une grille. En effet, l'objectif de la grille est de\nservir de base pour placer les différents éléments et de faire en sorte qu'ils\nsoient alignés et espacés uniformément. Le problème de CSS est qu'il rencontre\nbeaucoup de lacunes pour mettre en place cette logique.</p>\n<p>L'arrivée du module <code>Flexbox</code> a commencé à bien faciliter les choses. Toutefois,\nce module n'est pas adapté à toutes les situations et il est bien plus pertinent\nsur du layout de composants.</p>\n<p>C'est pour cette raison qu'a été développé le module <code>Grid Layout</code>, plus\npuissant et orienté mise en page.</p>\n<h2>État des lieux</h2>\n<p>Parlons des choses qui fâchent dès le début. À l'heure actuelle la dernière\nrévision date du <a href=\"http://www.w3.org/TR/css-grid-1/\">17 septembre 2015</a> et la\nspécification en est toujours à l'état de <em>working draft</em>.</p>\n<p>La compatibilité des\n<a href=\"http://caniuse.com/#feat=css-grid\">navigateurs est quelque peu limitée</a>.\nExcepté Internet Explorer 10+ (Edge également), il est nécessaire d'activer le\nflag <code>layout.css.grid.enabled</code> dans Firefox et\n<code>experimental Web Platform features</code> pour Chrome pour activer le support du\nmodule.</p>\n<p>Autant dire qu'une utilisation en production est relativement prématurée, quand\nbien même cela ne doit pas nous empêcher d'expérimenter ce module.</p>\n<h2>Grid</h2>\n<p>La notion de Grid n'est pas nouvelle, de multiples frameworks/librairies\nutilisent déjà la mise en page en <code>Grid</code> :</p>\n<ul>\n<li><a href=\"https://github.com/suitcss/components-grid\">SUIT CSS components-grid</a></li>\n<li><a href=\"http://foundation.zurb.com/docs/components/grid.html\">Zurb Foundation</a></li>\n<li><a href=\"http://960.gs/\">960</a></li>\n<li><a href=\"https://github.com/cssrecipes/grid\">cssrecipes Grid</a></li>\n</ul>\n<p>Toutes ces solutions se basent soit sur du <code>inline-block</code>, soit plus récemment\nsur <code>Flexbox</code>. Même si elles sont relativement élégantes, elles nécessitent\nquand même quelques petits hacks ou tricks pour réussir à faire quelque chose de\ncohérent (hello, <code>font-size: 0</code>, gouttière, <code>calc</code> avec marge négative, etc.).\nLa raison est simple : les techniques utilisées ne sont pas adaptées pour un\nsystème complet de <code>Grid</code>.</p>\n<h2>Thinking in Grid</h2>\n<p>De façon à pouvoir présenter une partie de la spécification, nous allons partir\nsur cette mise en page :</p>\n<p><img src=\"/public/images/articles/2016-01-05-introduction-a-grid-layout/maquette.png\" alt=\"Maquette Grid Layout\" /></p>\n<p>Avant de commencer à présenter les différentes propriétés, réfléchissons au\nconcept de <code>Grid</code>.</p>\n<h3>Grid lines</h3>\n<p>Si on applique cette notion à notre maquette, voici ce qu'on obtient :</p>\n<p><img src=\"/public/images/articles/2016-01-05-introduction-a-grid-layout/grid-line.png\" alt=\"Caniuse Grid Layout\" /></p>\n<p>Concrètement, cela consiste à découper notre interface de façon à pouvoir en\nextraire une grille et ainsi virtualiser la position et l'espace pris pour\nchaque élément.</p>\n<p>On va donc pouvoir extrapoler notre UI en lignes (<code>rows</code>), en colonnes\n(<code>columns</code>), en cellules (<code>cells</code>) et en zones (<code>areas</code>).</p>\n<p>Cette dernière notion (<code>areas</code>) est peut-être nouvelle dans la théorie, mais va\ns'avérer très utile dans la pratique pour la suite.</p>\n<h2>Grid Layout</h2>\n<p>On dispose de suffisamment d'informations sur notre interface pour démarrer\n(enfin) notre intégration.</p>\n<p>Voici le markup que l'on va utiliser pour notre maquette.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;Layout&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;Header&quot;</span>&gt;</span>Header<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">aside</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;Aside&quot;</span>&gt;</span>Aside<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">aside</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;Main&quot;</span>&gt;</span>\n    Main\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;Footer&quot;</span>&gt;</span>Footer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Dans un premier temps, nous allons &quot;configurer&quot; notre <code>Grid</code>:</p>\n<pre><code class=\"hljs language-CSS\"><span class=\"hljs-selector-class\">.Layout</span> {\n  <span class=\"hljs-comment\">/*\n   * On déclare un nouveau contexte dans le parent\n   * qui devient alors un grid-container\n   * tous les enfants deviennent des grid-items\n   */</span>\n   <span class=\"hljs-attribute\">display</span>: grid;\n\n  <span class=\"hljs-comment\">/* Configuration de notre canvas */</span>\n\n  <span class=\"hljs-comment\">/*\n   * On définit le nombre de colonnes :\n   * - la première fera 200px de large\n   * - la deuxième fera 10px de large\n   * - la troisième prendra tout l&#x27;espace restant\n   */</span>\n   <span class=\"hljs-attribute\">grid-template-columns</span>: <span class=\"hljs-number\">200px</span> <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">1</span>fr;\n\n  <span class=\"hljs-comment\">/*\n   * Cette fois-ci au tour des lignes :\n   * - la première fera 70px de haut\n   * - la deuxième fera 10px de haut\n   * - la troisième ligne s&#x27;adaptera à la hauteur de son contenu\n   * - la quatrième fera 50px de haut\n   */</span>\n   <span class=\"hljs-attribute\">grid-template-rows</span>: <span class=\"hljs-number\">70px</span> <span class=\"hljs-number\">10px</span> auto <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">50px</span>;\n\n  <span class=\"hljs-comment\">/*\n   * On peut utiliser grid qui est le raccourci\n   * des deux propriétés précédentes\n   */</span>\n   <span class=\"hljs-attribute\">grid</span>: <span class=\"hljs-number\">200px</span> <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">1</span>fr / <span class=\"hljs-number\">70px</span> <span class=\"hljs-number\">10px</span> auto <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">50px</span>;\n}\n</code></pre>\n<p>Notre <code>Grid</code> est prête, passons au positionnement de nos éléments.</p>\n<h2>grid-area</h2>\n<p>Pour notre exemple nous allons utiliser la méthode la plus originale du module à\nsavoir les <code>areas</code>. L'interêt de cette méthode est de pouvoir contrôler tant en\nterme d'espace occupé que de positionnement les différentes zones (<code>areas</code>) de\nnotre grille. On pourrait définir la forme des valeurs de <code>grid-template-areas</code>\ncomme de l'<code>ASCII art</code>.</p>\n<pre><code class=\"hljs language-CSS\"><span class=\"hljs-selector-class\">.Layout</span> {\n  <span class=\"hljs-comment\">/**\n   * 1. Header s&#x27;affichera sur 3 colonnes\n   * 2. On utilisera le symbole . pour définir un élément\n   *    virtuel et ainsi l&#x27;utiliser pour définir les gouttières\n   * 3. Aside s&#x27;affichera sur 1 colonne et 3 lignes\n   */</span>\n  <span class=\"hljs-attribute\">grid-template-areas</span>:\n   <span class=\"hljs-string\">&quot;Header Header Header&quot;</span>  <span class=\"hljs-comment\">/* 1 */</span>\n   <span class=\"hljs-string\">&quot;.        .      .   &quot;</span>  <span class=\"hljs-comment\">/* 2 */</span>\n   <span class=\"hljs-string\">&quot;Aside    .     Main &quot;</span>  <span class=\"hljs-comment\">/* 3 */</span>\n   <span class=\"hljs-string\">&quot;Aside    .      .   &quot;</span>  <span class=\"hljs-comment\">/* 3 */</span>\n   <span class=\"hljs-string\">&quot;Aside    .    Footer&quot;</span>; <span class=\"hljs-comment\">/* 3 */</span>\n}\n\n<span class=\"hljs-comment\">/**\n * 1. Il est donc nécessaire de nommer chaque élément\n *    pour le contrôler dans notre area\n */</span>\n\n<span class=\"hljs-selector-class\">.Header</span> {\n  <span class=\"hljs-attribute\">grid-area</span>: Header; <span class=\"hljs-comment\">/* 1 */</span>\n}\n\n<span class=\"hljs-selector-class\">.Main</span> {\n  <span class=\"hljs-attribute\">grid-area</span>: Main; <span class=\"hljs-comment\">/* 1 */</span>\n}\n\n<span class=\"hljs-selector-class\">.Aside</span> {\n  <span class=\"hljs-attribute\">grid-area</span>: Aside; <span class=\"hljs-comment\">/* 1 */</span>\n}\n\n<span class=\"hljs-selector-class\">.Footer</span> {\n  <span class=\"hljs-attribute\">grid-area</span>: Footer; <span class=\"hljs-comment\">/* 1 */</span>\n}\n</code></pre>\n<p>Notre intégration est terminée, on constate qu'avec très peu d'HTML et de CSS,\non arrive déjà à quelque chose d'intéressant. Il devient alors très facile de\nmanipuler et déplacer nos différents éléments en fonction du contexte de notre\napplication (mobile first, responsive, etc.).</p>\n<h2>Et c'est pas fini !</h2>\n<p><code>Grid-Layout</code> dispose d'une quantité assez impressionnante de propriétés, il\nembarque pratiquement toutes les propriétés introduites par <code>Flexbox</code>\n(<code>align-items</code>, <code>order</code>, <code>justify-content</code> etc..).</p>\n<p>De nouvelles fonctions font leur apparition comme <code>repeat</code> (permet d'appliquer\ndes motifs de répétition), mais aussi de nouvelles unités tels que <code>xfr</code>\n(fraction de l'espace restant), <code>min-content</code> (se rapporte à l'élément le plus\npetit), <code>max-content</code> (se rapporte à l'élément le plus grand). La notion de\n<code>subgrid</code> est également présente pour l'imbrication de grilles.</p>\n<p>Il est d'ailleurs tout à fait possible d'intégrer une même interface de\nplusieurs manières différentes. Si l'on reprend notre exemple, nous somme partis\nsur les propriétés utilisant les <code>areas</code>, mais on aurait très bien pu utiliser\n<code>grid-row</code> et <code>grid-column</code> qui s'appliquent non pas sur le parent mais sur les\nenfants. Cette solution peut s'avérer très pratique pour des systèmes de grilles\nclassiques.</p>\n<p><code>Grid Layout</code> est un module très puissant et très complet. En le combinant avec\n<code>Flexbox</code>, on dispose de suffisament d'outils pour travailler sur des mises en\npages complexes. Reste plus qu'aux navigateurs à rapidement\nvalider/intégrer/supporter cette nouvelle spécification.</p>\n"}