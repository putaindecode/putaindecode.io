{"slug":"le-vrai-probleme-des-web-components","filename":"2021-02-15-le-vrai-probleme-des-web-components","title":"Le vrai problème des Web Components","date":"Mon, 15 Feb 2021 00:00:00 GMT","draft":false,"meta":{"title":"Le vrai problème des Web Components","date":"2021-02-15T00:00:00.000Z","author":"bloodyowl","slug":"le-vrai-probleme-des-web-components"},"body":"<p>Les Web Components sont souvent vendus comme <strong>l'alternative</strong> des standards\nface aux <strong>frameworks</strong> qui ont envahi le dévelopemment front-end depuis\nplusieurs années. C'est un discours commercial (ou un discours d'<em>advocate</em>\ncomme on appelle ça dans le développement), mais qu'en est-il vraiment ? Les Web\nComponents sont-ils une <strong>alternative viable</strong> à React, Vue, Angular et consorts\n? Tiennent-ils la promesse d'unifier tout le monde derrière une même bannière ?\nÀ quoi servent-ils ?</p>\n<h2>Un peu d'histoire</h2>\n<p>L'histoire des Web Components débute par une énorme tentative de forçage. Google\n(<a href=\"https://pastebin.com/NUMTTrKj\">qui n'en est décidément pas à son coup d'essai pour emmerder le monde avec ses idées de technos</a>)\ndébarque, défonce la porte du W3C à grands coups de pieds, jette un brouillon de\nspécification sur le bureau, crie &quot;ET C'EST DÉJÀ DANS CHROME&quot; et s'en va comme\nil est venu. Dans le jargon on appelle ça une <strong>belette sauvage</strong>.</p>\n<p>Mais que contient cette spécification ? Elle s'articule autour de quatre\nconcepts :</p>\n<ul>\n<li>des <strong>templates</strong>: du HTML inerte et clonable</li>\n<li>des <strong>decorators</strong>: un moyen d'appliquer du HTML depuis CSS (?)</li>\n<li>des <strong>custom elements</strong>: qui permettent de créer ses propres éléments\nutilisables dans un document HTML, avec leur comportement propre</li>\n<li>le <strong>shadow DOM</strong>: un système de sous-arbre DOM</li>\n</ul>\n<p>Certains de ses aspects font rêver, comme <strong>les styles scopés</strong>, mais la\nsolution a du mal à prendre en dehors de Google. L'immense majorité de la\ncommunauté est complètement paumée devant ce concept de shadow DOM et ne\ncomprend pas bien comment sont censés s'articuler les différents concepts de la\nspécification.</p>\n<p>Passent quelques années. Le W3C finit par faire évoluer le brouillon de\nspécification en quelque chose de plus viable, mais ça met du temps. Il hérite\nde questions balayées par le document et doit les résoudre, avec le soin\nde ne rien casser. La tâche est d'autant plus ardue que Chrome fait déjà tourner\nla version brouillon.</p>\n<p>Pendant ce temps, Google a eu le temps de promouvoir sa specification à fond les\nballons, avec des frameworks construits autour et une forte communication de\nleurs <em>advocates</em>.</p>\n<p>Aujourd'hui, les Web Components retrouvent un peu de succès grâce à des\n<a href=\"https://lit-html.polymer-project.org\">bibliothèques</a> et\n<a href=\"https://stenciljs.com\">frameworks</a> qui permettent de simplifier la gestion de\nl'état et du DOM à l'intérieur du <em>custom-element</em>.</p>\n<h2>Le problème fondamental des Web Components</h2>\n<p>Je pense que les Web Components ont un problème fondamental : en tentant de\nréconcilier la généricité d'un Web partagé par tous avec le fait de se créer son\npropre &quot;standard local&quot;, <strong>ils finissent par ne répondre à aucun besoin\ncritique</strong>.</p>\n<h3>Le partage des custom elements</h3>\n<p>Partager et réutiliser, c'est la priorité <strong>numéro 1</strong> d'un système de\ncomposants. C'est pourtant quasiment impossible à atteindre quand on rajoute\nl'orchestration depuis HTML dans la balance.</p>\n<p>La manière d'enregistrer un <em>custom element</em> est de passer une <code>class</code> héritant\nde <code>HTMLElement</code> à une petite API:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.customElements.define(<span class=\"hljs-string\">&quot;my-tag-name&quot;</span>, MyTagClass);\n</code></pre>\n<p>Comme la forme que prend cette API le suggère, <code>my-tag-name</code> sera ajouté\n<strong>globalement</strong> à la page, ce qui est logique, puisque le tag doit être\nutilisable dans du code HTML.</p>\n<p>En général, pour rester pratique à l'usage, un module JavaScript dans lequel on\ndéclare un <em>custom-element</em> va l'auto-enregistrer, et on trouvera l'appel à\n<code>window.customElements.define</code> à la fin du fichier. Dès lors, pour utiliser\nnotre nouveau tag, il faudra simplement s'assurer qu'il a été déclaré dans la\npage :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// adds `my-tag-name` to our global scope if not already</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./MyTag.js&quot;</span>;\n</code></pre>\n<p>Le problème ici : entre la déclaration et l'utilisation, on trouve un <strong>lien\nfaible</strong>, et un oubli est vite arrivé. Il peut être difficile pour des outils de\ndétecter qu'un tag n'est pas déclaré ou au contraire déclaré sans être utilisé,\npuisque l'appel à <code>window.customElements.define</code> n'est pas <strong>pur</strong> au sens du\nprogramme : déclarer un nouvel élément <strong>peut avoir des effets de bord</strong>.</p>\n<p>L'API nous laisse en plus <strong>responsables du <em>namespacing</em></strong> : il faudra toujours\npréfixer vos noms de tags par une chaîne de caractères propre à votre\norganisation, et pas de chance si des éléments tiers que vous comptez utiliser\nsont tombés sur le même préfixe.</p>\n<p>Le versionning semble également absent des considérations de la spécification.\nSi différentes parties de votre application évoluent à des vitesses différentes\net que vous devez vous retrouver avec deux versions du même élément, l'une des\ndeux parties de votre application devra faire un sacrifice sur le nommage, avec\nun <code>color-picker-legacy</code> ou un <code>color-picker-v2</code>.</p>\n<h3>L'orchestration des composants</h3>\n<p>À moins d'être disposé à faire un retour de 10 ans en arrière quant à la gestion\nde l'état et du DOM, il me semble peu souhaitable de les gérer soi-même. On va\ndonc avoir tendance à utiliser des bibliothèques et frameworks <strong>dans ses\n<em>custom-elements</em></strong>. Sans ces outils, on se retrouve dans les écueils de\nmaintenabilité qui limitent ce qu'on est capable de produire sereinement.</p>\n<p>Pour apporter une valeur qui dépasse le simple styling et une gestion d'états\ntrès basique, les Web Components dépendent eux aussi de solutions tierces. <strong>À\n&quot;praticité&quot; égale, ils n'unifient pas les frameworks, ils en contiennent</strong>.</p>\n<p>L'intérêt de pouvoir orchestrer ses Web Components via différents frameworks au\nsein d'une même entreprise perd alors un peu de sa superbe, puisqu'on duplique\nde la fonctionnalité entre la logique macro (orchestration) et micro\n(comportement des éléments eux-même).</p>\n<h3>Nos besoin pratiques ne sont pas ceux de HTML</h3>\n<p>Les <em>custom-elements</em> étant des éléments HTML, ils héritent de leur manière\nd'échanger de l'information : les <strong>attributs</strong>, les <strong>propriétés</strong> et les\n<strong>évènements</strong>. Pour être utilisables depuis du code HTML, les attributs doivent\nêtre <strong>sérialisables</strong>, et le reste devra passer par des propriétés et des\névènements.</p>\n<p>Pour passer de l'information complexe, vous devrez donc impérativement passer\npar du code JS:</p>\n<pre><code class=\"hljs language-javascript\">myCustomElement.value = <span class=\"hljs-number\">1</span>;\nmyCustomElement.addEventListener(<span class=\"hljs-string\">&quot;change&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) </span>{\n  <span class=\"hljs-comment\">// do something with event.target.value</span>\n});\n</code></pre>\n<p>Et si vous faites l'effort d'accepter des attributs sérialisés, votre code n'en\nsera que plus complexe.</p>\n<p>Hors frameworks, cette mécanique va par ailleurs compliquer votre capacité à\nexiger des propriétés ou callbacks. Pour prendre un exemple simple, dans ma\ncodebase j'ai un composant <code>TouchableOpacity</code> (un bouton qui devient\nsemi-transparent lorsque la souris est appuyée dessus). Ce composant <strong>impose</strong>\nvia le compiler qu'on lui passe un callback <code>onPress</code>, faute de quoi ça signifie\nque je n'utilise pas le composant adapté, ou que j'ai oublié de lui en passer\nun. Cette mécanique me permet de créer sereinement des composants avec des\ncontraintes d'utilisation, et m'évite d'avoir à <strong>supporter des cas non\nsouhaités</strong>. Les custom-elements, si je les utilisais bas-niveau, m'imposeraient\nà leur échelle de prévoir ce genre de cas.</p>\n<p>Il est théoriquement possible d'avoir des outils capables de détecter et\nd'alerter sur ce genre de comportements. En pratique, à moins d'imposer un outil\nd'orchestration des Web Components (aka un nouveau framework), ça semble\nfortement compromis.</p>\n<h3>L'interopérabilité avec les outils génériques</h3>\n<p>Si je dois <em>crawler</em> une page et interpréter son contenu, recevoir des\n<em>custom-elements</em> rique de me rendre la tâche difficile : chaque site peut\ndonner <strong>un sens différent au même tag HTML</strong>.</p>\n<p>Prenons un exemple repris de la documentation de <a href=\"https://amp.dev\">Google AMP</a>,\nqui utilise les Web Components :</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">amp-list</span>\n  <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;auto&quot;</span>\n  <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;100&quot;</span>\n  <span class=\"hljs-attr\">layout</span>=<span class=\"hljs-string\">&quot;fixed-height&quot;</span>\n  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/static/inline-examples/data/amp-list-urls.json&quot;</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;amp-mustache&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;url-entry&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;{{url}}&quot;</span>&gt;</span>{{title}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">amp-list</span>&gt;</span>\n</code></pre>\n<p>AMP ajoutant les roles <code>aria</code> qui vont bien au <em>runtime</em>, le serveur me renvoie\nle code vu plus haut. Qu'est-ce que je suis censé en faire ?</p>\n<p>Est-ce que je dois:</p>\n<ul>\n<li>m'amuser à lister et interpréter manuellement tous les éléments custom de tous\nles sites ?</li>\n<li>forcer les gens à ajouter les rôles d'accessibilité à l'appel de leurs\n<em>custom-elements</em>, ce qui fait perdre un énorme intérêt à l'abstraction par\ncomposant</li>\n</ul>\n<p>Il est possible de bidouiller des solutions pour faire du Server-Side Rendering,\nmais c'est en réécrivant le contenu de chaque <em>custom-element</em> lorsque le\nJavaScript prend le relai, ce qui n'est pas idéal à l'étape où le navigateur\ntravaille le plus.</p>\n<h2>Un rêve irréconciliable avec la réalité</h2>\n<p>La plupart des problèmes que j'ai listé ici me paraissent cruciaux lorsqu'on\ndéveloppe une application Web avec des attentes modernes. C'est à mon avis la\nraison du succès des frameworks front-end : <strong>ils les ont réglé avec de\nl'outillage</strong>.</p>\n<p>Les <strong>Web Components</strong>, qui cherchent à résoudre une partie des problèmes\nauxquels s'adressent les frameworks, ont quant à eux la tâche beaucoup plus\ningrate : faire la même chose avec les impératifs de <strong>standardisation</strong> et de\n<strong>rétro-compatibilité</strong>, sans pour autant empêcher les <strong>évolutions futures</strong>.</p>\n<p>Ajouter la nécessité de pouvoir sérialiser en HTML ses composants dont le\ncomportement est déclaré dans du code JavaScript, en imposant un lien faible\nentre les deux (mon navigateur n'affiche aucune erreur si j'utilise un tag non\nenregistré), c'est se tirer une balle dans le pied. La <strong>separation of\nconcerns</strong> n'a de sens que si nos <strong>concerns</strong> sont indépendants, et ce n'est\ndéfinitivement pas le cas des Web Components.</p>\n<p>Ils ne <strong>parviennent pas à réconcilier</strong> les contraintes inhérentes aux\nstandards avec la fonctionnalité qu'ils doivent apporter, et <strong>c'est tout à fait\nnormal</strong> : Google a essayé de faire rentrer un rond dans un carré, empilant les\nconcepts jusqu'à perdre la substance même du besoin original : faire un standard\nde composants réutilisables sur le Web.</p>\n<p>En se foutant royalement du consensus (qui aurait eu de fortes chances de\ndéboucher sur « venez on le fait pas »), Google a foncé tête baissée pour créer\nune fonctionnalité pas finie, déjà limitée dans ses évolutions futures par son\nadoption que l'entreprise s'est efforcée de lancer à grands coups de\ncommunication et d'<em>advocacy</em>.</p>\n<p>C'est dommage.</p>\n"}