{"slug":"swift-la-fonction-une-closure-particuliere","filename":"2017-10-26-swift-la-fonction-une-closure-particuliere","title":"Swift - la fonction: une closure particulière","date":"Thu, 26 Oct 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-10-26T00:00:00.000Z","title":"Swift - la fonction: une closure particulière","author":"leolelego","oldSlug":"swift/closure","slug":"swift-la-fonction-une-closure-particuliere"},"body":"<p><strong>Swift</strong> est un langage simple pour les débutants, tout en offrant de grandes\npossibilitées aux développeurs expérimentés. Les <em>fonctions</em> Swift sont un bon\nexemple de cette façon d’avoir pensé le langage.</p>\n<h2>Les fonctions</h2>\n<h3>Déclaration simple</h3>\n<p>La déclaration et l’utilisation de <em>fonctions</em> est simple. On commence avec le\nmot clé <code>func</code> suivi du <em>nom</em>, puis des <em>paramètres</em> entre parenthèses (a.k.a.\n<code>input</code>) :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, age:UInt)</span></span>{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name), you are \\(age)&quot;</span>)\n}\n</code></pre>\n<p>L’appel se fait aussi simplement que ça : <code>sayHello(name:&quot;Bob&quot;, age: 32)</code>. Le\nmot clé <code>_</code> permet d'enlever le label du paramètre dans l'appel si besoin :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String,<span class=\"hljs-keyword\">_</span> age:UInt)</span></span>{\n <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name), you are \\(age)&quot;</span>)\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">32</span>)\n</code></pre>\n<p>Mais vous perdrez en clarté de code suivant les cas. Par exemple, avec\n<code>min(3,6)</code> on voit tout de suite ce que fait la fonction. Alors que\n<code>sayHelloTo(&quot;Bob&quot;, 32)</code>, le <code>32</code> pourrait être beaucoup de choses.</p>\n<blockquote>\n<p>Les paramètres sont obligatoirement typés, mais peuvent être optionnels (en\nautorisant la valeur nil) avec la notation ? (e.g. Int?, String?).</p>\n</blockquote>\n<p>Vous pouvez aussi définir des valeurs par défauts pour les paramètres :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, <span class=\"hljs-keyword\">_</span> age:UInt? = <span class=\"hljs-literal\">nil</span>)</span></span>{\n    <span class=\"hljs-keyword\">if</span> age == <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name)&quot;</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name), you are \\(age!)&quot;</span>) <span class=\"hljs-comment\">//! permet de pas afficher Optinal(value)</span>\n    }\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">&quot;Bob&quot;</span>) <span class=\"hljs-comment\">// -&gt; Hello Bob</span>\nsayHello(name:<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">32</span>) <span class=\"hljs-comment\">// -&gt;  Hello Bob, you are 32</span>\n</code></pre>\n<p>La plupart du temps nos fonctions servent à nous retourner des informations.\nPour cela on utilise <code>-&gt;</code> en signe de retour suivi du type de la valeur\nretournée.</p>\n<pre><code>func formatHelloSentence(name:String, age:UInt? = nil) -> String {\n    if age == nil {\n        return \"Hello \\(name)\"\n    } else {\n        return \"Hello \\(name), you are \\(age)\"\n    }\n}\n// Appel\nlet helloSentence = formatHelloSentence(name:\"Bob\", age: 32)\n</code></pre>\n<h3>Retours multiples ou Tuples</h3>\n<p>Apple n’est pas connu pour sa générosité, mais dans Swift ils en ont fait\nautrement <code>:troll:</code> : on peut retourner plusieurs valeurs avec une seule\nfonction. Pour cela on utilise un <code>Tuple</code> : un collection de variables\nordonnées.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>-&gt;(<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Float</span>,<span class=\"hljs-type\">String</span>) {\n    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> f : <span class=\"hljs-type\">Float</span> = <span class=\"hljs-number\">0.0</span>\n    <span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">&quot;&quot;</span>\n    <span class=\"hljs-comment\">//...</span>\n    <span class=\"hljs-keyword\">return</span> (a,b,f,str)\n}\n</code></pre>\n<p>Ici cette fonction prend en paramètres un tableau de <code>Float</code> et retourne un\n<em>Tuple</em> composé de deux <code>Int</code>, un <code>Float</code> et un <code>String</code> dans cet ordre. Vous\npouvez alors utiliser le <em>Tuple</em> comme une structure en utilisant l’index des\néléments du <em>Tuple</em> comme nom de variable (ex: <code>0</code>pour le premier <code>Int</code>, <code>3</code>\npour le <code>String</code>).</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.<span class=\"hljs-number\">3</span>\n</code></pre>\n<p>Mais ceci reste assez confus, alors on peut nommer les éléments.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>-&gt;(valSup:<span class=\"hljs-type\">Int</span>,\n        valMax:<span class=\"hljs-type\">Int</span>,\n        average:<span class=\"hljs-type\">Float</span>,\n        errorString:<span class=\"hljs-type\">String</span>) {\n    <span class=\"hljs-comment\">//...</span>\n}\n\n<span class=\"hljs-comment\">//utilisation</span>\n<span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.errorString <span class=\"hljs-comment\">// myTuple.3 marche encore</span>\n</code></pre>\n<p>L'exécution du code permettant d'avoir les valeurs <em>Tuple</em> n'est effectuée qu'à\nla demande de ces valeurs. Dans l'exemple ci-dessus, le code de <code>hardFunction</code>\nne sera appelé qu'à la dernière ligne, car c'est là qu'on a besoin de\n<code>errorString</code>, pas avant.</p>\n<p>Et la notion de <em>Closure</em> fait son entrée!</p>\n<h2>La closure: la variable-fonction</h2>\n<h3>Quésaco</h3>\n<p><strong>Une <em>closure</em> est une partie de code, avec paramètres et sorties, qui peut\nêtre encapsulé dans une variable, et exécutée à la demande</strong>. Si vous développez\nen C++ ou Objective-C vous connaissez peut-être déjà les <em>blocks</em> et en Java ou\nC# les <em>lambdas</em> qui sont des <em>features</em> très (très) proches.</p>\n<h3>Déclaration</h3>\n<p>Une <em>closure</em> se déclare grâce au <code>{}</code> et peut être appelée (exécutée) grâce aux\nparenthèses :</p>\n<pre><code class=\"hljs language-swift\"> <span class=\"hljs-keyword\">let</span> helloClosure = {\n     <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;hello, I’m a closure&quot;</span>)\n }\n\n helloClosure() <span class=\"hljs-comment\">// Le code est exécuté ici</span>\n</code></pre>\n<p>Ça vous rappelle rien ? L’appel d’une <em>fonction</em> ! En réalité, la <em>fonction</em> est\nune <em>closure</em> particulière associé à un contexte (Object, environnement,\nBundle...) pour réaliser des optimisations et une meilleur compréhension du\ncode.</p>\n<blockquote>\n<p>Pour une <em>closure</em> &quot;à l’air libre&quot;, on dit d’elle, qu’elle est <em>Self\nContained</em> alors qu’une fonction est contenue par un contexte (<code>class</code> par\nexemple)</p>\n</blockquote>\n<p>Comme les fonctions, les <em>closures</em> ont des paramètres d’entrée et de retour:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> complexClosure = {(name:<span class=\"hljs-type\">String</span>, age:<span class=\"hljs-type\">Float</span>) -&gt; <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n<span class=\"hljs-keyword\">let</span> success = complexClosure(<span class=\"hljs-string\">&quot;Louis&quot;</span>,<span class=\"hljs-number\">32</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Louis has \\(success)&quot;</span>)\n</code></pre>\n<p>Ainsi, les valeurs dans la première partie après la <code>{</code> sont les paramètres\nd’entrées et après la <code>-&gt;</code> ce sont les paramètres de sortie. Le code à exécuter\nest après le <code>in</code>.</p>\n<blockquote>\n<p>Comme vous avez dû le remarquer, les <em>closures</em> n’ont pas de paramètres\nnominatif. IL faut passer les paramètres d'entrée dans l'ordre de la\ndéclaration.</p>\n</blockquote>\n<h3>Closure et Type</h3>\n<p>Toute variable est typée en <em>Swift</em>, implicitement ou explicitement. Pour les\n<em>closures</em> le type est souvent implicite, aussi bien qu’on en oublie souvent\nqu’elles sont typées. Le type d’une closure va être défini par ses paramètres\nd’entrée et de sortie. Ainsi la <em>complexClosure</em> ci-dessus est du type :\n<code>((String, Float)) -&gt; (Bool)</code>.</p>\n<p>Je peux alors écrire ce code puisque les closures sont du même type :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> otherComplexClosure = { (surname:<span class=\"hljs-type\">String</span>,size:<span class=\"hljs-type\">Float</span>) -&gt; <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Other complexe Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\ncomplexClosure = otherComplexClosure\n</code></pre>\n<h3>Utilisation du contexte</h3>\n<p>Les <em>closures</em> ont une connaissance du contexte qui l’entoure. Ce qui veut dire\nque si la closure est créé dans une méthode, elle aura accès :</p>\n<ul>\n<li>au contexte de classe en passant par <code>self</code> (variables, autre fonctions...)</li>\n<li>au contexte de la fonction (paramètres, fonctions internes...)</li>\n</ul>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>{\n    <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&quot;Boby&quot;</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">crier</span><span class=\"hljs-params\">(cri:String)</span></span>{\n        <span class=\"hljs-keyword\">let</span> uselessClosure = {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;\\(self.name) cri \\(cri)&quot;</span>)\n        }\n        uselessClosure()\n    }\n}\n</code></pre>\n<h3>Trailing Closure</h3>\n<p>Pour finir, un peu d'esthétisme car on aime tous le <em>beau</em> code. La <em>Trailing\nClosure</em> est une syntaxe d'appel de fonction qui permet de rendre le code plus\nfacile à lire.</p>\n<p>Prenant la fonction suivante, prenant une <code>URL</code> est une closure de type\n<code>Void-&gt;Void</code> :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doLongTask</span><span class=\"hljs-params\">(on file:URL,\n        completion:<span class=\"hljs-params\">()</span></span></span> -&gt; ()){\n    <span class=\"hljs-comment\">//long task</span>\n    completion()\n}\n</code></pre>\n<p>On alors l'appeler cette fonction comme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL, completion:{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Task Applied on \\(aFileURL)&quot;</span>)\n})\n</code></pre>\n<p>Avec du code plus complexe, ça commence à devenir difficile à lire. Or si le\ndernier paramètre d'une fonction est une <em>closure</em>, on peut alors écrire l'appel\ncomme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL){\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Task Applied on \\(aFileURL)&quot;</span>)\n}\n</code></pre>\n<h2>Pro Tip</h2>\n<p>Imaginons une classe <code>A</code> ayant une variable <code>event</code> et un classe <code>B</code> ayant une\nfonction <code>awesomeEvent</code> ayant le même type que la variable <code>event</code> de la classe\n<code>A</code>. Je peux alors allouer, à la variable <code>event</code>, le code de <code>awesomeEvent</code>.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> </span>{\n    <span class=\"hljs-keyword\">var</span> event : ((<span class=\"hljs-type\">String</span>)-&gt;<span class=\"hljs-type\">Void</span>)?\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">awesome</span><span class=\"hljs-params\">(name:String)</span></span>{\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Awesome \\(name)&quot;</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-type\">B</span>()\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-type\">A</span>()\n\na.event = b.awesome\na.event?(<span class=\"hljs-string\">&quot;Mate&quot;</span>)\n</code></pre>\n<p><a href=\"http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696\">Exécutez ce code sur IBM Swift Sandbox c'est magique!</a></p>\n<h2>Conclusion</h2>\n<p>Voilà vous savez tout, ou presque, sur les fonctions et les closures. Les\nclosures ont vraiment la part belle en Swift, donc apprenez à les utiliser et\nles comprendre pour simplifiez votre code. Elles sont partout dans les API iOS\net macOS.</p>\n<p>Et un petit conseil: faite attention à l'état de vos <em>closures</em> dans vos\n<code>Thread</code> si vous ne voulez pas de fuite 😊</p>\n"}