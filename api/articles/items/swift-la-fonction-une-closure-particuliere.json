{"slug":"swift-la-fonction-une-closure-particuliere","filename":"2017-10-26-swift-la-fonction-une-closure-particuliere","title":"Swift - la fonction: une closure particuli√®re","date":"Thu, 26 Oct 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-10-26T00:00:00.000Z","title":"Swift - la fonction: une closure particuli√®re","author":"leolelego","oldSlug":"swift/closure","slug":"swift-la-fonction-une-closure-particuliere"},"body":"<p><strong>Swift</strong> est un langage simple pour les d√©butants, tout en offrant de grandes\npossibilit√©es aux d√©veloppeurs exp√©riment√©s. Les <em>fonctions</em> Swift sont un bon\nexemple de cette fa√ßon d‚Äôavoir pens√© le langage.</p>\n<h2>Les fonctions</h2>\n<h3>D√©claration simple</h3>\n<p>La d√©claration et l‚Äôutilisation de <em>fonctions</em> est simple. On commence avec le\nmot cl√© <code>func</code> suivi du <em>nom</em>, puis des <em>param√®tres</em> entre parenth√®ses (a.k.a.\n<code>input</code>) :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, age:UInt)</span></span>{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name), you are \\(age)&quot;</span>)\n}\n</code></pre>\n<p>L‚Äôappel se fait aussi simplement que √ßa : <code>sayHello(name:&quot;Bob&quot;, age: 32)</code>. Le\nmot cl√© <code>_</code> permet d'enlever le label du param√®tre dans l'appel si besoin :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String,<span class=\"hljs-keyword\">_</span> age:UInt)</span></span>{\n <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name), you are \\(age)&quot;</span>)\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">32</span>)\n</code></pre>\n<p>Mais vous perdrez en clart√© de code suivant les cas. Par exemple, avec\n<code>min(3,6)</code> on voit tout de suite ce que fait la fonction. Alors que\n<code>sayHelloTo(&quot;Bob&quot;, 32)</code>, le <code>32</code> pourrait √™tre beaucoup de choses.</p>\n<blockquote>\n<p>Les param√®tres sont obligatoirement typ√©s, mais peuvent √™tre optionnels (en\nautorisant la valeur nil) avec la notation ? (e.g. Int?, String?).</p>\n</blockquote>\n<p>Vous pouvez aussi d√©finir des valeurs par d√©fauts pour les param√®tres :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, <span class=\"hljs-keyword\">_</span> age:UInt? = <span class=\"hljs-literal\">nil</span>)</span></span>{\n    <span class=\"hljs-keyword\">if</span> age == <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name)&quot;</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello \\(name), you are \\(age!)&quot;</span>) <span class=\"hljs-comment\">//! permet de pas afficher Optinal(value)</span>\n    }\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">&quot;Bob&quot;</span>) <span class=\"hljs-comment\">// -&gt; Hello Bob</span>\nsayHello(name:<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">32</span>) <span class=\"hljs-comment\">// -&gt;  Hello Bob, you are 32</span>\n</code></pre>\n<p>La plupart du temps nos fonctions servent √† nous retourner des informations.\nPour cela on utilise <code>-&gt;</code> en signe de retour suivi du type de la valeur\nretourn√©e.</p>\n<pre><code>func formatHelloSentence(name:String, age:UInt? = nil) -> String {\n    if age == nil {\n        return \"Hello \\(name)\"\n    } else {\n        return \"Hello \\(name), you are \\(age)\"\n    }\n}\n// Appel\nlet helloSentence = formatHelloSentence(name:\"Bob\", age: 32)\n</code></pre>\n<h3>Retours multiples ou Tuples</h3>\n<p>Apple n‚Äôest pas connu pour sa g√©n√©rosit√©, mais dans Swift ils en ont fait\nautrement <code>:troll:</code> : on peut retourner plusieurs valeurs avec une seule\nfonction. Pour cela on utilise un <code>Tuple</code> : un collection de variables\nordonn√©es.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>-&gt;(<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Float</span>,<span class=\"hljs-type\">String</span>) {\n    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> f : <span class=\"hljs-type\">Float</span> = <span class=\"hljs-number\">0.0</span>\n    <span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">&quot;&quot;</span>\n    <span class=\"hljs-comment\">//...</span>\n    <span class=\"hljs-keyword\">return</span> (a,b,f,str)\n}\n</code></pre>\n<p>Ici cette fonction prend en param√®tres un tableau de <code>Float</code> et retourne un\n<em>Tuple</em> compos√© de deux <code>Int</code>, un <code>Float</code> et un <code>String</code> dans cet ordre. Vous\npouvez alors utiliser le <em>Tuple</em> comme une structure en utilisant l‚Äôindex des\n√©l√©ments du <em>Tuple</em> comme nom de variable (ex: <code>0</code>pour le premier <code>Int</code>, <code>3</code>\npour le <code>String</code>).</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.<span class=\"hljs-number\">3</span>\n</code></pre>\n<p>Mais ceci reste assez confus, alors on peut nommer les √©l√©ments.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>-&gt;(valSup:<span class=\"hljs-type\">Int</span>,\n        valMax:<span class=\"hljs-type\">Int</span>,\n        average:<span class=\"hljs-type\">Float</span>,\n        errorString:<span class=\"hljs-type\">String</span>) {\n    <span class=\"hljs-comment\">//...</span>\n}\n\n<span class=\"hljs-comment\">//utilisation</span>\n<span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.errorString <span class=\"hljs-comment\">// myTuple.3 marche encore</span>\n</code></pre>\n<p>L'ex√©cution du code permettant d'avoir les valeurs <em>Tuple</em> n'est effectu√©e qu'√†\nla demande de ces valeurs. Dans l'exemple ci-dessus, le code de <code>hardFunction</code>\nne sera appel√© qu'√† la derni√®re ligne, car c'est l√† qu'on a besoin de\n<code>errorString</code>, pas avant.</p>\n<p>Et la notion de <em>Closure</em> fait son entr√©e!</p>\n<h2>La closure: la variable-fonction</h2>\n<h3>Qu√©saco</h3>\n<p><strong>Une <em>closure</em> est une partie de code, avec param√®tres et sorties, qui peut\n√™tre encapsul√© dans une variable, et ex√©cut√©e √† la demande</strong>. Si vous d√©veloppez\nen C++ ou Objective-C vous connaissez peut-√™tre d√©j√† les <em>blocks</em> et en Java ou\nC# les <em>lambdas</em> qui sont des <em>features</em> tr√®s (tr√®s) proches.</p>\n<h3>D√©claration</h3>\n<p>Une <em>closure</em> se d√©clare gr√¢ce au <code>{}</code> et peut √™tre appel√©e (ex√©cut√©e) gr√¢ce aux\nparenth√®ses :</p>\n<pre><code class=\"hljs language-swift\"> <span class=\"hljs-keyword\">let</span> helloClosure = {\n     <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;hello, I‚Äôm a closure&quot;</span>)\n }\n\n helloClosure() <span class=\"hljs-comment\">// Le code est ex√©cut√© ici</span>\n</code></pre>\n<p>√áa vous rappelle rien ? L‚Äôappel d‚Äôune <em>fonction</em> ! En r√©alit√©, la <em>fonction</em> est\nune <em>closure</em> particuli√®re associ√© √† un contexte (Object, environnement,\nBundle...) pour r√©aliser des optimisations et une meilleur compr√©hension du\ncode.</p>\n<blockquote>\n<p>Pour une <em>closure</em> &quot;√† l‚Äôair libre&quot;, on dit d‚Äôelle, qu‚Äôelle est <em>Self\nContained</em> alors qu‚Äôune fonction est contenue par un contexte (<code>class</code> par\nexemple)</p>\n</blockquote>\n<p>Comme les fonctions, les <em>closures</em> ont des param√®tres d‚Äôentr√©e et de retour:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> complexClosure = {(name:<span class=\"hljs-type\">String</span>, age:<span class=\"hljs-type\">Float</span>) -&gt; <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n<span class=\"hljs-keyword\">let</span> success = complexClosure(<span class=\"hljs-string\">&quot;Louis&quot;</span>,<span class=\"hljs-number\">32</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Louis has \\(success)&quot;</span>)\n</code></pre>\n<p>Ainsi, les valeurs dans la premi√®re partie apr√®s la <code>{</code> sont les param√®tres\nd‚Äôentr√©es et apr√®s la <code>-&gt;</code> ce sont les param√®tres de sortie. Le code √† ex√©cuter\nest apr√®s le <code>in</code>.</p>\n<blockquote>\n<p>Comme vous avez d√ª le remarquer, les <em>closures</em> n‚Äôont pas de param√®tres\nnominatif. IL faut passer les param√®tres d'entr√©e dans l'ordre de la\nd√©claration.</p>\n</blockquote>\n<h3>Closure et Type</h3>\n<p>Toute variable est typ√©e en <em>Swift</em>, implicitement ou explicitement. Pour les\n<em>closures</em> le type est souvent implicite, aussi bien qu‚Äôon en oublie souvent\nqu‚Äôelles sont typ√©es. Le type d‚Äôune closure va √™tre d√©fini par ses param√®tres\nd‚Äôentr√©e et de sortie. Ainsi la <em>complexClosure</em> ci-dessus est du type :\n<code>((String, Float)) -&gt; (Bool)</code>.</p>\n<p>Je peux alors √©crire ce code puisque les closures sont du m√™me type :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> otherComplexClosure = { (surname:<span class=\"hljs-type\">String</span>,size:<span class=\"hljs-type\">Float</span>) -&gt; <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Other complexe Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\ncomplexClosure = otherComplexClosure\n</code></pre>\n<h3>Utilisation du contexte</h3>\n<p>Les <em>closures</em> ont une connaissance du contexte qui l‚Äôentoure. Ce qui veut dire\nque si la closure est cr√©√© dans une m√©thode, elle aura acc√®s :</p>\n<ul>\n<li>au contexte de classe en passant par <code>self</code> (variables, autre fonctions...)</li>\n<li>au contexte de la fonction (param√®tres, fonctions internes...)</li>\n</ul>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>{\n    <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&quot;Boby&quot;</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">crier</span><span class=\"hljs-params\">(cri:String)</span></span>{\n        <span class=\"hljs-keyword\">let</span> uselessClosure = {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;\\(self.name) cri \\(cri)&quot;</span>)\n        }\n        uselessClosure()\n    }\n}\n</code></pre>\n<h3>Trailing Closure</h3>\n<p>Pour finir, un peu d'esth√©tisme car on aime tous le <em>beau</em> code. La <em>Trailing\nClosure</em> est une syntaxe d'appel de fonction qui permet de rendre le code plus\nfacile √† lire.</p>\n<p>Prenant la fonction suivante, prenant une <code>URL</code> est une closure de type\n<code>Void-&gt;Void</code> :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doLongTask</span><span class=\"hljs-params\">(on file:URL,\n        completion:<span class=\"hljs-params\">()</span></span></span> -&gt; ()){\n    <span class=\"hljs-comment\">//long task</span>\n    completion()\n}\n</code></pre>\n<p>On alors l'appeler cette fonction comme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL, completion:{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Task Applied on \\(aFileURL)&quot;</span>)\n})\n</code></pre>\n<p>Avec du code plus complexe, √ßa commence √† devenir difficile √† lire. Or si le\ndernier param√®tre d'une fonction est une <em>closure</em>, on peut alors √©crire l'appel\ncomme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL){\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Task Applied on \\(aFileURL)&quot;</span>)\n}\n</code></pre>\n<h2>Pro Tip</h2>\n<p>Imaginons une classe <code>A</code> ayant une variable <code>event</code> et un classe <code>B</code> ayant une\nfonction <code>awesomeEvent</code> ayant le m√™me type que la variable <code>event</code> de la classe\n<code>A</code>. Je peux alors allouer, √† la variable <code>event</code>, le code de <code>awesomeEvent</code>.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> </span>{\n    <span class=\"hljs-keyword\">var</span> event : ((<span class=\"hljs-type\">String</span>)-&gt;<span class=\"hljs-type\">Void</span>)?\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">awesome</span><span class=\"hljs-params\">(name:String)</span></span>{\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Awesome \\(name)&quot;</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-type\">B</span>()\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-type\">A</span>()\n\na.event = b.awesome\na.event?(<span class=\"hljs-string\">&quot;Mate&quot;</span>)\n</code></pre>\n<p><a href=\"http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696\">Ex√©cutez ce code sur IBM Swift Sandbox c'est magique!</a></p>\n<h2>Conclusion</h2>\n<p>Voil√† vous savez tout, ou presque, sur les fonctions et les closures. Les\nclosures ont vraiment la part belle en Swift, donc apprenez √† les utiliser et\nles comprendre pour simplifiez votre code. Elles sont partout dans les API iOS\net macOS.</p>\n<p>Et un petit conseil: faite attention √† l'√©tat de vos <em>closures</em> dans vos\n<code>Thread</code> si vous ne voulez pas de fuite üòä</p>\n"}