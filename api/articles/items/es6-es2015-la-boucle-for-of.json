{"slug":"es6-es2015-la-boucle-for-of","filename":"2015-12-16-es6-es2015-la-boucle-for-of","title":"ES6, ES2015 : la boucle for..of","date":"Wed, 16 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-16T00:00:00.000Z","title":"ES6, ES2015 : la boucle for..of","author":"Freezystem","oldSlug":"js/es2015/for-of","slug":"es6-es2015-la-boucle-for-of"},"body":"<h2>Introduction</h2>\n<p>Avec l'arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de\ns'enrichir de nouvelles façons de parcourir ces derniers. Dans l'unique souci de\nmaintenir la rétro-compatibilité avec l'existant, l'ES6 se devait de garder la\nboucle <code>for..in</code> intacte.</p>\n<blockquote>\n<p>Mais alors, comment créer une variante de cette même boucle avec des capacités\naméliorées ?</p>\n</blockquote>\n<p>La solution est simple : &quot;Bienvenue au mot-clé <code>of</code> !&quot;</p>\n<p>Mais avant d'en dire plus, et pour comprendre l'utilité de ce nouveau mot-clé,\nrevoyons un peu l'existant.</p>\n<h2>Le bon vieux <code>for..in</code></h2>\n<p>Tout <em>JavaScript enthusiast</em> qui se respecte connaissait déjà la fameuse boucle\n<code>for..in</code> dont l'utilité première est d'itérer sur les différentes clés d'un\nobjet ou d'un tableau.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&quot;world&quot;</span> };\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> obj) {\n  <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">&quot;-&gt;&quot;</span> + obj[key]); <span class=\"hljs-comment\">// &#x27;foo-&gt;hello&#x27;, &#x27;bar-&gt;world&#x27;</span>\n}\n</code></pre>\n<p>La boucle <code>for..in</code>, malgré son apparente simplicité d'utilisation, cache\ncertains pièges :</p>\n<ul>\n<li><p>Lors de l'itération sur un tableau la valeur de l'index est convertie en\nchaîne de caractères : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc. Cela peut potentiellement poser\nproblème lors de l'utilisation de l'index dans des opérations de calcul.</p></li>\n<li><p>La boucle itère sur l'ensemble des clés du tableau, mais aussi sur chacune de\nses propriétés.</p>\n<pre><code>```js\nconst arr = ['foo', 'bar'];\narr.oups = 'baz';\n\nfor ( const key in arr ) {\n  console.log( key + '-&gt;' + arr[key] ); // '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'\n}\n```\n</code></pre></li>\n<li><p>L'ordre d'itération sur l'ensemble des clés d'un objet peut varier selon\nl'environnement d'éxecution du code.</p></li>\n</ul>\n<h2>La methode alternative <code>.forEach()</code></h2>\n<p>La boucle\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach\"><code>Array.prototype.forEach()</code></a>\npermet une itération plus sécurisée, mais présente certains autres inconvénients\ntels que :</p>\n<ul>\n<li>L'impossibilité d'interrompre la boucle avec les instructions traditionnelles\n<code>break;</code> et <code>return;</code></li>\n<li>Il s'agit d'une méthode réservée aux tableaux.</li>\n</ul>\n<h2><code>for..of</code> à la rescousse</h2>\n<p>Le consortium ECMA a donc décidé de procéder à la création d'une nouvelle\nversion améliorée de la boucle <code>for..in</code>. Ainsi naquit la boucle <code>for..of</code> qui\ncoexistera désormais avec la précédente, permettant de maintenir la\nrétro-compatibilité avec les versions antérieures de la norme.</p>\n<p>Le principe est le même : parcourir n'importe quel type <em>d'objet itérable</em>.</p>\n<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d'itérer sur\nl'ensemble des valeurs des clés d'un tableau.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-string\">&quot;world&quot;</span>];\narr.baz = <span class=\"hljs-string\">&quot;and mars&quot;</span>;\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> arrValue <span class=\"hljs-keyword\">of</span> arr) {\n  <span class=\"hljs-built_in\">console</span>.log(arrValue); <span class=\"hljs-comment\">// &#x27;hello&#x27;, &#x27;world&#x27;</span>\n}\n</code></pre>\n<p>La boucle <code>for..of</code> peut aussi itérer sur des types plus complexes. Examinons\ncela de plus près.</p>\n<h3>Les <em>Strings</em></h3>\n<p>Dans ce cas, chaque caractère est traité comme une entité Unicode.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">&quot;sm00th&quot;</span>;\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> chr <span class=\"hljs-keyword\">of</span> str) {\n  <span class=\"hljs-built_in\">console</span>.log(chr); <span class=\"hljs-comment\">// &#x27;s&#x27;, &#x27;m&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;t&#x27;, &#x27;h&#x27;</span>\n}\n</code></pre>\n<h3>Les <em>NodeList</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Note: cela ne fonctionnera que sur les environnements</span>\n<span class=\"hljs-comment\">// implémentant NodeList.prototype[Symbol.iterator]</span>\n\n<span class=\"hljs-comment\">// ce code ajoute une class &quot;read&quot; à toutes les balises &lt;p&gt;</span>\n<span class=\"hljs-comment\">// contenues dans la(les) balises &lt;article&gt;</span>\n\n<span class=\"hljs-keyword\">const</span> articleParagraphs = <span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">&quot;article &gt; p&quot;</span>);\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> paragraph <span class=\"hljs-keyword\">of</span> articleParagraphs) {\n  paragraph.classList.add(<span class=\"hljs-string\">&quot;read&quot;</span>);\n}\n</code></pre>\n<h3>Les <em>Maps</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>], [<span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-string\">&quot;world&quot;</span>]]);\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [name, value] <span class=\"hljs-keyword\">of</span> m) {\n  <span class=\"hljs-built_in\">console</span>.log(name + <span class=\"hljs-string\">&quot;-&gt;&quot;</span> + value); <span class=\"hljs-comment\">//&quot;foo-&gt;hello&quot;, &quot;bar-&gt;world&quot;</span>\n}\n</code></pre>\n<h3>Les <em>Sets</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">42</span>]);\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> s) {\n  <span class=\"hljs-built_in\">console</span>.log(value); <span class=\"hljs-comment\">// &#x27;foo&#x27;, true, 42</span>\n}\n</code></pre>\n<h3>Les <em>Generators</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;foo&quot;</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-literal\">false</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">42</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;bar&quot;</span>;\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> v <span class=\"hljs-keyword\">of</span> foo()) {\n  <span class=\"hljs-built_in\">console</span>.log(v); <span class=\"hljs-comment\">// &#x27;foo&#x27;, false, 42, &#x27;bar&#x27;</span>\n}\n</code></pre>\n<blockquote>\n<p>Et les objets traditionnels dans tout ça ?</p>\n</blockquote>\n<p>Étonnamment, les objets ne peuvent pas être parcourus avec cette nouvelle boucle\nsauf s'ils définissent le symbole <code>Symbol.iterator</code>. Heureusement, il existe une\nsolution de contournement par l'utilisation de\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys\"><code>Object.keys()</code></a>\nou encore\nd'<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/values\"><code>Object.values()</code></a>\net\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/entries\"><code>Object.entries()</code></a>\n(ajouts ECMAScript7).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">&quot;world&quot;</span> };\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.keys(obj)) {\n  <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">&quot;-&gt;&quot;</span> + obj[key]); <span class=\"hljs-comment\">// &#x27;foo-&gt;hello&#x27;, &#x27;bar-&gt;world&#x27;</span>\n}\n</code></pre>\n<p>Exemple définissant un itérateur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> iterableObj = {\n  *[<span class=\"hljs-built_in\">Symbol</span>.iterator]() {\n    <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-built_in\">Object</span>.entries(obj);\n  },\n};\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, val] <span class=\"hljs-keyword\">of</span> iterableObj) {\n  <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">&quot;-&gt;&quot;</span> + val); <span class=\"hljs-comment\">// &#x27;foo-&gt;hello&#x27;, &#x27;bar-&gt;world&#x27;</span>\n}\n</code></pre>\n<h2>En résumé</h2>\n<p><code>for..of</code> vient compléter les lacunes de <code>for..in</code> et permet une itération\nsimplifiée sur les <em>objets itérables</em> tels que :</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array\">Array</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String\">String</a></li>\n<li><a href=\"http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/\">Maps &amp; WeakMaps</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*\">Generators</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/API/NodeList\">NodeList</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments\">arguments</a></li>\n</ul>\n<p>De plus, <code>for..of</code> résout à présent les pièges tels que l'ordre d'itération non\nconstant ou la coercion automatique des index en chaîne de caractères.</p>\n<h2>Pour aller plus loin</h2>\n<p>La boucle <code>for..of</code> est donc une corde de plus à l'arc de l'ES6 qui permet de\nparcourir, de manière native, les tout nouveaux <em>objets itérables</em> du langage.</p>\n<p>Pour en savoir plus sur ses spécificités :</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of\">Documentation MDN</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/\">Le post de Jason Orendorff</a></li>\n<li><a href=\"http://tc39wiki.calculist.org/es6/for-of/\">Le post de Dave Herman</a></li>\n<li><a href=\"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements\">Specification ECMA-262</a></li>\n</ul>\n"}