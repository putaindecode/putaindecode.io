{"slug":"es6-es2015-iterateurs-et-generateurs","filename":"2015-12-10-es6-es2015-iterateurs-et-generateurs","title":"ES6, ES2015 : itérateurs et générateurs","date":"Thu, 10 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-10T00:00:00.000Z","title":"ES6, ES2015 : itérateurs et générateurs","author":"naholyr","oldSlug":"js/es2015/generators","slug":"es6-es2015-iterateurs-et-generateurs"},"body":"<p>Un gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent,\nappelées &quot;générateurs&quot;. ES6/2015 apporte énormément de &quot;sucres syntaxiques&quot;,\nmême s'ils sont terriblement pratiques. Les valeurs par défaut, l'affectation\npar déstructuration, les fonctions flêchées… Tout ça n'apporte pas de réelle\nnouvelle fonctionnalité. C'est un peu différent pour les générateurs qui vont\npermettre de prendre le contrôle sur l'éxécution d'une fonction depuis\nl'extérieur.</p>\n<h2>Fonction &quot;en pause&quot;</h2>\n<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par\nl'astérisque n'est jamais exécutée directement, à la place, elle retourne un\n<em>itérateur</em>. Un générateur est donc capable de s'interrompre (d'ailleurs, il\nl'est par défaut). Il est également capable de reprendre là où il s'était arrêté\n: l'itérateur retourné est un objet exposant une méthode <code>next</code> qui lorsqu'elle\nest appelée demande au générateur de reprendre là où il en était.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">idleFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;World&quot;</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = idleFunction();\n<span class=\"hljs-comment\">// L&#x27;exécution de la fonction est interrompue en attente d&#x27;être &quot;débloquée&quot;</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Hello&quot;</span>);\niterator.next(); <span class=\"hljs-comment\">// L&#x27;éxécution reprend et on affiche &quot;World&quot;</span>\n</code></pre>\n<p>Notez qu'il ne s'agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,\nson traitement sera repris plus tard, pendant ce temps l'<em>event-loop</em> continue\nsa petite vie.</p>\n<h2>Reprise du traitement et émission de valeur avec <code>yield</code></h2>\n<p>La méthode <code>next()</code> de l'itérateur retourne un objet possédant les propriétés\nsuivantes :</p>\n<ul>\n<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>\n<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>\n</ul>\n<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir une\nvaleur et de remettre en pause l'exécution de la fonction. Le principe étant\nqu'on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement\n<code>return</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">numbers</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = numbers();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.next(); <span class=\"hljs-comment\">// { value: 2, done: false }</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la\npropriété <code>value</code> de la dernière itération.</p>\n<h3><em>Use case</em> : listes infinies</h3>\n<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de\nlongueur non définie à l'avance. On peut parcourir une suite dont on ne sait pas\nà l'avance <em>combien</em> d'éléments on veut, par exemple récupérer tous les éléments\nde la suite de Fibonacci inférieurs à 100 :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fibo</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> [a, b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-comment\">// Who can stop me?</span>\n    [a, b] = [b, a + b];\n    <span class=\"hljs-keyword\">yield</span> a;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fibo();\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> iterator) {\n  <span class=\"hljs-keyword\">if</span> (n &gt;= <span class=\"hljs-number\">100</span>) {\n    <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// *I* can stop you</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(n);\n}\n<span class=\"hljs-comment\">// 1 2 3 5 8 13 21 34 55 89</span>\n</code></pre>\n<p>Note : l'opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>\n<h2>Passage de valeur au générateur</h2>\n<p>On a vu que <code>yield</code> permettait d'émettre une valeur depuis le générateur vers le\ncode contrôleur. Mais le sens inverse est également possible : la méthode <code>next</code>\nde l'itérateur accepte une valeur en paramètre, qui sera alors retournée par\nl'appel correspondant à <code>yield</code>. Exemple :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">math</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// Le premier appel à next() permet de &quot;démarrer&quot; le générateur</span>\n  <span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">yield</span>; <span class=\"hljs-comment\">// la valeur de la première itération sera undefined</span>\n  <span class=\"hljs-comment\">// x = le paramètre du second appel à next()</span>\n  <span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">yield</span> x + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// valeur de la seconde itération : x + 1</span>\n  <span class=\"hljs-comment\">// y = paramètre du troisième appel à next()</span>\n  <span class=\"hljs-keyword\">yield</span> y; <span class=\"hljs-comment\">// valeur de la troisième itération : y</span>\n  <span class=\"hljs-comment\">// le 4e appel (et +) à next() retournent { value: undefined, done: true }</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = math();\niterator.next(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// { value: undefined, done: false }</span>\n<span class=\"hljs-comment\">// Passer un paramètre au premier appel à next() n&#x27;est pas utile : cette valeur</span>\n<span class=\"hljs-comment\">// n&#x27;est pas accessible dans le générateur car aucun &quot;yield&quot; correspondant</span>\n\niterator.next(<span class=\"hljs-number\">33</span>); <span class=\"hljs-comment\">// { value: 34, done: false }, x = 33 dans le générateur</span>\niterator.next(<span class=\"hljs-number\">27</span>); <span class=\"hljs-comment\">// { value: 27, done: false }, y = 27 dans le générateur</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>\nn'importe quel type de donnée : une fonction, un objet, un autre itérateur… Les\npossibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>\n<h3><em>Use case</em> : co-routines</h3>\n<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à\n<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est\nlibre d'appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>\n<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et\nquand elles peuvent reprendre leur traitement. Et si… notre générateur émettait\ndes promesses ? Histoire d'expliquer à son code contrôleur <em>quand</em> il est sûr de\nreprendre le traitement. Et si ce code contrôleur, voyant qu'il récupère une\npromesse, attendait que cette dernière soit résolue pour transmettre au\ngénérateur en retour la valeur résolue ? Dans ce cas le générateur pourrait\ndisposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de\ntraitements asynchrones :</p>\n<pre><code class=\"hljs language-js\">execAsync(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Ajax request…&quot;</span>);\n  <span class=\"hljs-keyword\">var</span> rows = <span class=\"hljs-keyword\">yield</span> fetch(<span class=\"hljs-string\">&quot;http://my.api/get&quot;</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Work…&quot;</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Save…&quot;</span>);\n  <span class=\"hljs-keyword\">yield</span> fetch(<span class=\"hljs-string\">&quot;http://my.api/post&quot;</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK.&quot;</span>);\n}); <span class=\"hljs-comment\">// Ajax request… Work… Save… OK.</span>\n</code></pre>\n<p>Ne serait-ce pas merveilleux ? C'est le <em><em>use case</em></em> le plus intéressant pour\nnous au quotidien, et c'est assez simple en fait :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">execAsync</span>(<span class=\"hljs-params\">promiseGenerator</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> iter = promiseGenerator(); <span class=\"hljs-comment\">// en pause…</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loop</span>(<span class=\"hljs-params\">iteration</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (iteration.done) {\n      <span class=\"hljs-comment\">// Le générateur a return&#x27;é, fin du game</span>\n      <span class=\"hljs-keyword\">return</span> iteration.value;\n    }\n\n    <span class=\"hljs-comment\">// c&#x27;est un générateur de promesse, dont on attend la résolution ici</span>\n    <span class=\"hljs-keyword\">return</span> iteration.value.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// La promesse est résolue, on peut repasser sa valeur au générateur</span>\n      <span class=\"hljs-keyword\">const</span> nextIteration = iter.next(result); <span class=\"hljs-comment\">// cette valeur est return&#x27;ée par</span>\n      <span class=\"hljs-comment\">// le même &quot;yield&quot; qui a émis la promesse, ça tombe bien :)</span>\n\n      <span class=\"hljs-comment\">// Puis on relance notre boucle, et on continue récursivement</span>\n      <span class=\"hljs-keyword\">return</span> next(nextIteration);\n    });\n  }\n\n  <span class=\"hljs-keyword\">const</span> promiseIteration = iter.next(); <span class=\"hljs-comment\">// exécution reprise jusqu&#x27;au prochain &quot;yield&quot;</span>\n  <span class=\"hljs-comment\">// le générateur est remis en pause jusqu&#x27;au prochain appel à &quot;iter.next&quot;</span>\n\n  <span class=\"hljs-comment\">// Première itération de la boucle</span>\n  <span class=\"hljs-keyword\">return</span> loop(promiseIteration);\n}\n</code></pre>\n<h2>More! more! more!</h2>\n<h3>Gestion d'erreur</h3>\n<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux\ndirections. Le générateur peut <code>throw</code> vers le code contrôleur (le code est\nsynchrone) :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fail</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fail();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\n<span class=\"hljs-keyword\">try</span> {\n  iterator.next(); <span class=\"hljs-comment\">// throws</span>\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  e; <span class=\"hljs-comment\">// Error(&#x27;oops&#x27;)</span>\n}\n</code></pre>\n<p>Mais le code contrôleur peut également émettre une erreur vers le générateur\navec la méthode <code>throw</code> de l'itérateur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fail</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(e);\n  }\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fail();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.throw(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;nope&quot;</span>)); <span class=\"hljs-comment\">// affiche &quot;[Error: nope]&quot;</span>\niterator.next(); <span class=\"hljs-comment\">// { value: 2, done: false }</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>\nl'exécution du générateur, qui va alors jusqu'au premier <code>yield</code>, évalue\nl'expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en\npause. C'est au second <code>yield</code> seulement que l'exécution reprend <strong>à partir de\n<code>yield 1</code></strong>. C'est une partie que je trouve contre-intuitive et que j'ai eu du\nmal à assimiler.</p>\n<h3>Délégation</h3>\n<p>L'opérateur <code>yield*</code> permet d'émettre les valeurs d'un autre itérateur, par\nexemple :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">oneToThree</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">zeroToFour</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">yield</span>* oneToThree();\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;\n}\n</code></pre>\n<p>Cela fonction bien sûr avec tous\n<a href=\"/fr/articles/js/es2015/iterators/\">les <em>itérables</em></a> : <code>yield * [1, 2, 3]</code> est\nvalide par exemple.</p>\n<h3>Retour anticipé</h3>\n<p>Il est possible de terminer le traitement d'un générateur depuis le code\ncontrôleur avec la méthode <code>return</code> de l'itérateur. Tout se passera comme si le\ngénérateur se terminait immédiatement avec la valeur de retour fournie.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">numbers</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = numbers();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.return(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<h2>Conclusion</h2>\n<p>Un habituel petit coup d'œil sur\n<a href=\"https://kangax.github.io/compat-table/es6/#test-generators\">la compatibilité</a> :</p>\n<ul>\n<li>Les navigateurs modernes (donc pas IE)</li>\n<li>IE Edge ≥ 13</li>\n<li>Niveau polyfill, c'est vers Babel ou Traceur qu'il faudra se tourner</li>\n</ul>\n<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent\nd'inverser la responsabilité : c'est le code appelant qui prend le pouvoir sur\nla façon dont va s'exécuter la fonction appelée. Ils représentent le premier pas\nvers d'autres concepts qui bouleverseront probablement votre façon de coder dans\nquelques mois/années : fonctions asynchrones, observables… prennent leurs\nracines dans les générateurs. Les comprendre permettra de mieux appréhender de\nfutures fonctionnalités.</p>\n"}