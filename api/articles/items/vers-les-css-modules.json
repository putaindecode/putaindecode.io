{"slug":"vers-les-css-modules","filename":"2016-02-23-vers-les-css-modules","title":"Vers les CSS modules","date":"Tue, 23 Feb 2016 00:00:00 GMT","draft":false,"meta":{"date":"2016-02-23T00:00:00.000Z","title":"Vers les CSS modules","author":"thibthib","oldSlug":"css/modules","slug":"vers-les-css-modules"},"body":"<blockquote>\n<p>Je crois que même avant que je sache exactement ce qu'était le CSS, j'avais\ndéjà entendu quelqu'un me dire &quot;Je HAIS le CSS&quot;. Cette phrase était souvent\ndite par un de mes amis du back-end, et souvent pour de très bonnes raisons.\nCet article n'essaiera pas de défendre ni de vous faire aimer le CSS, mais\ncomme les outils de développement front-end évoluent rapidement, je trouve\nintéressant d'expliquer les nouvelles façons d'écrire le CSS.</p>\n</blockquote>\n<h2>Retour aux bases</h2>\n<p>D'abord, pour comprendre quel sont les problèmes que les nouveaux outils tentent\nde résoudre, un petit rappel sur ce qu'est le CSS : <em>Cascading Style Sheets</em> ou\n<em>Feuilles de style en cascade</em>.</p>\n<p>Une feuille de style ? C'est facile ! C'est un bout de code qui lie des &quot;styles&quot;\nà du HTML. En cascade ? Et bien, quelques fois un élément HTML peut correspondre\nà plusieurs styles, et &quot;en cascade&quot; est le groupe de règles qui permet de\ndéterminer lequel appliquer.</p>\n<p>Voici du code CSS basique : nous voulons que nos titres h1 soient rouges.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n</code></pre>\n<p>Ici, nous lions la <strong><em>règle (ou déclaration)</em></strong> <code>color: red</code> au <strong><em>sélecteur</em></strong>\n&quot;h1&quot;. Un sélecteur peut contenir plusieurs règles dans son bloc de déclarations.</p>\n<blockquote>\n<p>Et les dernières lueurs de bonheur s'éteignent alors que nous entrons dans\nl'enfer de la cascade</p>\n</blockquote>\n<h2>Le truc qui cascade</h2>\n<p>La cascade est pour moi un désastre qui rend le CSS très compliqué à maintenir\nsi on ne suit pas de lignes directrices ou on n'utilise pas d'outils pour\nl'écrire. Je vais vous montrer quelques exemples simples pour vous expliquer les\nprincipaux concepts de la cascade, mais gardez en tête que la plupart des\napplications web contiennent de nos jours beaucoup de code, aggravant les effets\nde la cascade.</p>\n<p>La nécessité d'avoir un système comme la cascade vient du fait que le CSS permet\nà plusieurs règles de style de s'appliquer à un même élément, ces dernières\npouvant même venir de plusieurs origines (du site, mais aussi du navigateur ou\nencore même de l'utilisateur). Il faut donc pouvoir définir dans ce cas-là\nquelle est la règle qui au final sera appliquée. Pour cela, la cascade donne à\nchacune un poids, calculé selon un certain nombre de critères, et applique la\nrègle la plus lourde. Cela peut paraitre simple au premier abord, mais les\ncritères de calcul de poids ne le sont pas du tout.</p>\n<p>Les règles qui sont les plus légères dans la cascade ne sont pas vraiment un\nproblème, mais il faut les connaitre afin de s'éviter des surprises :</p>\n<h3>Les valeurs par défaut du navigateur</h3>\n<p>Voici le haut de la cascade. Ce sont les règles qui font qu'un titre h1 est gros\nmême si on ne l'a pas spécifié.</p>\n<h3>L'héritage des parents</h3>\n<p>Ensuite, les règles sont héritées depuis les éléments HTML parents. Si on\nreprend notre élément h1, si une règle <code>color: blue</code> est définie sur l'élément\n<code>body</code>, le titre va en hériter, et sera donc bleu.</p>\n<p>Ceci étant dit, on entre maintenant dans un niveau plus douloureux de la\ncascade.</p>\n<h3>L'ordre des règles</h3>\n<p>La position d'une règle par rapport aux autres va influer sur son poids. Deux\nrègles auraient pu avoir le même poids si elles étaient à la même position mais,\nau final, c'est la dernière qui sera la plus lourde et sera donc appliquée.\n<strong><em>La dernière.</em></strong> Quand il s'agit de code assez simple, cela peut être\nfacilement compréhensible :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n</code></pre>\n<p>Facile, n'est-ce pas ? Le titre sera bleu ! Mais s'il y a une règle <code>color: red</code>\ndans un fichier CSS nommé <em>foo.css</em>, et une règle <code>color: blue</code> dans un autre\nfichier nommé <em>bar.css</em>, que le fichier <em>foo.css</em> met plus de temps que le\nfichier <em>bar.css</em> à charger, mais que le tag HTML référençant <em>foo.css</em> est\navant celui de <em>bar.css</em>, quelle règle est appliquée ? Eh bien, c'est plus\ncompliqué à savoir. <em>(indice : le temps de chargement n'est pas pris en compte)</em></p>\n<h3>La spécificité des sélecteurs</h3>\n<p>Ce critère est un niveau de complexité au-dessus des autres,\n<a href=\"https://specificity.keegan.st\">si bien que des personnes en ont fait des calculettes pour le simplifier</a>.\nJe ne vais pas rentrer dans les détails, mais il faut savoir que le poids d'un\nsélecteur est égal à la somme des poids de tous les sélecteurs le composant. Et\nque tous les sélecteurs n'ont pas le même poids.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.title</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n\n<span class=\"hljs-selector-tag\">body</span> <span class=\"hljs-selector-tag\">header</span> <span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n</code></pre>\n<p>Ici, le premier sélecteur pèse 10 parce qu'il contient un sélecteur de classe\nCSS, qui pèse lui-même 10. Le deuxième sélecteur quant à lui pèse 3, parce qu'il\ncontient trois sélecteurs de tag, pesant chacun 1. Et donc, comme 10 &gt; 3, le\ntitre h1 sera rouge !</p>\n<h3>Les styles inline</h3>\n<p>Les règles qui sont dans l'attribut “style” d'un élément HTML sont plus lourdes\nque n'importe quel sélecteur défini précédemment. Et donc voici un titre bleu :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: blue;&quot;</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></pre>\n<h3>Importance</h3>\n<p>Et enfin le dernier critère, le God Mode, le broyeur de styles, le mot-clé\n<strong><em>!important.</em></strong> Quand on veut VRAIMENT que le titre soit rouge :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red <span class=\"hljs-meta\">!important</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: blue;&quot;</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></pre>\n<p>Et comme toute la cascade est à propos de poids, si deux règles sont marquées\ncomme !important, le reste des critères est toujours pris en compte pour\ncalculer laquelle est la plus lourde, et donc appliquée.</p>\n<p><strong>…Et on ne peut pas faire plus compliqué que ça.</strong> Maintenant, imaginez des\nmilliers et des milliers de sélecteurs et règles cascadant les uns sur les\nautres pour définir le style d'un site, et vous comprendrez l'enfer que peut\nêtre le CSS. Ainsi, des développeurs CSS ont imaginé différentes méthodologies\net outils pour éviter ce cauchemar !</p>\n<h2>L'évolution des outils</h2>\n<p>Maintenant, je vais vous présenter comment ma façon d'écrire du CSS a évolué au\nfil du temps. Ne vous attendez pas à une chronologie complète de tous les outils\ninventés depuis la création du CSS en 1996 (j'avais 6 ans !) mais plutôt une\nexplication de comment je me suis débrouillé avec la cascade dans ma courte\nexpérience personnelle.</p>\n<h3>Pré-processeurs</h3>\n<p>J'ai commencé à developper des applications web en 2012, en plein âge d'or\n<a href=\"/fr/articles/css/preprocesseurs/\">des pré-processeurs</a>. Ils étaient apparus\nquelques années auparavant, comme le CSS lui-même n'était pas suffisamment\nadapté pour construire des sites complexes. Les pré-processeurs sont des\ncompilateurs qui génèrent du code CSS à partir de languages légèrement\ndifférents, comme <a href=\"http://sass-lang.com\">Sass</a> ou <a href=\"http://lesscss.org\">LESS</a>.\nCes nouveaux languages permettent de créer des variables par exemple, ou\nd'imbriquer des sélecteurs, entre autres merveilleuses nouvelles\nfonctionnalités.</p>\n<p>On peut transformer ce vieux code CSS compliqué à maintenir :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#e5e5e5</span>;\n}\n\n<span class=\"hljs-selector-tag\">body</span> <span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}\n</code></pre>\n<p>en cette bien <em>meilleure</em> version :</p>\n<pre><code class=\"hljs language-scss\"><span class=\"hljs-variable\">$textColor</span>: <span class=\"hljs-number\">#333333</span>;\n\n<span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">background</span>: lighten(<span class=\"hljs-variable\">$textColor</span>, <span class=\"hljs-number\">90%</span>);\n\n  <span class=\"hljs-selector-tag\">h1</span> {\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textColor</span>;\n  }\n}\n</code></pre>\n<p>Avec ces nouveaux outils, et pour éviter aux règles d'entrer en collision dans\nla cascade, nous avons commencé à imbriquer nos sélecteurs et à répliquer toute\nnotre structure HTML dans le code de notre pré-processeur favori. Notre CSS se\nretrouva donc avec des sélecteurs très long et lourds qui étaient associés\nuniquement avec un element HTML précis, comme ce dernier :</p>\n<blockquote>\n<p>.searchPage .sideBar .refinements.default .category .star input</p>\n</blockquote>\n<p>Et ça a plutôt bien marché au début ! Mais ces sélecteurs n'étaient pas les plus\nperformants, et la structure du HTML étant répliquée, n'importe quel changement\ndans cette dernière doit être répercuté dans les styles. Donc je suis passé à\nautre chose.</p>\n<h3>Méthodologies CSS</h3>\n<p>À ce moment, quelques nouvelles guidelines CSS ont commencé a attirer mon\nattention. On pouvait les utiliser avec les pré-processeurs, et avaient pour but\nd'éviter les collisions dans la cascade (tout comme l'imbrication des\nsélecteurs) avec un certain nombre de règles, comme sur le nommage des\nsélecteurs.</p>\n<p>Ces méthodologies sont arrivées au moment ou je commençais à découper mes\ndéveloppements en composants. L'imbrication des sélecteurs ne marchait pas très\nbien avec ces derniers, vu que le but est de créer des bouts de code\nréutilisables partout dans la web app, comme un bouton par exemple. La\nméthodologie que j'utilise (toujours aujourd'hui) est appelée\n<a href=\"/fr/articles/css/bem/\">BEM, pour Block Element Modifier</a>, mais il y en a\nd'autres avec le même but : chaque élément HTML de mes composants doit avoir une\nclasse CSS qui lui est unique. De cette façon, pas besoin d'imbrication, et pas\nde collision de la cascade !</p>\n<p>Et ce code de pré-processeur :</p>\n<pre><code class=\"hljs language-scss\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textColor</span> img {\n    border: <span class=\"hljs-number\">1px</span> solid black;\n  }\n}\n</code></pre>\n<p>se transforme en :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.Title</span> {\n  <span class=\"hljs-attribute\">color</span>: $textColor;\n}\n\n<span class=\"hljs-selector-class\">.Title-icon</span> {\n  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;\n}\n</code></pre>\n<p>Évidement, le code HTML doit être mis à jour avec les nouvelles classes, mais\nles sélecteurs sont maintenant courts et compréhensibles. Et ceci, sans aucune\nchance de collision de cascade.</p>\n<p>Maintenant, pour pouvoir mieux expliquer un dernier outil, celui qui je pense va\nrésoudre tous nos problèmes, il faut que je vous montre une autre approche pour\ncontourner les problèmes de la cascade :</p>\n<h3>Frameworks CSS</h3>\n<p>Ici, pour éviter à nos règles CSS d'entrer en collision, nous… n'en écrivons\nplus ! Les frameworks CSS sont des styles déjà écrits qu'on peut utiliser avec\ndes classes CSS spécifiques. Il y a deux approches ici :</p>\n<ul>\n<li><p>Les frameworks de styles &quot;finaux&quot; comme <a href=\"http://getbootstrap.com\">Bootstrap</a>.\nIl suffit d'ajouter la classe <code>btn</code> sur un élément HTML et… tada ! C'est\nmaintenant un magnifique bouton. Certaines variables sont modifiables pour\ntransformer le look global du framework.</p></li>\n<li><p>Les frameworks de styles &quot;utilitaires&quot; comme <a href=\"http://tachyons.io\">Tachyons</a>.\nIci, il n'y a pas de styles pré-définis, mais plein de classes utilitaires\nsont disponibles, comme <code>pam</code> pour donner un <em>medium padding</em> à un élément, ou\nencore <code>ba</code> pour lui donner une <em>border all</em> tout autour.</p></li>\n</ul>\n<p>Les frameworks utilitaires sont assez intéressants, du fait que le fichier CSS\nfinal fera autour de 10kB et jamais plus, même si le site grandit ! Mais il y\naura beaucoup de classes peu compréhensibles dans le code HTML. C'est comparable\naux styles inline, avec une optimization de poids final, comme <code>ba</code> est plus\ncourt que <em>“border-style: solid; border-width: 1px;”</em></p>\n<p>Ces frameworks nous évitent tout tracas avec la cascade ! Mais je n'aimais pas\nle fait d'utiliser un framework, ainsi qu'avoir beaucoup de classes non\ncompréhensibles dans mon code HTML. Cependant, la totale réutilisabilité et\nmodularité des styles, sans problèmes de cascade, sont impressionnants.</p>\n<p>Cela nous amène donc à cet outil génial, forgé directement avec la meilleure\nmagie JavaScript :</p>\n<h3>CSS Modules</h3>\n<p>Ce concept a d'abord pris forme suite à une simple observation : de nos jours,\nle CSS est compilé à partir d'autres languages pour permettre une écriture plus\nfacile, et pour cette même raison le HTML est aussi généré grâce à des outils de\ntemplating en JavaScript. Mais les sélecteurs CSS, le lien entre les éléments et\nles styles, ceux-la même auxquels le codeur doit faire très attention pour\néviter qu'ils n'entrent en collision, n'ont pas d'outils du tout.</p>\n<p>Et <a href=\"https://github.com/css-modules/css-modules\">CSS Modules</a> fut créé. La\npremière fonctionnalité intéressante est la génération automatique des noms de\nclasses CSS. Plus d'inquiétude sur leur unicité, on peut les nommer comme on\nveut, au final ceux générés dans le HTML seront uniques. Promis. Cela nous\npermet de réécrire ce code CSS en BEM, et HTML :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.Title</span> {\n  <span class=\"hljs-attribute\">color</span>: $textColor;\n}\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;Title&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></pre>\n<p>en ce code CSS et template JavaScript :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.styleName</span> {\n  <span class=\"hljs-attribute\">color</span>: $textColor;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./style.css&quot;</span>;\n<span class=\"hljs-string\">`&lt;h1 class=<span class=\"hljs-subst\">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span>;\n</code></pre>\n<p>Une fois compilé, ce code générera quelque chose comme ça :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.styleName__abc5436</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;styleName__abc5436&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></pre>\n<p>Une casc-quoi ? Je ne sais pas ce que c'est ! ❤️</p>\n<p>La deuxième fonctionnalité géniale, directement inspirée par les frameworks CSS\nmodulaires comme Tachyons, est la composition des styles. De la même façon qu'en\najoutant plusieurs classes utilitaires sur son élément HTML, CSS Modules nous\npermet de composer nos classes à partir de styles communs. Laissez-moi vous\nmontrer :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.titleColor</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}\n\n<span class=\"hljs-selector-class\">.bigTitle</span> {\n  <span class=\"hljs-attribute\">composes</span>: titleColor;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">24px</span>;\n}\n\n<span class=\"hljs-selector-class\">.mediumTitle</span> {\n  <span class=\"hljs-attribute\">composes</span>: titleColor;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./style.css&quot;</span>;\n<span class=\"hljs-string\">`&lt;h1 class=<span class=\"hljs-subst\">${styles.bigTitle}</span>&gt;&lt;/h1&gt;\n &lt;h2 class=<span class=\"hljs-subst\">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span>;\n</code></pre>\n<p>va générer :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.titleColor__abc5436</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}\n\n<span class=\"hljs-selector-class\">.bigTitle__def6547</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">24px</span>;\n}\n\n<span class=\"hljs-selector-class\">.mediumTitle__1638bcd</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">&lt;h1 <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">&quot;titleColor__abc5436 bigTitle__def6547&quot;</span>&gt;&lt;/h1&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;titleColor__abc5436 mediumTitle__1638bcd&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span></span>\n</code></pre>\n<p>Et ceci, messieurs-dames, est plutôt fantastique. Les styles sont modularisables\net composables, et ce sans classes incompréhensibles mais directement dans les\nfeuilles de style. Et les collisions de sélecteurs et règles ne sont plus qu'un\nmauvais souvenir.</p>\n<p>Et c'est ainsi que j'ai expérimenté avec le CSS et sa cascade jusque-là.\nJ'espère que les mois et les années à venir vont me surprendre avec de meilleurs\noutils et / ou méthodologies, et je serais heureux de les apprendre et les\nessayer 👍</p>\n"}