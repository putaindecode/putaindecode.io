{"slug":"programmation-arduino-presentation-pour-les-debutants","filename":"2018-05-07-programmation-arduino-presentation-pour-les-debutants","title":"Programmation Arduino: présentation pour les débutants","date":"Mon, 07 May 2018 00:00:00 GMT","draft":false,"meta":{"date":"2018-05-07T00:00:00.000Z","title":"Programmation Arduino: présentation pour les débutants","author":"toxnico","oldSlug":"arduino/presentation-debutants","slug":"programmation-arduino-presentation-pour-les-debutants"},"body":"<h2>1. Mais qu'est-ce que c'est Arduino, d'abord?</h2>\n<h3>1.1. Photo d'une Uno</h3>\n<p>Arduino, ce sont des cartes électroniques programmables, avec un certain nombre\nd'entrées/sorties. Quoi ? c'est pas précis ? OK, je recommence.</p>\n<p>Une carte Arduino, ça ressemble (de manière non exhaustive, parce qu'il y a\nenormément de modèles et de clones) à ceci :</p>\n<p><img src=\"/public/images/articles/2018-05-07-programmation-arduino-presentation-pour-les-debutants/Arduino_Uno.jpg\" alt=\"Arduino Uno\" /></p>\n<p>C'est une carte électronique open source, constituée essentiellement de :</p>\n<ul>\n<li>un microcontrôleur fabriqué par Atmel,</li>\n<li>un port USB,</li>\n<li>des connecteurs d'entrés/sortie (plus ou moins nombreux selon les modèles).</li>\n</ul>\n<p>L'open hardware, par analogie à l'open software, permet de partager les plans\npour pouvoir répliquer, améliorer, comprendre un dispositif matériel.</p>\n<p>Arduino, c'est aussi un IDE (disons plutôt un éditeur de code) qui permet\nd'envoyer les programmes sur la carte à travers un port USB.</p>\n<p>Il est open source et <a href=\"https://www.arduino.cc/en/main/software\">disponible ici</a>.</p>\n<h3>1.2. Spécifications du matériel</h3>\n<p>Le modèle Uno présenté ici dispose, accrochez-vous, de :</p>\n<ul>\n<li>32 ko de mémoire pour stocker les programmes,</li>\n<li>2 ko de RAM, une EEPROM 1 ko pour stocker… 2 ou 3 trucs, typiquement des\nparamètres. Impossible d'y stocker des logs GPS, par exemple ;</li>\n<li>et tout ce petit monde est cadencé à la fréquence totalement dingo de 16 MHz !</li>\n</ul>\n<p>Tout ça pour la modique somme d'une vingtaine d'euros (pour les authentiques),\net une dizaine d'euros — voire moins — pour les clones.</p>\n<h3>1.3. Mais à quoi ça sert?</h3>\n<p>&quot;C'est quoi ces specs, c'est une blague ? Qu'est-ce qu'on peut faire d'un bidule\npareil aujourd'hui ?&quot;</p>\n<p>Eh bien on peut interagir avec le monde réel, car contrairement à un PC qui\ndispose de 3 ou 4 ports USB (et je ne parle même pas des Mac), une petite carte\ncomme celle-ci peut gérer des moteurs, des systèmes d'affichage, des capteurs\n(accéléromètres, température, pression atmosphérique, luminosité, et la liste\nest loin d'être exhaustive).</p>\n<p>Au final, ça sert à fabriquer des machines. Elles peuvent être autonomes,\ndiscuter entre elles ou avec un PC, et réagir à leur environnement.</p>\n<p>La grosse vague des imprimantes 3D a eu lieu grâce à ces petits bidules. La\nmienne tourne avec une ATMEGA 2560 comme celle-ci (on remarquera qu'il y a\nbeaucoup plus de pins sur celle-ci) :</p>\n<p><img src=\"/public/images/articles/2018-05-07-programmation-arduino-presentation-pour-les-debutants/Arduino_Mega2560.jpg\" alt=\"ATMEGA2560\" /></p>\n<p>Ma fraiseuse CNC dans le garage tourne avec une simple Arduino Uno, qui reçoit\nles commandes depuis un PC et pilote 3 axes avec des moteurs pas à pas assez\nbalaises.</p>\n<p>Le projet ArduPilot propose des firmwares et shields (extensions qui se\nconnectent directement sur la carte) destinés à gérer des drones (multicoptères,\navions, rovers) dans toutes leurs fonctions (moteurs, stabilisation, GPS,\naltimètre…)</p>\n<h3>1.4. Principe de fonctionnement</h3>\n<p>Le principe, rapidement évoqué dans la toute première phrase, est d'utiliser les\npins (i.e. les connecteurs numérotés que l'on peut voir sur la photo) pour lire\nou écrire des informations.</p>\n<p>OK, OK, les informations sont de très bas niveau, vu que c'est un signal soit de\n5 V, soit de 0 V.</p>\n<p>Un bit, quoi. Tout juste de quoi faire clignoter un LED (<strong>spoiler</strong> : c'est ce\nque nous allons faire tout de suite).</p>\n<p>Nous verrons plus tard que des protocoles de communication sont à notre\ndisposition pour ne pas se taper l'écriture des bits un par un sur une pin\n(c'est très sexuel comme terminologie hein).</p>\n<p><strong>Mais vous l'aurez compris, globalement, on va être dans de la programmation de\nbas niveau.</strong></p>\n<h2>2. Structure d'un programme, langages utilisés</h2>\n<p>Allez, assez de teasing, nous allons écrire notre premier programme !</p>\n<p>Le but ? faire clignoter une LED sur la carte. Ben oui, il faut commencer petit\npour bien saisir la structure d'un programme dans cet environnement.</p>\n<p>Le programme principal consiste en deux fonctions (ce sera toujours le cas),\ndont voici les signatures ultra simples :</p>\n<ul>\n<li>void setup()</li>\n<li>void loop()</li>\n</ul>\n<p><code>setup()</code> est appelée une seule fois, au moment de la mise sous tension de la\ncarte. <code>loop()</code> est appelée, comme son nom l'indique, en boucle. Elle est lancée\naprès <code>setup()</code>, et tourne à fond à l'infini (tant que la carte est alimentée en\ntout cas).</p>\n<p>Ah j'oubliais : le langage de programmation utilisé est au choix le C, ou le\nC<ins>. J'ai un faible pour le C</ins> pour sa relative simplicité par rapport au C\npur.</p>\n<p>Donc pour reprendre sur notre programme de base, on a quelque chose comme ça :</p>\n<pre><code class=\"hljs language-C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{\n    setup();\n\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)\n        loop();\n}\n</code></pre>\n<p>En pratique, nous n'implémenterons que les deux fonctions <code>setup()</code> et <code>loop()</code>.\nLe <code>main()</code> est généré par le compilateur.</p>\n<p>Allez, assez discuté, passons à notre programme, le grand classique <strong>Blink</strong>:</p>\n<pre><code class=\"hljs language-C\"><span class=\"hljs-keyword\">int</span> led = <span class=\"hljs-number\">13</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span> </span>{\n  pinMode(led, OUTPUT);      <span class=\"hljs-comment\">// Définit la pin 13 comme pin de sortie</span>\n}\n\n<span class=\"hljs-comment\">// the loop routine runs over and over again forever:</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loop</span><span class=\"hljs-params\">()</span> </span>{\n  digitalWrite(led, HIGH);   <span class=\"hljs-comment\">// Allume la LED</span>\n  delay(<span class=\"hljs-number\">1000</span>);               <span class=\"hljs-comment\">// Attend une seconde</span>\n  digitalWrite(led, LOW);    <span class=\"hljs-comment\">// Eteint la LED</span>\n  delay(<span class=\"hljs-number\">1000</span>);               <span class=\"hljs-comment\">// Attend une seconde</span>\n}\n</code></pre>\n<p>Dans ce programme, on fait usage de 3 fonctions de la librairie standard :</p>\n<ul>\n<li><code>pinMode(pinNumber, mode)</code> : définit le mode de fonctionnement d'une pin. À la\nlouche, soit INPUT, soit OUTPUT ;</li>\n<li><code>digitalWrite(pinNumber, value)</code> : si la pin est définie en OUTPUT, cette\ninstruction permet d'écrire 1 ou 0. Si on mesure avec un voltmètre la tension\nentre la pin et la masse, on aura +5 V ou 0 V. HIGH et LOW sont des constantes\nprédéfinies, mais 1 ou 0 fonctionneraient aussi ;</li>\n<li>delay(ms) : cette instruction bloque l'exécution du programme (de <strong>tout</strong> le\nprogramme) pendant une durée donnée en millisecondes.</li>\n</ul>\n<p>La pin 13 est très pratique, car elle est reliée à une LED intégrée à la carte.\nDu coup, dès qu'on active ou désactive la 13, une petite LED orange s'allume ou\ns'éteint.</p>\n<h2>3. Instructions de base</h2>\n<p>Nous venons de voir au paragraphe précédent 2 instructions qui permettent\nd'envoyer une information en sortie (dans ce cas, faire clignoter une LED. Paye\nta gloire.)</p>\n<p>On peut aussi <strong>lire</strong> une information venant de l'extérieur, avec\n<code>digitalRead(pinNumber)</code>.</p>\n<p>Ca va permettre par exemple de savoir si un bouton poussoir est appuyé ou pas,\nsi une porte est ouverte ou fermée, etc.</p>\n<p>Par exemple, on pourrait écrire ceci :</p>\n<pre><code class=\"hljs language-C\"><span class=\"hljs-keyword\">int</span> ledPin = <span class=\"hljs-number\">13</span>;   <span class=\"hljs-comment\">// LED sur la pin 13</span>\n<span class=\"hljs-keyword\">int</span> btnPin = <span class=\"hljs-number\">7</span>;     <span class=\"hljs-comment\">// bouton poussoir sur la pin 7</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span>\n</span>{\n  pinMode(ledPin, OUTPUT);\n  pinMode(btnPin, INPUT);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loop</span><span class=\"hljs-params\">()</span>\n</span>{\n  <span class=\"hljs-keyword\">int</span> val = digitalRead(btnPin);     <span class=\"hljs-comment\">// lit l&#x27;état du bouton</span>\n  digitalWrite(ledPin, val);    <span class=\"hljs-comment\">// allume la LED en fonction de l&#x27;état du bouton</span>\n}\n</code></pre>\n<p>Je vous vois venir : &quot;Oui, mais tu te fous un peu de nous là, on n'a qu'à\nconnecter la LED directement au bouton !&quot;</p>\n<p>La réponse est oui. Mais si je voulais introduire un délai entre l'appui sur le\nbouton et l'allumage de la LED, ça commence à devenir intéressant.</p>\n<p>Ou bien si l'allumage dépend d'autres capteurs branchés sur d'autres pins, comme\npar exemple une photorésistance. On pourrait faire en sorte que la LED ne\ns'allume que si la luminosité ambiante est suffisamment faible.</p>\n<p>Mais comment savoir si la luminosité est suffisamment faible, alors que jusqu'à\nmaintenant on n'est capable de lire que HIGH ou LOW ? Grâce à\n<code>analogRead(pinNumber)</code>, bien sûr !</p>\n<p>Sur la carte en photo on peut voir une série de pins notées de A0 à A5, et leur\nparticularité, c'est qu'elles peuvent transformer un signal analogique (une\ntension entre 0 et 5 V) en un entier de 0 à 1023.</p>\n<p>Par exemple, si une photorésistance est branchée entre le +5 V et la pin A0, on\npeut obtenir la luminosité ambiante avec :</p>\n<pre><code class=\"hljs language-C\"><span class=\"hljs-comment\">// Pas besoin de faire un pinMode() dans le cas d&#x27;une lecture analogique.</span>\n<span class=\"hljs-keyword\">int</span> ambientBrightness = analogRead(A0);\n</code></pre>\n<p>Donc pour allumer la LED uniquement si le bouton est pressé <strong>ET</strong> que la\nluminosité ambiante est suffisamment basse (seuil à déterminer empiriquement,\ndisons 600):</p>\n<pre><code class=\"hljs language-C\"><span class=\"hljs-keyword\">int</span> ledPin = <span class=\"hljs-number\">13</span>;   <span class=\"hljs-comment\">// LED sur la pin 13</span>\n<span class=\"hljs-keyword\">int</span> btnPin = <span class=\"hljs-number\">7</span>;     <span class=\"hljs-comment\">// Bouton poussoir sur la pin 7</span>\n<span class=\"hljs-keyword\">int</span> photoResPin = A0; <span class=\"hljs-comment\">// A0 est une constante utilisable directement</span>\n<span class=\"hljs-keyword\">int</span> threshold = <span class=\"hljs-number\">600</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setup</span><span class=\"hljs-params\">()</span>\n</span>{\n  pinMode(ledPin, OUTPUT);\n  pinMode(btnPin, INPUT);\n  <span class=\"hljs-comment\">// On éteint la LED à l&#x27;initialisation:</span>\n  digitalWrite(ledPin, LOW);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loop</span><span class=\"hljs-params\">()</span>\n</span>{\n  <span class=\"hljs-comment\">//lecture du bouton</span>\n  <span class=\"hljs-keyword\">int</span> val = digitalRead(btnPin);     <span class=\"hljs-comment\">// Lit l&#x27;état du bouton</span>\n\n  <span class=\"hljs-comment\">//lecture de la luminosité</span>\n  <span class=\"hljs-keyword\">int</span> ambientBrightness = analogRead(A0);\n\n  <span class=\"hljs-keyword\">if</span>((val == HIGH &amp;&amp; ambientBrightness &lt; threshold) || val == LOW)\n    digitalWrite(ledPin, val);    <span class=\"hljs-comment\">// Allume la LED en fonction de l&#x27;état du bouton ET de la luminosité</span>\n}\n</code></pre>\n<p>Si j'étais joueur, je permettrais à l'utilisateur de régler le seuil avec un\npotentiomètre relié à une autre entrée analogique, histoire de ne pas le coder\nen dur… Mais comme je suis un gros fainéant et que je vois des étoiles briller\ndans vos yeux, je vais vous laisser y réfléchir. :)</p>\n<h2>4. Résumé de cette première session</h2>\n<p>Un petit doliprane ou ça va ?</p>\n<p>Pour résumer cette session, voici ce qu'il faut retenir :</p>\n<ul>\n<li>Arduino est une plateforme pour programmer des cartes électroniques\n(communément appelés microcontrôleurs),</li>\n<li>on programme en C ou en C++,</li>\n<li>nous avons des fonctions à disposition pour lire des entrées et écrire sur des\nsorties (la plupart des pins sont réversibles d'ailleurs) ;</li>\n<li>il y a peu de mémoire à disposition, donc l'optimisation des programmes sera\ncruciale pour des projets complexes.</li>\n</ul>\n<p><em>Crédits images : <a href=\"https://commons.wikimedia.org\">https://commons.wikimedia.org</a>, <a href=\"https://www.arduino.cc\">https://www.arduino.cc</a></em></p>\n"}