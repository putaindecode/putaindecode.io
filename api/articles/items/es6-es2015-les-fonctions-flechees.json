{"slug":"es6-es2015-les-fonctions-flechees","filename":"2015-12-15-es6-es2015-les-fonctions-flechees","title":"ES6, ES2015 : les fonctions fléchées","date":"Tue, 15 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-15T00:00:00.000Z","title":"ES6, ES2015 : les fonctions fléchées","author":"MoOx","oldSlug":"js/es2015/arrow-functions","slug":"es6-es2015-les-fonctions-flechees"},"body":"<p>ES2015 nous apporte encore du sucre syntaxique qui risque très probablement de\nvous faire oublier <code>Function.prototype.bind()</code>.</p>\n<p>Les fonctions fléchées offrent une syntaxe raccourcie des fonctions en utilisant\nla syntaxe <code>=&gt;</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>;\n};\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>;\n};\n</code></pre>\n<p>Les fonctions fléchées sont syntaxiquement similaires à ce qu'on trouve déjà\ndans d'autres langages comme CoffeeScript, Java (8+), C#…</p>\n<p>Elles supportent les expressions ou les blocs en tant que corps de fonction.\nDans notre exemple précédent, nous avons utilisé un corps classique. Pour de\nsimples fonctions, nous pouvons utiliser des expressions, le but étant d'avoir\nquelque chose de concis. Notre exemple précédent peut ainsi s'écrire de la sorte\n:</p>\n<pre><code>const myFn = (x) => x + 1;\n</code></pre>\n<p>Notez que lorsque l'on a qu'un argument dans notre fonction, on peut omettre les\nparenthèses. Notre exemple peut donc aussi s'écrire ainsi :</p>\n<pre><code>const myFn = x => x + 1;\n</code></pre>\n<p>Si notre expression mérite d'être sur plusieurs lignes, on peut aussi utiliser\ndes parenthèses :</p>\n<pre><code>const myFn = x => (\n  x +\n  1 // Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX\n)\n</code></pre>\n<p>Les exemples suivants sont donc tous les mêmes :</p>\n<pre><code>const myFn = (x) => {\n  return x + 1;\n};\n// ===\nconst myFn = (x) => x + 1;\n// ===\nconst myFn = x => x + 1;\n// ===\nconst myFn = x => (x + 1);\n</code></pre>\n<p>Dans la pratique, vous utiliserez souvent cette syntaxe pour des petites\nméthodes comme par exemple lors de l'utilisation des fonctions de tableau\nreduce/filter/map, etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">const</span> odds = nums.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v % <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [1, 3, 5]</span>\n<span class=\"hljs-keyword\">const</span> oddsSum = odds.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, v</span>) =&gt;</span> sum + v, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 9</span>\n</code></pre>\n<h2>Les fonctions fléchées n'ont pas de <code>this</code></h2>\n<p>Oui, vous avez bien lu : à l'inverse des fonctions normales, les fonctions\nfléchées partagent le même <code>this</code> lexical que leur scope parent. Du coup, le\n<code>this</code> que vous pourrez utiliser dans votre corps de fonction fléchée est celui\ndu code parent :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> Someone = {\n  <span class=\"hljs-attr\">name</span>: “MoOx”,\n  <span class=\"hljs-attr\">friends</span>: [], <span class=\"hljs-comment\">// Malheureusement, il n&#x27;a pas d&#x27;amis :(</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">printFriends</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">this</span>._friends.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =&gt;</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>._name + <span class=\"hljs-string\">&quot; knows &quot;</span> + f)\n      <span class=\"hljs-comment\">// `this` ne réfère pas à la fonction fléchée du forEach !</span>\n    )\n  }\n}\n</code></pre>\n<p>En lisant ce code, vous avez peut être compris qu'il peut être possible de ne\nplus avoir besoin du <code>bind()</code> aussi souvent que ça pouvait être le cas :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> “react”\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stuff</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n\n  <span class=\"hljs-comment\">// à l&#x27;ancienne</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">onClick</span>(<span class=\"hljs-params\">e</span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.setState({ <span class=\"hljs-attr\">omg</span>: <span class=\"hljs-literal\">false</span> })\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        { /* à l&#x27;ancienne */ }\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{</span> <span class=\"hljs-attr\">this.onClick.bind</span>(<span class=\"hljs-attr\">this</span>) }&gt;</span>\n          Old binded call\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n        { /* REGARDE MAMAN, JE BIND RIEN */ }\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{</span> (<span class=\"hljs-attr\">e</span>) =&gt;</span> this.onClick(e) }&gt;\n          I don’t need `bind` anymore !\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n        { /* Encore plus simplement */ }\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{</span> (<span class=\"hljs-attr\">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;\n          Hell yeah\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    )\n  }\n}\n</code></pre>\n<h2>Note sur les expressions et les objets</h2>\n<p>Si vous voulez retourner un objet, vous serez surement supris de ne pas obtenir\nle résultat attendu avec ce code :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> {\n  <span class=\"hljs-attr\">key</span>: obj.value;\n};\n<span class=\"hljs-keyword\">const</span> anObj = {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;my value&#x27;</span>\n};\n<span class=\"hljs-built_in\">console</span>.log(aFn(anObj)); <span class=\"hljs-comment\">// undefined</span>\n</code></pre>\n<p>En effet, l'exemple ci-dessus pourrait être traduit en ES5 de la manière\nsuivante :</p>\n<pre><code>var aFn = function (obj) {\n  key:         // Defines a label named `key`\n    obj.value  // Gets `obj.value`\n               // Implicit returns `undefined`\n}\n</code></pre>\n<p>Gardez en tête que dans ce contexte, une accolade ouvre un corps de fonction,\npas un objet. Vous devrez donc faire comme ceci :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">key</span>: obj.value };\n};\n</code></pre>\n<p>Mais attendez, avec une simple astuce, on s'en sort avec un couple de\nparenthèses :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> ({ <span class=\"hljs-attr\">key</span>: obj.value }); <span class=\"hljs-comment\">// It works !</span>\n</code></pre>\n<h2>Conclusion</h2>\n<p>Regardez\n<a href=\"https://kangax.github.io/compat-table/es6/#test-arrow_functions\">la table de compatibilité</a>.\nC'est plutôt bien supporté par la plupart des navigateurs, mais vous risquez\nsûrement d'avoir à utiliser <a href=\"http://babeljs.io\">Babel</a> afin d'être tranquille.</p>\n<p>Vous verrez que vous utiliserez les fonctions fléchées de plus en plus. Même si\nle mot clé <code>function</code> n'est pas mort, les fonctions fléchées ont un avenir\ncertain !</p>\n"}