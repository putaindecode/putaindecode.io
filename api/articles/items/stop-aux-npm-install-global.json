{"slug":"stop-aux-npm-install-global","filename":"2017-11-30-stop-aux-npm-install-global","title":"Stop aux `npm install -g` sauvages (ou pourquoi vous ne devriez pas installer en global de packages et outils CLI)","date":"Thu, 30 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-30T00:00:00.000Z","title":"Stop aux `npm install -g` sauvages (ou pourquoi vous ne devriez pas installer en global de packages et outils CLI)","author":"MoOx","oldSlug":"npm/install-g","slug":"stop-aux-npm-install-global"},"body":"<p>Ã€ chaque fois quâ€™un dÃ©veloppeur installe un outil globalement, une discussion\ntabs vs spaces commence. Et Dieu sait que câ€™est inutile. Les espaces câ€™est\nmieux. Fin de la discussion.</p>\n<p>Ã€ chaque fois quâ€™un dÃ©veloppeur utilise un outil de dÃ©veloppement global, un\nchaton meurt. Et Dieu sait que nous aimons les chats.</p>\n<p>Plus sÃ©rieusement, câ€™est une vraie question. Et une bonne question.</p>\n<h2>Pourquoi installer un outil de maniÃ¨re globale sur sa machine est une mauvaise idÃ©e?</h2>\n<p>On va tenter de rÃ©pondre ici de maniÃ¨re constructive.</p>\n<p>La raison est simple et câ€™est la mÃªme raison pour laquelle aujourdâ€™hui il y a\nYarn et npm 5 qui utilisent des fichiers <code>lock</code> : parce que vous voulez avoir\nl'assurance d'avoir la mÃªme version que vos collÃ¨gues.</p>\n<p>TrÃ¨s souvent, dans le fond un outil CLI nâ€™est rien de plus quâ€™une dÃ©pendance Ã \nun projet. Il est tout Ã  fait (voire hautement) probable que sur deux projets\ndiffÃ©rents dÃ©veloppÃ©s Ã  deux instants diffÃ©rents dans le temps vous ayez utilisÃ©\ndeux versions diffÃ©rentes dâ€™un outil.</p>\n<p>Le premier exemple de ma vie qui me vient en tÃªte câ€™est les prÃ©-processeurs CSS.\nÃ€ lâ€™Ã©poque oÃ¹ jâ€™utilisais Sass, il Ã©tait courant que pour une raison X ou Y (par\nexemple une nouvelle fonctionnalitÃ© disponible dans une version majeure) que je\ndois mettre Ã  jour la version pour le projet en cours. Mais que se passe-t-il\nalors pour tous mes anciens projets ? Vont-ils Ãªtre compatibles ? Vont-ils avoir\ndes problÃ¨mes ? Vais-je devoir mettre mes autres projets Ã  jour ? Cela va-t-il\nme faire chier dâ€™une maniÃ¨re hors du commun ?</p>\n<p>Vous avez ici des vraies questions d'ordre pratique. Ã‡a a dÃ» arriver Ã  tout le\nmonde dâ€™avoir ce cas de figure.</p>\n<p>Et je vais ajouter Ã  ceci un autre problÃ¨me.</p>\n<h2>Â« mais puisse ke je te di ke sa marche cez moi ! Â»</h2>\n<p>On a tous travaillÃ© Ã  plus de deux dÃ©veloppeurs sur un projet (et encore Ã§a peut\nnous arriver tout seul au changement de machine)</p>\n<p>Le fameux Â« Ã§a marche sur ma machine Â». Celui-lÃ  qui prend grÃ¢ve la tÃªte.\nCelui-lÃ  qui peut nous faire perdre des heures Ã  comprendre pourquoi Ã§a marche\npas sur le PC des collÃ¨gues.</p>\n<p>Celui-lÃ  qui Ã©nerve les personnes chez qui Ã§a marche et ceux chez qui cela ne\nmarche pas. Oui Ã§a fait clairement chier tout le monde.</p>\n<p>Du coup pour Ã©viter ce problÃ¨me, il y a une mÃ©thode simple.</p>\n<h2>Ne jamais (Ã´ grand jamais) installer un outil de dÃ©veloppeur globalement sur sa machine.</h2>\n<p>De rien. VoilÃ  câ€™Ã©tait un conseil gratuit.</p>\n<p>(Je dÃ©taillerai Ã  la fin de cet article les seules raisons valables pour\nutiliser et installer globalement un package ou un outil CLI)</p>\n<p>Bon du coup pour Ã©viter ce problÃ¨me on a une solution extrÃªmement simple :\ninstaller localement Ã  chaque projet TOUTES les dÃ©pendances.</p>\n<p>Il y a deux choses que peu de gens savent : la premiÃ¨re est que npm et yarn vont\nautomatiquement ajouter tous les bin disponibles de tous les node_modules locaux\ndans le PATH utilisÃ© via les scripts dÃ©finis dans votre package.json.</p>\n<p>Du coup dans la pratique il vous suffit de vous faire un petit alias pour chaque\noutil CLI et le tour est jouÃ©.</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">&quot;scripts&quot;</span>: {\n    <span class=\"hljs-string\">&quot;cmd&quot;</span>: <span class=\"hljs-string\">&quot;cmd&quot;</span> <span class=\"hljs-comment\">// on assume qu&#x27;on a un outil qui offre le bin `cmd`</span>\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-console\">npm run cmd\n</code></pre>\n<p>Ã€ savoir avec npm il faudra rajouter des â€” Ã  la fin dâ€™une commande pour que cela\nfonctionne correctement si vous passez des arguments.</p>\n<pre><code class=\"hljs language-console\">npm run cmd -- arg\n</code></pre>\n<p>Avec Yarn, cela nâ€™est pas nÃ©cessaire. Câ€™est bien plus bref (et pratique).</p>\n<pre><code class=\"hljs language-console\">yarn cmd arg\n</code></pre>\n<p>Il faut savoir que pour les dÃ©veloppeurs de ce type dâ€™outil câ€™est aussi un petit\ncauchemar Ã  gÃ©rer.</p>\n<p>Lorsquâ€™un outil a une package offrant une interface CLI, comment savoir si la\nversion de la bibliothÃ¨que fonctionnera avec ?</p>\n<p>De cette problÃ©matique est nÃ©e une solution rÃ©currente : les packages qui ont une\nCLI et une bibliothÃ¨que en parallÃ¨le vont trÃ¨s souvent avoir une CLI trÃ¨s light\nqui va en gÃ©nÃ©ral consister Ã  aller chercher dans le dossier de la bibliothÃ¨que\noÃ¹ vous vous trouvez le vrai code Ã  exÃ©cuter.</p>\n<p>Je dirais mÃªme que câ€™est plutÃ´t cool dans un sens.</p>\n<p>Mais on voit bien ici quâ€™on a un petit problÃ¨me car cela demande du travail\nsupplÃ©mentaire aux dÃ©veloppeurs des projets qui sont dÃ©jÃ  trop souvent Ã  flirter\navec le burnout.</p>\n<h2>Petite astuce bien stylÃ©e</h2>\n<p>Vous pouvez ajouter tous les binaires de <code>node_modules/.bin</code> localement Ã  votre\nPATH histoire de pouvoir les utiliser en CLI.</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># to avoid npm install -g / yarn global add</span>\n<span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:./node_modules/.bin\n</code></pre>\n<p>Une fois cette astuce rÃ©alisÃ©e, dÃ©posez dans votre <code>.bashrc</code> (ou<code>.zshrc</code>â€¦), vous\npourrez utiliser des bin locaux Ã  votre projet comme si ils avaient Ã©tÃ©\ninstallÃ©s globalement. Sans passer par alias. Mais Ã§a ne marchera bien entendu\nquâ€™Ã  la racine du projet. Ã‡a reste bien pratique nâ€™est-ce pas?</p>\n<p>(Et non, si vous faites Ã§a dans l'ordre dÃ©crit plus haut, il n'y a pas de soucis\nde sÃ©curitÃ© genre <em>&quot;un package remplace <code>rm</code> et fait ce qu'il veut avec mes\ndonnÃ©es&quot;</em> puisque la prioritÃ© sera donnÃ©e Ã  la premiÃ¨re partie du <code>PATH</code>.)</p>\n<h2>Alternative bien stylÃ©e</h2>\n<p>Si vous n'Ãªtes pas fan de modifier votre <code>PATH</code>,\n<a href=\"https://www.npmjs.com/package/npx\"><code>npx</code></a> est un outil qui va justement\npermettre d'appeler les <code>node_modules/.bin</code> locaux sans le modifier.</p>\n<p>Ah mais comment on l'installe? Avec <code>-g</code> pardi ! Je plaisante. Il est inclus\navec <code>npm</code>. Faites un petit <code>which npx</code> pour vÃ©rifier!</p>\n<p>Dans tous les cas, <code>npx</code> fait partie des rares outils qui mÃ©ritent d'Ãªtre\ninstallÃ©s en global, ceux qui sont pour l'environnement du dÃ©veloppeur, pas pour\nun projet.</p>\n<p>D'ailleurs parlons en de ces cas oÃ¹ <code>-g</code> est valide.</p>\n<h2>Les seuls cas valides oÃ¹ les outils globaux ont du sens</h2>\n<p>Les seuls cas valides sont pour des outils qui ne sont pas des outils liÃ©s Ã  un\nprojet. Câ€™est pas plus compliquÃ©!</p>\n<p>RÃ©pÃ©tez avec moi: <em>&quot;Installer avec -g c'est pour mon environnement de\ndÃ©veloppeur, rien qu'Ã  moi. Pas pour un projet&quot;.</em></p>\n<p>En plus de <code>npx</code>, un trÃ¨s bon exemple serait\n<a href=\"https://www.npmjs.com/package/trash\"><code>trash(-cli)</code></a>, que je vous conseille\ndâ€™utiliser en place de <code>rm -rf</code> (il va plus vite (dÃ©place dans votre corbeille),\net permet donc la rÃ©cupÃ©ration, sait-on jamais). Et encore si vous lâ€™utilisez\nsur un projet, pensez Ã  lâ€™ajouter aux dÃ©pendances (--dev)!</p>\n<p>Il en existera d'autres, mais rappelez-vous que <code>npm install -g</code> est clairement\ntrop souvent recommandÃ© alors qu'il ne devrait pas l'Ãªtre!</p>\n<p>Nâ€™hÃ©sitez pas Ã  rÃ©agir Ã  ces conseils.</p>\n<p>Bisous Ã  tous ğŸ˜˜</p>\n<hr />\n<h2>Note sur <code>npx</code> et sa magie intÃ©grÃ©e</h2>\n<p><code>npx</code> permet de tÃ©lÃ©charger automatiquement les packages. Par exemple tapez\n<code>npx mocha</code> et il vous installera le package <code>mocha</code> en global et ira mÃªme\njusqu'Ã  s'occuper des mises Ã  jour tout seul (en plus d'exÃ©cuter la commande,\npuisque c'est son but initial). Malheureusement, pour les raisons expliquÃ©es\nplus haut, je ne pense vraiment pas que Ã§a soit une bonne idÃ©e. Que se\npasse-t-il si vous avez pris l'habitude d'utiliser <code>npx</code> et qu'un beau jour il\nvous tÃ©lÃ©charge (puisqu'il ne vous demande rien - c'est magique) une version\ncontenant un bug? Vous aurez l'air malin. Et cela n'empÃªche en rien le fameux\nproblÃ¨me du &quot;Ã§a marche sur ma machine&quot; puisque vous aurez potentiellement des\ncollÃ¨gues qui ne l'utiliseront pas. Oui ceux qui ne lisent jamais les README et\nn'Ã©coutent pas les recommandations...</p>\n<p>(Je vois encore trop souvent des gens utiliser <code>npm</code> sur des projets nÃ©cessitant\n<code>yarn</code> et qui viennent se plaindre de temps en temps que\n&quot;Ã§a-marche-plus-j'ai-fait-rm-rf-node_modules-&amp;&amp;-npm-install-mais-c-est-pas-mieux&quot;)</p>\n"}