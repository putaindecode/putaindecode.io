{"slug":"es6-es2015-les-object-literals","filename":"2015-12-08-es6-es2015-les-object-literals","title":"ES6, ES2015 : Les object literals","date":"Tue, 08 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-08T00:00:00.000Z","title":"ES6, ES2015 : Les object literals","author":"lionelB","oldSlug":"js/es2015/object-literals","slug":"es6-es2015-les-object-literals"},"body":"<p>Là encore, cette évolution du langage amène un sucre syntaxique bien pratique\nlors de l'initialisation d'objets.</p>\n<h2>Nom des propriétés raccourcies</h2>\n<p>Lorsqu'on crée un objet, il arrive fréquemment que lorsqu'on définisse une\npropriété depuis une variable, la clé porte le même nom que la variable.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> firstname = <span class=\"hljs-string\">&quot;Robert&quot;</span>;\n<span class=\"hljs-keyword\">var</span> lastname = <span class=\"hljs-string\">&quot;Laiponje&quot;</span>;\n\n<span class=\"hljs-keyword\">return</span> {\n  <span class=\"hljs-attr\">firstname</span>: firstname,\n  <span class=\"hljs-attr\">lastname</span>: lastname,\n};\n</code></pre>\n<p>Avec ES2015, on va pouvoir l'écrire comme ça :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> firstname = <span class=\"hljs-string\">&quot;Robert&quot;</span>;\n<span class=\"hljs-keyword\">const</span> lastname = <span class=\"hljs-string\">&quot;Laiponje&quot;</span>;\n\n<span class=\"hljs-keyword\">return</span> {\n  firstname,\n  lastname,\n};\n<span class=\"hljs-comment\">// { firstname: &quot;Robert&quot;, lastname: &quot;Laiponje&quot; }</span>\n</code></pre>\n<p>De la même manière, on pourra déclarer des méthodes en se passant du mot clé\n<code>function</code>. Idem pour les <em>getter</em> / <em>setter</em>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = {\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">email</span>() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.email();\n  },\n  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title\">email</span>(<span class=\"hljs-params\">email</span>) {\n    <span class=\"hljs-built_in\">this</span>.email = email;\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-title\">validateEmail</span>(<span class=\"hljs-params\">email</span>)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  },\n};\n</code></pre>\n<h2>Nom de propriétés calculées</h2>\n<p>La dernière nouveauté concernant les <em>literal objects</em> va nous permettre de\ncréer des noms de propriétés depuis une expression, directement à la création de\nl'objet. Auparavant, il fallait procéder en 2 temps, création puis affectation.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">action</span>(<span class=\"hljs-params\">type, data</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> payload = {};\n  payload[type] = data;\n  <span class=\"hljs-keyword\">return</span> payload;\n}\n</code></pre>\n<p>En ES2015, cela donnerait :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">action</span>(<span class=\"hljs-params\">type, data</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    [type]: data,\n  };\n}\n</code></pre>\n<p><strong>À noter</strong> qu'avec l'introduction des propriétés calculées, on va pouvoir aussi\ndéclarer plusieurs fois une même propriété, la dernière déclaration écrasant les\nprécédentes (et plus de <code>syntaxError</code>).</p>\n"}