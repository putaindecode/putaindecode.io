{"slug":"respecter-semver-sans-avoir-a-y-penser-avec-semantic-release","filename":"2017-11-21-respecter-semver-sans-avoir-a-y-penser-avec-semantic-release","title":"Respecter SemVer (presque) sans avoir à y penser avec semantic-release","date":"Tue, 21 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-21T00:00:00.000Z","title":"Respecter SemVer (presque) sans avoir à y penser avec semantic-release","author":"drazik","oldSlug":"semver/semantic-release","slug":"respecter-semver-sans-avoir-a-y-penser-avec-semantic-release"},"body":"<h2>Petit rappel : SemVer, c'est quoi déjà ?</h2>\n<p>SemVer signifie <strong>Sem</strong>antic <strong>Ver</strong>sionning. C'est une manière de numéroter les\nversions succéssives d'un module. Je vous invite à aller lire\n<a href=\"http://putaindecode.io/fr/articles/semver/\">l'article sur SemVer</a> avant de lire\nla suite si vous n'êtes pas certain de bien comprendre ce que c'est. Je vais ici\nciter certaines parties de ce post afin de faire un rapide résumé :</p>\n<blockquote>\n<p>Une version s'applique à un produit, une application, une bibliothèque, un OS,\ntout ce qui a une progression en informatique. Cela permet de définir\nl'avancement du produit. SemVer s'écrit de cette façon : X.Y.Z où X est\n&quot;majeur&quot;, Y est &quot;mineur&quot;, Z est &quot;patch&quot;.</p>\n</blockquote>\n<blockquote>\n<p>SemVer est un contrat que vous signez avec vos utilisateurs, une forme de\nrespect qui leur permet d'adapter leur code ou non en fonction des versions\nque vous proposez.</p>\n</blockquote>\n<blockquote>\n<p>Cela veut dire que si vous avez corrigé un bug dans votre lib et que cela\nn'affecte en rien le code écrit par votre utilisateur, alors incrémentez Z\n(+0.0.1).</p>\n</blockquote>\n<blockquote>\n<p>Si vous avez fait des ajouts dans votre app qui peuvent être intéressants pour\nl'utilisateur et mérite une certaine attention afin d'améliorer le code qui\nutilise votre lib, alors incrémentez Y (+0.1.0).</p>\n</blockquote>\n<blockquote>\n<p>Si en revanche, vous avez cassé ne serait-ce qu'une partie de l'API (&quot;breaking\nchanges&quot;), que vous avez juste changé des noms de méthodes / fonctions déjà\nexistantes (et donc sûrement utilisées par quelqu'un d'autre), que finalement\ncela nécessite forcément une modification de la part de l'utilisateur sous\npeine que sa propre app ne fonctionne plus, alors incrémentez X (+1.0.0).</p>\n</blockquote>\n<p>Maintenant que nous sommes au point sur SemVer, passons à la suite.</p>\n<h2>Publier un module sur npm manuellement</h2>\n<p>Lorsqu'on veut publier un module sur npm, on utilise principalement deux\ncommandes : <code>npm version</code> et <code>npm publish</code>.</p>\n<p><code>npm version</code> nous permet de dire quelle composante de notre numéro de version\non souhaite incrémenter. Ainsi, <code>npm version major</code> augmentera la partie\n<code>MAJEUR</code>, <code>npm version minor</code> augmentera la partie <code>MINEUR</code> et\n<code>npm version patch</code>... je crois que vous l'avez maintenant. La commande crée\naussi un tag git ayant pour nom le numéro de version.</p>\n<p>Une fois la nouvelle version prête, <code>npm publish</code> permet, vous l'aurez deviné\n(j'espère), de la publier sur npm.</p>\n<p>Ce processus semble simple à première vue. Selon les modifications qui ont été\napportées au module depuis la dernière version, on décide de la composante\nSemVer à incrémenter, on lance un <code>npm version</code> puis un <code>npm publish</code> et c'est\nterminé. Pourtant, une étape du processus implique une décision prise par un\nhumain, et est donc soumise à interprétation ainsi qu'à de potentielles erreurs\nou oublis.</p>\n<p>Imaginons : je travaille sur mon super module au nom extrêmement original\n<code>foobar</code>. Celui-ci est actuellement en version <code>1.2.3</code> et plusieurs personnes\nont proposé des pull requests ajoutant des fonctionnalités et corrigeant des\nbugs. Il est temps de publier une nouvelle version de <code>foobar</code> afin que tout le\nmonde puisse bénéficier de ces améliorations. Je passe en revue ce qui a été\najouté, et je décide d'incrémenter la composante <code>MINEUR</code> de mon numéro de\nversion. Je publie cette nouvelle version, documente le tout dans une note de\nversion, je suis heureux.</p>\n<p>Manque de chance, quelques temps après la publication, les issues Github de mon\nprojet s'affolent. J'ai raté une modification non rétrocompatible, les\nutilisateurs de mon module (auxquels je promets de respecter SemVer) se sont\njoyeusement empressés de faire la mise à jour dans leur application, et\nmaintenant tout est cassé. Sueurs froides, j'étais pourtant sûr de mon coup, et\nmaintenant je dois me débrouiller pour régler ce problème dans l'urgence.\n&quot;Accessoirement&quot;, j'ai aussi perdu la confiance que m'accordaient certains\nutilisateurs.</p>\n<p>Après avoir réglé le problème, une question se pose : comment éviter cela à\nl'avenir ?</p>\n<h2>semantic-release, pour ne plus se soucier de rien, sauf de ce sur quoi on travaille</h2>\n<p>Eviter ce problème, c'est la promesse de\n<a href=\"https://github.com/semantic-release/semantic-release\">semantic-release</a>. Ce\nmodule nous permet de ne plus avoir à décider nous-même du prochain numéro de\nversion de notre module.</p>\n<p>Le principe est simple : à chaque fois que je fais un commit, je décris dans le\nmessage qui l'accompagne ce que j'ai effectué dans celui-ci, dans un format\nprécis qui pourra être analysé automatiquement afin de calculer le prochain\nnuméro de version. C'est un deal entre nous et semantic-release : si on respecte\nce format, il nous garantit de correctement incrémenter les différentes\ncomposantes du numéro de version, et de publier automatiquement chaque nouvelle\nversion de notre module.</p>\n<p>Par défaut, semantic-release se base sur la convention de message de commit du\nprojet AngularJS, qui propose le format suivant :</p>\n<pre><code><type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n</code></pre>\n<p>Ainsi, si un commit correspond à la correction d'un bug, je peux lui attribuer\nun message de la forme (exemples tirés de la documentation) :</p>\n<pre><code>fix(pencil): stop graphite breaking when too much pressure applied\n</code></pre>\n<p>Dans le cas d'un ajout de fonctionnalité :</p>\n<pre><code>feat(pencil): add 'graphiteWidth' option\n</code></pre>\n<p>Et dans le cas d'une modification qui casse la rétrocompatibilité :</p>\n<pre><code>perf(pencil): remove graphiteWidth option\n\nBREAKING CHANGE: The graphiteWidth option has been removed. The default\ngraphite width of 10mm is always used for performance reasons.\n</code></pre>\n<p>Ainsi, lorsque semantic-release va passer tous les commits en revue, il pourra\nanalyser le type de chacun d'entre eux, ainsi que rechercher les &quot;BREAKING\nCHANGE&quot;, afin d'incrémenter le numéro de version comme il se doit.</p>\n<p>Petit bonus : semantic-release se charge aussi de vous générer des notes de\nversion et de les ajouter à votre release sur Github.</p>\n<p>Finalement, en écrivant de bons messages de commits (ce qui devrait déjà être le\ncas, non ?) qui suivent un formalisme précis, vous vous épargnez d'avoir à gérer\nvous-même SemVer pour votre module.</p>\n<h2>Mettre en place semantic-release sur son projet</h2>\n<p>Voyons maintenant comment mettre en place semantic-release sur un projet de\nmodule npm.</p>\n<p>La première chose à faire, c'est d'installer la CLI :</p>\n<pre><code>npm install -g semantic-release-cli\n</code></pre>\n<p>Puis de lancer le setup dans le dossier de votre projet :</p>\n<pre><code>semantic-release-cli setup\n</code></pre>\n<p>semantic-release vous pose alors quelques questions :</p>\n<ul>\n<li><code>What is your npm registry?</code> : appuyez directement sur entrée pour\nsélectionner le registry npm par défaut</li>\n<li><code>What is your npm username?</code> : entrez votre username npm</li>\n<li><code>What is your npm password?</code> : entrez votre mot de passe npm</li>\n<li><code>What is your GitHub username?</code> : entrez votre username GitHub</li>\n<li><code>What is your GitHub password?</code> : entrez votre mot de passe GitHub</li>\n<li><code>What is your GitHub two-factor authentication code?</code> : si vous avez activé\nl'authentification à deux facteurs sur GitHub, entrez le code que vous aurez\nreçu ici</li>\n<li><code>What CI are you using?</code> : nous allons ici utiliser Travis CI, mais vous\npouvez utiliser ce que vous voulez si vous avez un système de CI particulier.\nPour la suite, il n'y a pas besoin de maîtriser Travis CI ni l'intégration\ncontinue en soit. Je vous suggère juste de lire\n<a href=\"http://putaindecode.io/fr/articles/ci/\">l'article d'introduction</a> si le\nconcept d'intégration continue ne vous parle pas du tout</li>\n<li><code>Do you want a .travis.yml file with semantic-release setup?</code> : Yes !</li>\n</ul>\n<p>Voilà, tout est configuré et prêt à être utilisé :</p>\n<ul>\n<li>Un script npm <code>semantic release</code> a été ajouté à votre <code>package.json</code></li>\n<li>Le champs <code>version</code> de votre <code>package.json</code> a été modifié en\n<code>0.0.0-development</code>. Vous n'aurez plus jamais à y toucher, c'est\nsemantic-release qui fera ce travail avant de publier chaque nouvelle version</li>\n<li>Un fichier <code>.travis.yml</code> contenant la configuration Travis CI nécessaire a été\ncréé. Vous pouvez le modifier selon vos besoins. Dans l'immédiat, la chose\nurgente est d'adapter la liste des versions de Node sur lesquelles Travis va\nlancer vos tests</li>\n<li>Votre repository doit être visible sur Travis CI, prêt à lancer un build\nlorsque vous ferez un <code>git push</code></li>\n<li>Un token npm a été ajouté au repository sur Travis CI, pour que celui-ci\npuisse s'authentifier lorsqu'il voudra publier une nouvelle version</li>\n</ul>\n<p><em>Une petite note concernant Travis CI : le but de semantic-release étant\nd'automatiser le processus de publication d'un module npm, celui-ci va tout\nbonnement refuser de se lancer en dehors d'un environnement d'intégration\ncontinue. Une configuration de base est fournie, il n'y a donc pas à se soucier\nde ça, mais sans intégration continue, pas de semantic-release. C'est pourquoi\nl'utilisation d'une plateforme d'intégration continue vous est imposée.</em></p>\n<p>Maintenant que tout est en place, il va falloir travailler un peu, faire\nquelques commits afin d'arriver au point où on voudra publier une nouvelle\nversion. Disons que je travaille sur un module <code>math</code> qui implémente\nactuellement les fonctions <code>add</code> et <code>substract</code>. Le module est actuellement en\nversion 1.0.0 sur npm, et un utilisateur m'a remonté un bug sur la fonction\n<code>add</code> lorsqu'on souhaite additionner deux nombres décimaux. Je règle le\nproblème, et arrive le moment de faire le commit. Selon la convention que nous\navons vu un peu plus tôt, celui-ci devra ressembler à :</p>\n<pre><code>fix(add): handle decimal numbers addition\n</code></pre>\n<p>Semantic-release pourra alors voir que ce commit est une correction de bug, qui\ns'applique à la fonction add, et qui règle un problème d'addition sur des\nnombres décimaux. Il pourra donc prendre la décision d'incrémenter la composante\n<code>MINEUR</code> de la version du module.</p>\n<p>Satisfait de mon travail pour aujourd'hui, je décide de m'arrêter là, et je fais\nun <code>git push</code>. Travis CI déclenchera un build dès qu'il aura détecté ce nouveau\ncommit sur mon repository GitHub. Celui-ci va donc lancer mes tests, et si\nceux-ci passent, lancera le script npm créé lors du setup de semantic-release\n(<code>npm run semantic-release</code>). Ce script va faire les choses suivantes :</p>\n<ol>\n<li>Vérifier que les conditions d'exécution sont bonnes (par défaut, il vérifie\nqu'on est bien sur Travis CI, sur la branche master et que tous les autres\njobs Travis CI sont bien terminés)</li>\n<li>Récupérer le dernier numéro de version publié</li>\n<li>Analyser les commits afin de déterminer le numéro de la nouvelle version</li>\n<li>Publier la nouvelle version (mise à jour du champ <code>version</code> du\n<code>package.json</code> puis <code>npm publish</code>)</li>\n<li>Générer les notes de version</li>\n<li>Créer un tag git ainsi que la release associée sur GitHub</li>\n</ol>\n<p>Une fois le build Travis CI terminé, je verrais donc la version <code>1.0.1</code> de\n<code>math</code> publiée sur npm, un nouveau tag et une nouvelle release (avec les notes\nqui y sont associées) disponibles sur GitHub.</p>\n<p>Si je décide maintenant d'ajouter les fonctions <code>multiply</code> et <code>divide</code> à mon\nmodule, et d'effectuer les deux commits suivants :</p>\n<pre><code>feat(multiply): add multiply function\n</code></pre>\n<pre><code>feat(divide): add divide function\n</code></pre>\n<p>Semantic-release déterminera que le prochain numéro de version est <code>1.1.0</code>, et\nfera le même travail que précédemment.</p>\n<p>Enfin, si je décide d'implémenter une fonction spécifique pour l'addition de\ndeux nombre décimaux, je ferais le commit suivant :</p>\n<pre><code>feat(add): split add function into addInts and addFloats\n\nBREAKING CHANGE: add function has been removed. You must replace it with\naddInts or addFloats\n</code></pre>\n<p>Semantic-release publiera dans ce cas la version <code>2.0.0</code>, parce qu'il détectera\n(grâce au &quot;BREAKING CHANGE&quot;) que ce commit contient des modifications non\nrétrocompatibles. Il s'occupera aussi d'ajouter aux notes de version une liste\ndes changements non rétrocompatibles.</p>\n<h2>Si vous voulez aller un peu plus loin</h2>\n<p>Nous avons jusqu'ici utilisé semantic-release avec tout ce qu'il propose par\ndéfaut. Toutefois celui-ci est basé sur un système de plugins et peut donc être\npersonnalisé quasiment de A à Z. Je ne détaillerais pas tout ici, mais chaque\nétape du processus qui se déroule au lancement du script npm <code>semantic-release</code>\nne fait qu'exécuter une liste de plugins qui peuvent tous être remplacés. Vous\npouvez ainsi implémenter votre propre logique pour chaque étape. Un exemple :\nécrire un plugin pour la phase d'analyse des commits afin d'utiliser une\nconvention différente de celle d'Angular JS.</p>\n<p><a href=\"https://github.com/semantic-release/semantic-release#plugins\">La documentation</a>\nexplique bien comment écrire un plugin. Les possibilités sont virtuellement\ninfinies, libre à vous d'adapter semantic-release à votre façon de travailler et\nvos envies.</p>\n"}