{"slug":"les-dockerfiles","filename":"2015-07-02-les-dockerfiles","title":"Les Dockerfiles","date":"Thu, 02 Jul 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-07-02T00:00:00.000Z","title":"Les Dockerfiles","author":"Uhsac","oldSlug":"docker/dockerfile","slug":"les-dockerfiles"},"body":"<p>Dans <a href=\"/fr/articles/docker/\">l'article précédent</a>, je vous ai présenté le\nfonctionnement de base de Docker. Mais cela vous limitait à l'usage des images\nque vous pouviez trouver sur le <a href=\"https://registry.hub.docker.com/\">Docker Hub</a>.\nAfin de vraiment pouvoir utiliser Docker au maximum, il serait appréciable de\npouvoir créer des images adaptées à nos projets et c'est là l'utilité des\nDockerfiles.</p>\n<h1>Les Dockerfiles</h1>\n<p>Les Dockerfiles sont des fichiers qui permettent de construire une image Docker\nadaptée à nos besoins, étape par étape. Rentrons dans le vif du sujet en créant\nune image permettant de lancer un projet JavaScript.</p>\n<p>Pour commencer, créez un nouveau fichier <code>Dockerfile</code> à la racine de votre\nprojet.</p>\n<p>La première chose à faire dans un Dockerfile est de définir de quelle image vous\nhéritez. Pour cet exemple, je vous propose d'utiliser une image de Debian comme\nbase (ce qui est une bonne pratique, car cette image est plutôt légère en\ncomparaison avec celle d'Ubuntu par exemple).</p>\n<pre><code>FROM debian:jessie\n</code></pre>\n<p><code>FROM</code> permet de définir notre image de base, vous pouvez l'utiliser seulement\nune fois dans un Dockerfile.</p>\n<p>Comme nous voulons créer une image pour une application JavaScript full-stack,\nnous devons commencer par installer Node.js. Pour ce faire, on va télécharger\nl'archive Node.js directement depuis le site officiel à l'aide de curl que nous\nallons aussi devoir installer.</p>\n<pre><code>RUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\n\nRUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" \\\n&& tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 \\\n&& rm node-v0.12.5-linux-x64.tar.gz\n</code></pre>\n<p><code>RUN</code> permet d'exécuter une commande à l'intérieur de votre image comme si vous\nétiez devant un shell unix.</p>\n<p>La première commande nous permet d'installer curl et de nettoyer ensuite le\ngestionnaire de paquets afin que notre image soit un peu plus légère.</p>\n<p>Avec la deuxième commande, nous téléchargeons le binaire de Node.js que nous\ninstallons ensuite à sa place, et on n'oublie pas de supprimer l'archive\nensuite.</p>\n<p>Vous pouvez vous demander pourquoi j'exécute plusieurs commandes sur une même\ninstruction <code>RUN</code> ? Eh bien, cela permet simplement de limiter le nombre\nd'instructions dans votre Dockerfile ce qui rendra votre image finale plus\nlégère.</p>\n<p>Maintenant, nous allons ajouter les sources de notre projet dans l'image et\ntélécharger nos dépendances.</p>\n<pre><code>ADD package.json /app/\n\nWORKDIR /app\n\nRUN npm install\n\nADD . /app/\n</code></pre>\n<p><code>ADD</code> permet d'ajouter des fichiers locaux ou distants à l'intérieur de votre\nimage, il est le plus souvent utilisé pour importer les sources de votre projet\nou des fichiers de configuration.</p>\n<p><code>WORKDIR</code> permet de changer le répertoire courant de votre image, toutes les\ncommandes qui suivront seront exécutées à partir de ce répertoire.</p>\n<p>Avec la dernière instruction, nous ajoutons les sources de notre projet à\nl'intérieur de l'image, mais vous allez vous demander pourquoi nous ne l'avons\npas fait en même temps que l'ajout des fichiers de dépendances. Eh bien, cela\nnous permet d'économiser beaucoup de temps !</p>\n<p>Quand Docker crée une nouvelle image à partir d'un Dockerfile, il exécute chaque\ninstruction dans un conteneur, et le résultat de cette instruction est\nsauvegardé sous forme de couche. Au final, une image est un assemblage de\nplusieurs couches (une par instruction). Et donc, quand vous reconstruisez une\nimage pour la seconde fois, les instructions qui n'impliquent pas de changements\nne sont pas réexécutées, car la couche est récupérée depuis l'image précédente.\nPar contre, si l'instruction implique un changement quelconque, elle est\nréexécutée ainsi que toutes les instructions suivantes.</p>\n<p>Dans notre cas, les sources auront tendance à beaucoup changer, et donc ne pas\nretélécharger les dépendances à chaque changement dans le code est un réel gain\nde temps !</p>\n<p>Maintenant, nous allons indiquer quel port et dossier nous souhaitons partager\navec l'extérieur du conteneur.</p>\n<pre><code>EXPOSE 3000\n\nVOLUME /app/log\n</code></pre>\n<p><code>EXPOSE</code> et <code>VOLUME</code> permettent respectivement d'indiquer quel port et quel\ndossier nous souhaitons partager.</p>\n<p>Et pour finir, nous pouvons indiquer quelle instruction doit s'exécuter au\nlancement de votre conteneur grâce à l'instruction <code>CMD</code>.</p>\n<pre><code>CMD node server.js\n</code></pre>\n<p>Voici un résumé de notre Dockerfile :</p>\n<pre><code># Image de base\nFROM debian:jessie\n\n# Installation de curl avec apt-get\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\n\n# Installation de Node.js à partir du site officiel\nRUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" \\\n&& tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 \\\n&& rm node-v0.12.5-linux-x64.tar.gz\n\n# Ajout du fichier de dépendances package.json\nADD package.json /app/\n\n# Changement du repertoire courant\nWORKDIR /app\n\n# Installation des dépendances\nRUN npm install\n\n# Ajout des sources\nADD . /app/\n\n# On expose le port 3000\nEXPOSE 3000\n\n# On partage un dossier de log\nVOLUME /app/log\n\n# On lance le serveur quand on démarre le conteneur\nCMD node server.js\n</code></pre>\n<p>Avant de transformer ce Dockerfile en une image, vous devez créer un fichier de\nplus, le <code>.dockerignore</code>, ce fichier permet comme un <code>.gitignore</code> de ne pas\ninclure certain fichiers dans votre image Docker, et c'est très important afin\nd'éviter d'inclure les dépendances de votre projet dans votre image\n(<code>node_modules</code> dans notre cas) qui sont propres à votre système, mais pas au\nsystème du conteneur. Voici à quoi votre <code>.dockerignore</code> doit ressembler :</p>\n<pre><code>node_modules\n.git\n</code></pre>\n<p>Pour transformer ce Dockerfile en une image Docker, vous devez utiliser cette\ncommande :</p>\n<pre><code class=\"hljs language-console\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> docker build -t fullstack-js .</span>\nSending build context to Docker daemon 4.381 MB\nSending build context to Docker daemon\nStep 0 : FROM debian:jessie\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> bf84c1d84a8f</span>\nStep 1 : RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> 93258459a279</span>\n...\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 4fffcf3749a2</span>\nRemoving intermediate container 93258459a279\nStep 2 : RUN curl -LO &quot;https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz&quot; &amp;&amp; tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 &amp;&amp; rm node-v0.12.5-linux-x64.tar.gz\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> a3a17d584bae</span>\n...\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 4eaa62ace8de</span>\nRemoving intermediate container a3a17d584bae\nStep 3 : ADD *.json /app/\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 1e8ffd7e10a8</span>\nRemoving intermediate container 5db20e8b8ed2\nStep 4 : WORKDIR /app\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> 7b84b06642b1</span>\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 9c0e2287c34d</span>\nRemoving intermediate container 7b84b06642b1\nStep 5 : RUN npm install\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> 0523df6e9aac</span>\n...\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 6d7327ebee30</span>\nRemoving intermediate container 0523df6e9aac\nStep 6 : ADD . /app\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 13bdbe70c6fa</span>\nRemoving intermediate container 3c83d82c1d53\nStep 7 : EXPOSE 3000\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> 51e252173b12</span>\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 6c62eb1197e2</span>\nRemoving intermediate container 51e252173b12\nStep 8 : VOLUME /app/log\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> 4af0bb73307b</span>\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> 15b6190de473</span>\nRemoving intermediate container 4af0bb73307b\nStep 9 : CMD node server.js\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> Running <span class=\"hljs-keyword\">in</span> 9522c6b9bf95</span>\n<span class=\"hljs-meta\"> ---&gt;</span><span class=\"bash\"> aaf20fb25dac</span>\nRemoving intermediate container 9522c6b9bf95\nSuccessfully built aaf20fb25dac\n</code></pre>\n<p>L'option <code>-t</code> permet de nommer votre image docker, ce qui vous servira lorsque\nvous voudrez lancer votre conteneur. Et le <code>.</code> est le repertoire où se trouve le\nDockerfile, dans notre cas le dossier courant.</p>\n<p>Maintenant, vous pouvez lancer votre conteneur de cette manière :</p>\n<pre><code class=\"hljs language-console\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> docker run -d -p 3000:3000 -v $(<span class=\"hljs-built_in\">pwd</span>)/<span class=\"hljs-built_in\">log</span>:/app/<span class=\"hljs-built_in\">log</span> fullstack-js</span>\n</code></pre>\n<p>Cette commande permet de lancer notre image en partageant le port et un dossier\navec votre ordinateur, si vous voulez plus de détails sur le fonctionnement du\nclient Docker, je vous invite à lire mon\n<a href=\"/fr/articles/docker/\">article précédent</a>.</p>\n<hr />\n<p>Dans cet article, vous avez pu voir comment créer votre propre Dockerfile,\nmaintenant vous pouvez créer des images Docker parfaitement adaptées à votre\nprojet, et même plus. En cherchant sur Internet, vous pourrez trouver des images\nDocker pour tout et n'importe quoi, comme des images pour lancer Chrome dans un\nconteneur par exemple. Pour en savoir plus, je vous redirige vers le blog de\n<a href=\"https://blog.jessfraz.com/post/docker-containers-on-the-desktop/\">Jessie Frazelle</a>.</p>\n<p>Dans le prochain article, je vous parlerai de docker-compose, un outil qui\npermet de lancer des applications multi-conteneurs facilement.</p>\n"}