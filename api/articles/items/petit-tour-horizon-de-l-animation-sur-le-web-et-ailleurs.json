{"slug":"petit-tour-horizon-de-l-animation-sur-le-web-et-ailleurs","filename":"2016-12-20-petit-tour-horizon-de-l-animation-sur-le-web-et-ailleurs","title":"Petit tour d'horizon de l'animation sur le web (et ailleurs)","date":"Tue, 20 Dec 2016 00:00:00 GMT","draft":false,"meta":{"date":"2016-12-20T00:00:00.000Z","title":"Petit tour d'horizon de l'animation sur le web (et ailleurs)","author":"bloodyowl","oldSlug":"css/animations","slug":"petit-tour-horizon-de-l-animation-sur-le-web-et-ailleurs"},"body":"<p>Les animations prennent une grande place dans les interfaces utilisateur. Loin\nde n'apporter qu'un côté esthétique, elles augmentent la performance perçue,\naméliorent notre expérience en nous aidant à nous repérer et en guidant notre\nattention. Sur les applications natives, ces animations sont souvent plus\nnaturelles que sur le web, et pour cause, beaucoup de leurs animations sont des\n<em>springs</em>.</p>\n<p>Qu'est-ce qu'une animation <em>spring</em> ? Pour arriver à le définir, voyons comment\non a l'habitude de créer des animations avec les technologies web.</p>\n<p>CSS possède deux propriétés permettant d'animer des valeurs: les <code>animation</code> et\nles <code>transition</code>. Au delà de la différence entre leurs capacités au sein de CSS\n(propriété VS ensemble de propriétés avec des étapes), les deux reposent sur le\nmême mécanisme. On va donc étudier le plus simple: <code>transition</code>.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.block</span> {\n  <span class=\"hljs-attribute\">transition</span>: <span class=\"hljs-number\">300ms</span> linear transform;\n}\n\n<span class=\"hljs-selector-class\">.block</span><span class=\"hljs-selector-pseudo\">:hover</span> {\n  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-number\">1.05</span>);\n}\n</code></pre>\n<p>Cette transition est définie sur un modèle simple : on fixe une durée\nd'animation (ici <code>300ms</code>) et un easing —<em>ou <em>zizine</em> si vous écoutez\n<a href=\"http://putaindecode.io/fr/articles/podcast/1/\">le podcast</a></em>— qui est une\nfonction d'interpolation (ici <code>linear</code>).</p>\n<p>L'easing est une fonction toute bête comme vous avez pu en voir au collège et\nles avez dessinées sur votre calculatrice Casio ou Texas (si comme moi vous\nétiez le seul péquin de la classe à avoir l'autre modèle, à devoir toujours se\ndémerder parce que les profs savaient pas comment la vôtre marchait).</p>\n<p>Bref, une fonction d'easing est assez simple. Par exemple, la <code>linear</code> ça\nrevient à :</p>\n<p><img src=\"/public/images/articles/2016-12-20-petit-tour-horizon-de-l-animation-sur-le-web-et-ailleurs/Linear.png\" alt=\"\" /></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> linear = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x; <span class=\"hljs-comment\">// such complicated</span>\n<span class=\"hljs-comment\">// didn&#x27;t even import `lodash.identity` from npm</span>\n</code></pre>\n<p>Le paramètre <code>x</code> varie entre <code>0</code> et <code>1</code>, c'est la progression de l'animation. Ce\nparamètre vaut <code>0</code> quand vous êtes au début de l'animation et <code>1</code> à la fin.</p>\n<p>En faisant à la main une version du système gérant l'animation, ça donne quelque\nchose dans ce style :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> transition = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ duration, easing, onUpdate, startValue, endValue }</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> startDate = <span class=\"hljs-built_in\">Date</span>.now(); <span class=\"hljs-comment\">// le moment où commence l&#x27;animation</span>\n  <span class=\"hljs-comment\">// la fonction tick sera executée périodiquement</span>\n  <span class=\"hljs-keyword\">const</span> tick = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> absoluteProgress = (<span class=\"hljs-built_in\">Date</span>.now() - startDate) / duration; <span class=\"hljs-comment\">// on calcule `x`</span>\n    <span class=\"hljs-keyword\">const</span> progress = <span class=\"hljs-built_in\">Math</span>.min(absoluteProgress, <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// on fait gaffe de pas déborder</span>\n    <span class=\"hljs-keyword\">const</span> progressWithEasing = easing(progress); <span class=\"hljs-comment\">// on applique la fonction d&#x27;easing</span>\n    <span class=\"hljs-comment\">// pour calculer la valeur, on diminue progressivement la valeur initiale et l&#x27;on accroit la valeur finale</span>\n    onUpdate(\n      (<span class=\"hljs-number\">1</span> - progressWithEasing) * startValue + progressWithEasing * endValue,\n    );\n    <span class=\"hljs-keyword\">if</span> (progress &lt; <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-comment\">// si c&#x27;est pas fini, on repart pour un tour</span>\n      requestAnimationFrame(tick);\n    }\n  };\n  tick();\n};\n\nmyElement.onclick = <span class=\"hljs-function\">() =&gt;</span>\n  transition({\n    <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">500</span>,\n    <span class=\"hljs-attr\">easing</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x,\n    <span class=\"hljs-attr\">onUpdate</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span>\n      (myElement.style.transform = <span class=\"hljs-string\">`translateY(<span class=\"hljs-subst\">${value + <span class=\"hljs-string\">&quot;px&quot;</span>}</span>)`</span>),\n    <span class=\"hljs-attr\">startValue</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">endValue</span>: <span class=\"hljs-number\">200</span>,\n  });\n</code></pre>\n<p>Pour définir cette fonction d'easing, CSS vous permet également de configurer\ndes courbes de Bézier cubiques.</p>\n<p>Une courbe de Bézier cubique se définit avec 4 points : <code>P0</code>, <code>P1</code>, <code>P2</code> et\n<code>P3</code>. Il en est ensuite dérivé une courbe à partir de ces quatre points. C'est\navec ce mécanisme que fonctionne la plume de la plupart des logiciels d'édition\nd'image.</p>\n<p><img src=\"/public/images/articles/2016-12-20-petit-tour-horizon-de-l-animation-sur-le-web-et-ailleurs/Bezier.png\" alt=\"\" /></p>\n<p>Vu que votre animation commence et finit à des valeurs définies à l'avance, deux\npoints sont fixés à l'avance : <code>P0</code> sera toujours <code>(0, 0)</code> et <code>P3</code> <code>(1, 1)</code>.</p>\n<p>Vous avez avec CSS la liberté de définir <code>P1</code> et <code>P2</code> sous la forme\n<code>cubic-bezier(P1x, P1y, P2x, P2y)</code>. Pour visualiser le fonctionnement, je vous\nconseille de faire un tour sur <a href=\"http://cubic-bezier.com\">cubic-bezier</a> de\n<a href=\"https://twitter.com/leaverou\">Lea Verou</a>.</p>\n<p>Tout ce que nous avons vu jusque-là sont des animations <em>timées</em> (vive les\nanglicismes). Leur durée est connue à l'avance et est immuable, les variations\npossibles se feront dans les limites de ces contraintes.</p>\n<p>Ces animations sont très pratiques pour certaines animations basiques et\nrempliront très bien leur mission, mais elles peuvent rapidement avoir des\nlimites :</p>\n<p>Avec CSS :</p>\n<ul>\n<li>On n'a aucun contrôle sur l'exécution de l'animation</li>\n<li>Configurer des animations complexes complique la maintenance</li>\n</ul>\n<p>Avec un easing basique en général :</p>\n<ul>\n<li><code>cubic-bezier</code> limite énormément les possibilités d'évolution de la valeur\nanimée (e.g. on souhaite que l'animation ait de l'élasticité, les\ntiming-functions ne permettent de faire qu'un seul débord qui ne parait pas\n&quot;naturel&quot;).</li>\n<li>Avoir des animations cohérentes dans toute notre UI est extrêmement\ncontraignant avec CSS</li>\n</ul>\n<p>Pour l'élasticité, vous pouvez vous débrouiller avec <code>@keyframes</code>, hardcoder\ntoutes les valeurs, les <em>timer</em> à la main, y passer des heures pour vous\nretrouver avec 60 étapes dans votre animation et au final de ne pas être\nsatisfait du résultat, claquer la porte de votre boulot et partir élever des\nbrebis dans les Pyrénées.</p>\n<p>C'est là qu'interviennent les <em>springs</em>.</p>\n<p>Une animation spring vous expose en général deux paramètres : <code>tension</code> et\n<code>friction</code> (ou <code>stiffness</code>, pour rigidité &amp; <code>damping</code>, pour amortissement, selon\nles systèmes). Ce sont des valeurs logiques dans ce contexte, puisqu'elles\nviennent des lois de la physique (big up Newton).</p>\n<p>Quelques exemples sur les\n<a href=\"http://facebook.github.io/rebound-js/examples/\">demos de Rebound.js</a> peuvent\nvous aider à visualiser ce que représentent ces paramètres au sein de\nl'animation.</p>\n<p>Afin d'obéir à des lois &quot;logiques&quot; de la physique, l'animation spring doit\nprendre en compte à chaque <code>tick</code> non seulement la valeur actuelle et celle\nd'arrivée mais aussi sa rapidité actuelle : c'est ce qui lui permet d'enchaîner\nnaturellement les animations.</p>\n<p>À chaque frame, il va exécuter la fonction suivante pour déterminer la <code>value</code>\net <code>velocity</code> à venir (note : ce côté est une simplification du code utilisé par\n<a href=\"https://github.com/chenglou/react-motion\">react-motion</a>).</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> unitOfTime = <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">60</span>; <span class=\"hljs-comment\">// the number of seconds in a frame</span>\n<span class=\"hljs-keyword\">const</span> precision = <span class=\"hljs-number\">0.01</span>;\n\n<span class=\"hljs-keyword\">const</span> step = <span class=\"hljs-function\">(<span class=\"hljs-params\">lastValue, lastVelocity, toValue, stiffness, damping</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> spring = -stiffness * (lastValue - toValue);\n  <span class=\"hljs-keyword\">const</span> damper = -damping * lastVelocity;\n\n  <span class=\"hljs-keyword\">const</span> all = spring + damper;\n  <span class=\"hljs-keyword\">const</span> nextVelocity = lastVelocity + all * unitOfTime;\n  <span class=\"hljs-keyword\">const</span> nextValue = lastValue + nextVelocity * unitOfTime;\n\n  <span class=\"hljs-keyword\">const</span> shouldRest =\n    <span class=\"hljs-built_in\">Math</span>.abs(nextVelocity) &lt; precision &amp;&amp;\n    <span class=\"hljs-built_in\">Math</span>.abs(nextValue - toValue) &lt; precision;\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">velocity</span>: shouldRest ? <span class=\"hljs-number\">0</span> : nextVelocity,\n    <span class=\"hljs-attr\">value</span>: shouldRest ? toValue : nextValue,\n  };\n};\n</code></pre>\n<p>Ensuite, une simple fonction <code>spring</code> qui reproduit à peu de choses près la\nmécanique de notre <code>createTransition</code> vu plus haut :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> spring = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  stiffness = <span class=\"hljs-number\">180</span>,\n  damping = <span class=\"hljs-number\">12</span>,\n  onRest = () =&gt; {},\n  toValue,\n}</span>) =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">onUpdate</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> frame;\n  <span class=\"hljs-keyword\">const</span> tick = <span class=\"hljs-function\"><span class=\"hljs-params\">curr</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// on calcule l&#x27;état</span>\n    <span class=\"hljs-keyword\">const</span> { velocity, value } = step(\n      curr.value,\n      curr.velocity,\n      toValue,\n      stiffness,\n      damping,\n    );\n    onUpdate({ velocity, value });\n    <span class=\"hljs-comment\">// si l&#x27;animation n&#x27;est pas terminée</span>\n    <span class=\"hljs-keyword\">if</span> (velocity !== <span class=\"hljs-number\">0</span> || value !== toValue) {\n      <span class=\"hljs-comment\">// on programme la prochaine frame</span>\n      frame = requestAnimationFrame(<span class=\"hljs-function\">() =&gt;</span> tick({ value, velocity }));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// sinon on prévient que l&#x27;animation est au repos</span>\n      onRest();\n    }\n  };\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-comment\">// afin de permettre aux animations de s&#x27;enchaîner, la fonction `start` prend l&#x27;état actuel de la valeur</span>\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {\n      frame = requestAnimationFrame(<span class=\"hljs-function\">() =&gt;</span> tick(value));\n    },\n    <span class=\"hljs-attr\">stop</span>: <span class=\"hljs-function\">() =&gt;</span> {\n      cancelAnimationFrame(frame);\n    },\n  };\n};\n</code></pre>\n<p>Il nous reste à créer une classe &quot;observable&quot; <code>Value</code> qui conserve l'état et\nl'animation active. Cela permet de stopper l'animation en cours avant de lancer\nla suivante lorsque cela arrive.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Value</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">initialValue</span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.value = {\n      <span class=\"hljs-attr\">value</span>: initialValue,\n      <span class=\"hljs-attr\">velocity</span>: <span class=\"hljs-number\">0</span>,\n    };\n    <span class=\"hljs-built_in\">this</span>.listeners = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();\n    <span class=\"hljs-built_in\">this</span>.animation = <span class=\"hljs-literal\">null</span>;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">addListener</span>(<span class=\"hljs-params\">listener</span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.listeners.add(listener);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-built_in\">this</span>.listeners.delete(listener);\n    };\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">updateValue</span>(<span class=\"hljs-params\">nextValue</span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.value = nextValue;\n    <span class=\"hljs-built_in\">this</span>.listeners.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">listener</span> =&gt;</span> listener(<span class=\"hljs-built_in\">this</span>.value.value));\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-title\">animate</span>(<span class=\"hljs-params\">animation</span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.animation) {\n      <span class=\"hljs-built_in\">this</span>.animation.stop();\n    }\n    <span class=\"hljs-built_in\">this</span>.animation = animation(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> <span class=\"hljs-built_in\">this</span>.updateValue(v));\n    <span class=\"hljs-built_in\">this</span>.animation.start(<span class=\"hljs-built_in\">this</span>.value);\n  }\n}\n</code></pre>\n<p>Et voilà, vous avez une animation :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-keyword\">new</span> Value(<span class=\"hljs-number\">1</span>);\n\nscale.addListener(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> (myElement.style.transform = <span class=\"hljs-string\">`scale(<span class=\"hljs-subst\">${value}</span>)`</span>));\n\nmyElement.onmousedown = <span class=\"hljs-function\">() =&gt;</span> {\n  scale.animate(spring({ <span class=\"hljs-attr\">toValue</span>: <span class=\"hljs-number\">2</span> }));\n};\n\nmyElement.onmouseup = <span class=\"hljs-function\">() =&gt;</span> {\n  scale.animate(spring({ <span class=\"hljs-attr\">toValue</span>: <span class=\"hljs-number\">1</span> }));\n};\n</code></pre>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/bloodyowl/36d0nc7r/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<p>Les animations spring ont de nombreux avantages. Elles vous permettent\nd'utiliser un vocabulaire cohérent avec celui du mouvement. Elles vous\npermettent aussi de gérer de manière intelligente le timing de vos animations :\nplus besoin de <em>hardcoder</em> le temps qu'elles doivent mettre ; seule la\ndescription du mouvement compte. Aussi, vous n'avez plus à vous soucier des\nchangements de valeurs et de ses conséquences sur la cohérence globale d'une\nanimation : le système les gère et s'adapte.</p>\n<p>Il existe plusieurs solutions pour les gérer :</p>\n<ul>\n<li>JS: <a href=\"http://facebook.github.io/rebound-js/examples/\">Rebound.js</a></li>\n<li>JS spécifique React: <a href=\"https://github.com/chenglou/react-motion\">react-motion</a></li>\n<li>JS spécifique React, utilisé par react-native:\n<a href=\"https://github.com/animatedjs/animated\">Animated</a></li>\n<li>Java (Android): <a href=\"http://facebook.github.io/rebound/\">Rebound</a></li>\n<li>Objective-C/Swift (iOS): <a href=\"https://github.com/facebook/pop\">Pop</a></li>\n</ul>\n<p>La team WebKit\n<a href=\"https://twitter.com/webkit/status/748573524734812161\">a également proposé</a>\nl'ajout d'une fonction <code>spring</code> à CSS mais la discussion stagne (à tester dans\nSafari Technology Preview).</p>\n<p>En espérant que ça vous donne des idées d'animations cool à faire.</p>\n<p>Bisous bisous.</p>\n"}