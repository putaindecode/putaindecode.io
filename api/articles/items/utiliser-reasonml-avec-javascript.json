{"slug":"utiliser-reasonml-avec-javascript","filename":"2017-10-10-utiliser-reasonml-avec-javascript","title":"Utiliser ReasonML avec JavaScript","date":"Tue, 10 Oct 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-10-10T00:00:00.000Z","title":"Utiliser ReasonML avec JavaScript","author":"bloodyowl","oldSlug":"reason/interop","slug":"utiliser-reasonml-avec-javascript"},"body":"<p>Dans un <a href=\"/fr/articles/reason/introduction-reason/\">précédent article</a>, on vous\nprésentait une nouvelle syntaxe pour OCaml:\n<a href=\"https://reasonml.github.io\">ReasonML</a>, elle rend le langage plus accessible en\nle rapprochant de JavaScript moderne.</p>\n<p>À l'aide du projet\n<a href=\"https://bucklescript.github.io/bucklescript/Manual.html\">BuckleScript</a> qui\nsupporte Reason nativement, on peut compiler notre code Reason vers JavaScript\ntrès facilement. Le créateur de BuckleScript utilisait à l'origine un autre\nprojet appelé <a href=\"http://ocsigen.org/js_of_ocaml/\">js_of_ocaml</a>. Trouvant qu'il\nserait possible d'optimiser et de rendre plus lisible le code JavaScript en\nsortie si le compiler commençait son travail à une étape plus haut niveau (une\nreprésentation du programme contenant des informations supplémentaires, alors\nque js_of_ocaml utilise du bytecode), il propose ce changement à la team\njs_of_ocaml qui refuse, et décide donc de se lancer dans le projet qui deviendra\nBuckleScript.</p>\n<p>Pour démarrer un projet avec BuckleScript et Reason, on ouvre son terminal, et\nc'est parti:</p>\n<p>On installe BuckleScript:</p>\n<pre><code class=\"hljs language-console\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> npm install -g bs-platform</span>\n</code></pre>\n<p>On initialise le projet:</p>\n<pre><code class=\"hljs language-console\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> bsb -init my-app -theme basic-reason</span>\n</code></pre>\n<p>Hop, votre projet est prêt dans <code>my-app</code>.</p>\n<p>Maintenant la question est: comment est-ce que je peux utiliser du JS dans\nReason et vice-versa ?</p>\n<h2>Les FFI (ou Foreign Function Interface)</h2>\n<p>OCaml gère naturellement les <code>FFI</code>, notamment pour appeler des fonctions <code>C</code>\nlorsqu'il compile vers du code natif.</p>\n<p>BuckleScript vient les overloader pour les adapter à JavaScript.</p>\n<p>Créons une FFI pour la fonction <code>alert</code> :</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-attribute\">[@bs.val]</span> <span class=\"hljs-keyword\">external</span> alert : string =&gt; unit = <span class=\"hljs-string\">&quot;&quot;</span>;\n</code></pre>\n<p>On définit:</p>\n<ul>\n<li>une fonction externe nommée <code>alert</code></li>\n<li>qui prend une <code>string</code> et ne retourne <em>rien</em> (ici représenté par la valeur\n<code>unit</code>)</li>\n<li>qui est une valeur à simplement récupérer (<code>[@bs.val]</code>)</li>\n</ul>\n<p>Si on regarde le code JavaScript en sortie, c'est vide. En effet, <code>external</code> est\nun moyen de définir comment accéder à une valeur ainsi que son type. Si en\nrevanche on utilise la function <code>alert</code> dans le module:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-attribute\">[@bs.val]</span> <span class=\"hljs-keyword\">external</span> alert : string =&gt; unit = <span class=\"hljs-string\">&quot;&quot;</span>;\n\nalert(<span class=\"hljs-string\">&quot;Hello!&quot;</span>);\n</code></pre>\n<p>On voit dans l'output que BuckleScript a <em>inliné</em> l'appel de <code>alert</code>, il n'a pas\ncrée de représentation intermédiaire.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">&quot;use strict&quot;</span>;\n\nalert(<span class=\"hljs-string\">&quot;Hello!&quot;</span>);\n\n<span class=\"hljs-comment\">/*  Not a pure module */</span>\n</code></pre>\n<p>Maintenant amusons nous à créer des bindings pour jQuery, juste pour le fun:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* On crée un type opaque pour représenter un objet jQuery */</span>\n<span class=\"hljs-keyword\">type</span> jQuery;\n\n<span class=\"hljs-comment\">/* On type le module jQuery */</span>\n<span class=\"hljs-attribute\">[@bs.module]</span> <span class=\"hljs-keyword\">external</span> jQuery : string =&gt; jQuery = <span class=\"hljs-string\">&quot;jquery&quot;</span>;\n\n<span class=\"hljs-comment\">/* On type la méthod `on`, BuckleScript peut naturellement typer\n  le pattern de chaining, assez commun en JS, à l&#x27;aide de l&#x27;annotation\n  `bs.send.pipe: type` */</span>\n<span class=\"hljs-attribute\">[@bs.send.pipe: jQuery]</span> <span class=\"hljs-keyword\">external</span> on : string =&gt; (<span class=\"hljs-module-identifier\">Dom</span>.event =&gt; unit) =&gt; jQuery = <span class=\"hljs-string\">&quot;&quot;</span>;\n\njQuery(<span class=\"hljs-string\">&quot;.selector&quot;</span>)\n  <span class=\"hljs-operator\">|&gt;</span> on(<span class=\"hljs-string\">&quot;click&quot;</span>, (_) =&gt; alert(<span class=\"hljs-string\">&quot;hey&quot;</span>));\n</code></pre>\n<p>Ce qui va nous sortir:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">&quot;use strict&quot;</span>;\n\n<span class=\"hljs-keyword\">var</span> JQuery = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;jquery&quot;</span>);\n\nJQuery(<span class=\"hljs-string\">&quot;.selector&quot;</span>).on(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  alert(<span class=\"hljs-string\">&quot;hey&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">/* () */</span> <span class=\"hljs-number\">0</span>;\n});\n\n<span class=\"hljs-comment\">/*  Not a pure module */</span>\n</code></pre>\n<p>Comme on peut le constater, le code de sortie ressemble beaucoup à ce qu'on\npourrait écrire à la main.</p>\n<p>Pour en savoir un peu plus sur les FFI JavaScript:</p>\n<ul>\n<li><a href=\"https://bucklescript.github.io/bucklescript/Manual.html\">La documentation de BuckleScript</a></li>\n<li><a href=\"https://github.com/reasonml-community\">Les projets de bindings crées par la communauté</a>\n(ceux nommés <code>bs-{nom-de-lib-js}</code>)</li>\n</ul>\n<h2>Les objets</h2>\n<p>On peut directement utiliser des objets JavaScript en Reason. Pour accéder à une\npropriété, on utilise <code>##</code>.</p>\n<pre><code class=\"hljs language-reason\">myJsObject##property\n</code></pre>\n<p>Ça dépanne, mais au sein de notre code Reason, on préférera bien souvent\nutiliser des records: ils ont une représentation plus légère et sont par défaut\nimmutables. Pour effectuer une conversion, on procède de la manière suivante:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">type</span> jsUser = {\n  .\n  <span class=\"hljs-string\">&quot;id&quot;</span>: string,\n  <span class=\"hljs-string\">&quot;username&quot;</span>: string,\n  <span class=\"hljs-comment\">/* valeur pouvant être null, undefined, ou la valeur */</span>\n  <span class=\"hljs-string\">&quot;birthdate&quot;</span>: <span class=\"hljs-module-identifier\">Js</span>.<span class=\"hljs-module-identifier\">Null_undefined</span>.t(string),\n  <span class=\"hljs-comment\">/* &quot;light&quot; ou &quot;dark&quot;, les enums sont souvent représentés par des strings en JS */</span>\n  <span class=\"hljs-string\">&quot;theme&quot;</span>: string\n};\n\n<span class=\"hljs-comment\">/* En Reason, les enums sont représentés par des variants */</span>\n<span class=\"hljs-keyword\">type</span> theme =\n  | <span class=\"hljs-constructor\">Light</span>\n  | <span class=\"hljs-constructor\">Dark</span>;\n\n<span class=\"hljs-keyword\">type</span> user = {\n  id: string,\n  username: string,\n  <span class=\"hljs-comment\">/* pas de null ou undefined, on utilise un type option */</span>\n  birthdate: option(string),\n  theme\n};\n\n<span class=\"hljs-comment\">/* une fonction de transformation JS -&gt; Reason */</span>\n<span class=\"hljs-keyword\">let</span> fromJs = (jsUser) =&gt; {\n  id: jsUser##id,\n  username: jsUser##username,\n  <span class=\"hljs-comment\">/* BuckleScript propose des helpers pour les conversions */</span>\n  birthdate: <span class=\"hljs-module-identifier\">Js</span>.<span class=\"hljs-module-identifier\">Null_undefined</span>.to_opt(jsUser##birthdate),\n  theme:\n    <span class=\"hljs-keyword\">switch</span> jsUser##theme {\n    | <span class=\"hljs-string\">&quot;dark&quot;</span> =&gt; <span class=\"hljs-constructor\">Dark</span>\n    | <span class=\"hljs-string\">&quot;light&quot;</span>\n    <span class=\"hljs-comment\">/* On match une chaîne de caractère, le match n&#x27;est pas exhaustif,\n         on doit donc définir la valeur de fallback (par defaut) à l&#x27;aide\n         de `_`\n       */</span>\n    | _ =&gt; <span class=\"hljs-constructor\">Light</span>\n    }\n};\n\n<span class=\"hljs-comment\">/* Pour créer un objet JS en Reason, il suffit de l&#x27;écrire comme un\n     record, mais avec des clés entre quotes, comme du JSON.\n   */</span>\n<span class=\"hljs-keyword\">let</span> toJs = (user) =&gt; {\n  <span class=\"hljs-string\">&quot;id&quot;</span>: user.id,\n  <span class=\"hljs-string\">&quot;username&quot;</span>: user.username,\n  <span class=\"hljs-string\">&quot;birthdate&quot;</span>: <span class=\"hljs-module-identifier\">Js</span>.<span class=\"hljs-module-identifier\">Null_undefined</span>.from_opt(user.birthdate),\n  <span class=\"hljs-string\">&quot;theme&quot;</span>:\n    <span class=\"hljs-keyword\">switch</span> user.theme {\n    | <span class=\"hljs-constructor\">Light</span> =&gt; <span class=\"hljs-string\">&quot;light&quot;</span>\n    | <span class=\"hljs-constructor\">Dark</span> =&gt; <span class=\"hljs-string\">&quot;dark&quot;</span>\n    }\n};\n</code></pre>\n<p>Le code en sortie:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">&quot;use strict&quot;</span>;\n\n<span class=\"hljs-keyword\">var</span> Js_primitive = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;bs-platform/lib/js/js_primitive.js&quot;</span>);\n<span class=\"hljs-keyword\">var</span> Js_null_undefined = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;bs-platform/lib/js/js_null_undefined.js&quot;</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fromJs</span>(<span class=\"hljs-params\">jsUser</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> match = jsUser.theme;\n  <span class=\"hljs-keyword\">var</span> tmp;\n  <span class=\"hljs-keyword\">switch</span> (match) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;dark&quot;</span>:\n      tmp = <span class=\"hljs-comment\">/* Dark */</span> <span class=\"hljs-number\">1</span>;\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;light&quot;</span>:\n      tmp = <span class=\"hljs-comment\">/* Light */</span> <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      tmp = <span class=\"hljs-comment\">/* Light */</span> <span class=\"hljs-number\">0</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">/* record */</span> [\n    <span class=\"hljs-comment\">/* id */</span> jsUser.id,\n    <span class=\"hljs-comment\">/* username */</span> jsUser.username,\n    <span class=\"hljs-comment\">/* birthdate */</span> Js_primitive.null_undefined_to_opt(jsUser.birthdate),\n    <span class=\"hljs-comment\">/* theme */</span> tmp,\n  ];\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toJs</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> match = user[<span class=\"hljs-comment\">/* theme */</span> <span class=\"hljs-number\">3</span>];\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">id</span>: user[<span class=\"hljs-comment\">/* id */</span> <span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">username</span>: user[<span class=\"hljs-comment\">/* username */</span> <span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-attr\">birthdate</span>: Js_null_undefined.from_opt(user[<span class=\"hljs-comment\">/* birthdate */</span> <span class=\"hljs-number\">2</span>]),\n    <span class=\"hljs-attr\">theme</span>: match !== <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&quot;dark&quot;</span> : <span class=\"hljs-string\">&quot;light&quot;</span>,\n  };\n}\n\n<span class=\"hljs-built_in\">exports</span>.fromJs = fromJs;\n<span class=\"hljs-built_in\">exports</span>.toJs = toJs;\n<span class=\"hljs-comment\">/* No side effect */</span>\n</code></pre>\n<h2>Les standard-libs</h2>\n<p>Si le besoin s'en fait sentir, BuckleScript propose naturellement la stdlib de\nJavaScript.</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> myArray = <span class=\"hljs-literal\">[|</span><span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span><span class=\"hljs-literal\">|]</span>;\n\nmyArray\n  <span class=\"hljs-operator\">|&gt;</span> <span class=\"hljs-module-identifier\">Js</span>.<span class=\"hljs-module-identifier\">Array</span>.map((item) =&gt; item <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">2</span>)\n  <span class=\"hljs-operator\">|&gt;</span> <span class=\"hljs-module-identifier\">Js</span>.<span class=\"hljs-module-identifier\">Array</span>.reduce((acc, item) =&gt; acc <span class=\"hljs-operator\">+</span> item, <span class=\"hljs-number\">0</span>);\n</code></pre>\n<p>vous sortira:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">&quot;use strict&quot;</span>;\n\n<span class=\"hljs-keyword\">var</span> myArray = <span class=\"hljs-comment\">/* array */</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n\nmyArray\n  .map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> item &lt;&lt; <span class=\"hljs-number\">1</span>;\n  })\n  .reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">acc, item</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> (acc + item) | <span class=\"hljs-number\">0</span>;\n  }, <span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-built_in\">exports</span>.myArray = myArray;\n<span class=\"hljs-comment\">/*  Not a pure module */</span>\n</code></pre>\n<h2>La technique bourrin</h2>\n<p>Pour les cas extrêmes ou vous voulez juste balancer une fonction JS, vous\npouvez:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* %bs.raw pour une expression, %%bs.raw pour un bloc de code arbitraire */</span>\n<span class=\"hljs-keyword\">let</span> log: string =&gt; unit = <span class=\"hljs-attribute\">[%bs.raw {|\n  function (a) {\n    console.log(a);\n  }\n|}]</span>;\n\nlog(<span class=\"hljs-string\">&quot;ok&quot;</span>);\n</code></pre>\n<p>qui vous sort un joli:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>\n<span class=\"hljs-meta\">&quot;use strict&quot;</span>;\n\n<span class=\"hljs-keyword\">var</span> Curry = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;bs-platform/lib/js/curry.js&quot;</span>);\n\n<span class=\"hljs-keyword\">var</span> log = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(a);\n};\n\nCurry._1(log, <span class=\"hljs-string\">&quot;ok&quot;</span>);\n\n<span class=\"hljs-built_in\">exports</span>.log = log;\n<span class=\"hljs-comment\">/* log Not a pure module */</span>\n</code></pre>\n<h2>Conclusion</h2>\n<p>OCaml peut en grande majorité être compilé en JavaScript très simple, parce\nqu'il partage beaucoup de concepts avec ce dernier. Il est assez simple de créer\ndes ponts entre les deux langages à l'aide des FFI. L'énorme avantage de cette\nfeature, c'est que l'on peut commencer à utiliser Reason incrémentalement sur\nson projet sans avoir à tout réécrire d'un coup.</p>\n<p>Bisous bisous.</p>\n"}