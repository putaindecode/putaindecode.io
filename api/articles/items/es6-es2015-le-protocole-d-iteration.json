{"slug":"es6-es2015-le-protocole-d-iteration","filename":"2015-12-09-es6-es2015-le-protocole-d-iteration","title":"ES6, ES2015 : le protocole d'itération","date":"Wed, 09 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-09T00:00:00.000Z","title":"ES6, ES2015 : le protocole d'itération","author":"ffesseler","oldSlug":"js/es2015/iterators","slug":"es6-es2015-le-protocole-d-iteration"},"body":"<p>Imaginez un concept si important que si vous l’enleviez du langage, il faudrait\nen conséquence enlever le spread, le destructuring, les générateurs, le for…of\net bien d’autres. Ce concept, introduit dans l’ES6, est en fait un protocole :\nle protocole d’itération.</p>\n<p>Le principe est de définir une convention dans le langage, qui permet de\nstandardiser la façon dont des sources de données peuvent être traversées.</p>\n<p>Première bonne nouvelle, ce protocole est assez simple à comprendre et se base\nsur 2 &quot;interfaces&quot; (oui les guillemets c’est pour dire qu’on ne parle pas\nd’interface au sens technique, puisqu’elles n’existent pas en JS).</p>\n<p>La première interface, appelée <strong>Iterator</strong> permet à un objet de produire des\nvaleurs en séquence. Un objet est un Iterator lorsqu’il implémente une function\n<code>next()</code> qui retourne un objet avec 2 propriétés :</p>\n<ul>\n<li><code>value</code>: la valeur courante lors de l'itération</li>\n<li><code>done</code> : un booléen qui indique si on a atteint la fin de l’itération ou non</li>\n</ul>\n<p>Les appels successifs à la méthode <code>next()</code> d’un Iterator permettent donc de\ntraverser et récupérer les valeurs d’un objet. Prenons l’exemple de l’Iterator\nretourné par un Array qui contiendrait 2 valeurs (&quot;a&quot; et &quot;b&quot;) :</p>\n<pre><code class=\"hljs language-js\">iteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: &quot;a&quot;, done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: &quot;b&quot;, done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: undefined, done: true}</span>\n</code></pre>\n<p>Mais comment récupérer l’Iterator d’un objet vas-tu me dire ? (n’est-ce pas ?)\nÇa tombe bien, c’est le rôle de la seconde interface, appelée <strong>Iterable</strong>. Un\nobjet est Iterable s’il implémente une méthode particulière qui va retourner\nl'Iterator. Cette méthode particulière (appelée <em>@@iterator</em> dans la\nspécification) doit être définie en utilisant le symbole <code>[Symbol.iterator]</code>.\n(Les symboles seront expliqués dans un prochain article, pas de panique).</p>\n<p>En reprenant l’exemple précédent, voici comment récupérer l’Iterator d’un Array\n:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>];\n<span class=\"hljs-keyword\">const</span> iteratorArray = arr[<span class=\"hljs-built_in\">Symbol</span>.iterator]();\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: &quot;a&quot;, done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: &quot;b&quot;, done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: undefined, done: true}</span>\n</code></pre>\n<p>L’exemple ci-dessus illustre donc l’implémentation du protocole par l’Array. Il\nn’est pas très utile en soi, en voici donc un autre qui va permettre de boucler\nsur les valeurs et les afficher :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>];\n<span class=\"hljs-keyword\">var</span> iterator = arr[<span class=\"hljs-built_in\">Symbol</span>.iterator]();\n\n<span class=\"hljs-keyword\">var</span> result = iterator.next();\n<span class=\"hljs-keyword\">while</span> (!result.done) {\n  <span class=\"hljs-built_in\">console</span>.log(result.value);\n  result = iterator.next();\n}\n<span class=\"hljs-comment\">// &#x27;a&#x27;</span>\n<span class=\"hljs-comment\">// &#x27;b&#x27;</span>\n</code></pre>\n<p>De manière générale, quand un objet qui implémente le protocole d’itération est\ntraversé, sa méthode <em>@@iterator</em> est appelée (une seule fois donc) et\nl’Iterator retourné est utilisé pour boucler sur ses valeurs.</p>\n<h1>Consommateurs d'Iterable</h1>\n<p>La deuxième bonne nouvelle, c’est que plusieurs concepts du langage tirent\navantage de ce protocole :</p>\n<ul>\n<li>Certaines syntaxes s’attendent à recevoir des Iterables</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>];\n\n<span class=\"hljs-comment\">// La syntaxe à laquelle on pense immédiatement est la syntaxe « for .. of »</span>\n<span class=\"hljs-comment\">// qui permet de boucler sur les valeurs des Iterables.</span>\n<span class=\"hljs-keyword\">for</span> (val <span class=\"hljs-keyword\">of</span> arr) {\n  <span class=\"hljs-built_in\">console</span>.log(val);\n}\n\n<span class=\"hljs-comment\">// Le spread qui permet d&#x27;insérer facilement des valeurs dans un Array</span>\n<span class=\"hljs-comment\">// utilise également des Iterable</span>\n[<span class=\"hljs-string\">&quot;0&quot;</span>, ...arr, <span class=\"hljs-string\">&quot;1&quot;</span>]; <span class=\"hljs-comment\">// 0, a, b, 1</span>\n\n<span class=\"hljs-comment\">// yield nécessite également des Iterable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">gen</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span>* arr;\n}\ngen().next(); <span class=\"hljs-comment\">// { value:&quot;a&quot;, done:false }</span>\n\n<span class=\"hljs-comment\">// Le destructuring avec le pattern Array</span>\n<span class=\"hljs-keyword\">const</span> [x, y] = arr; <span class=\"hljs-comment\">// x = &#x27;a&#x27;,  y = &quot;b&quot;</span>\n</code></pre>\n<ul>\n<li>Des API acceptent également des Iterables</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>];\n\n<span class=\"hljs-comment\">// Certains constructeurs acceptent des Iterable</span>\n\n<span class=\"hljs-comment\">// Set et Weakset</span>\n<span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(arr);\nset.has(<span class=\"hljs-string\">&quot;b&quot;</span>); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-comment\">// Map et WeakMap</span>\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(arr.entries()); <span class=\"hljs-comment\">// Attention, le constructeur attend un ensemble [clé, valeur]</span>\nmap.get(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// &#x27;a&#x27;</span>\n\n<span class=\"hljs-comment\">// Ou encore les API suivants :</span>\n\n<span class=\"hljs-built_in\">Array</span>.from(iterable); <span class=\"hljs-comment\">// transforme n&#x27;importe quel Iterable en Array.</span>\n<span class=\"hljs-built_in\">Promise</span>.all(iterableCollectionDePromises); <span class=\"hljs-comment\">// n&#x27;importe quel Iterable qui contient un ensemble de Promises</span>\n<span class=\"hljs-built_in\">Promise</span>.race(iterableCollectionDePromises); <span class=\"hljs-comment\">// idem</span>\n</code></pre>\n<h1>Built-in Iterable</h1>\n<p>Troisième bonne nouvelle, plusieurs objets du langage implémentent déjà ce\nprotocole :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// évidemment les Array</span>\n<span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;l&quot;</span>, <span class=\"hljs-string\">&quot;o&quot;</span>, <span class=\"hljs-string\">&quot;l&quot;</span>];\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> arr) {\n  <span class=\"hljs-built_in\">console</span>.log(v);\n  <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n  <span class=\"hljs-comment\">// &#x27;o&#x27;</span>\n  <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n}\n\n<span class=\"hljs-comment\">// les String</span>\n<span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">&quot;lol&quot;</span>;\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> str) {\n  <span class=\"hljs-built_in\">console</span>.log(v);\n  <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n  <span class=\"hljs-comment\">// &#x27;o&#x27;</span>\n  <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n}\n\n<span class=\"hljs-comment\">// les Map et Set (mais PAS WeakMap et WeakSet)</span>\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-string\">&quot;l&quot;</span>, <span class=\"hljs-number\">1</span>).set(<span class=\"hljs-string\">&quot;o&quot;</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> map) {\n  <span class=\"hljs-built_in\">console</span>.log(v);\n  <span class=\"hljs-comment\">// [&quot;l&quot;, 1]</span>\n  <span class=\"hljs-comment\">// [&quot;o&quot;, 2]</span>\n}\n<span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>().add(<span class=\"hljs-string\">&quot;l&quot;</span>).add(<span class=\"hljs-string\">&quot;o&quot;</span>);\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> map) {\n  <span class=\"hljs-built_in\">console</span>.log(v);\n  <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n  <span class=\"hljs-comment\">// &#x27;o&#x27;</span>\n}\n\n<span class=\"hljs-comment\">// Les TypedArray que vous utilisez tous les jours</span>\n<span class=\"hljs-keyword\">const</span> int16 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>(<span class=\"hljs-number\">2</span>);\nint16[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> int16) {\n  <span class=\"hljs-built_in\">console</span>.log(v);\n  <span class=\"hljs-comment\">// 42</span>\n  <span class=\"hljs-comment\">// 0</span>\n}\n\n<span class=\"hljs-comment\">// Même l&#x27;objet spécial arguments (que vous</span>\n<span class=\"hljs-comment\">// ne devriez plus utiliser avec l&#x27;ES6) est un Iterable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">arguments</span>) {\n    <span class=\"hljs-built_in\">console</span>.log(v);\n    <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n    <span class=\"hljs-comment\">// &#x27;o&#x27;</span>\n    <span class=\"hljs-comment\">// &#x27;l&#x27;</span>\n  }\n}\ntest(<span class=\"hljs-string\">&quot;l&quot;</span>, <span class=\"hljs-string\">&quot;o&quot;</span>, <span class=\"hljs-string\">&quot;l&quot;</span>);\n\n<span class=\"hljs-comment\">// Les NodeList retournés par l&#x27;API DOM également !</span>\n<span class=\"hljs-keyword\">const</span> matches = <span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">&quot;div&quot;</span>);\n<span class=\"hljs-keyword\">for</span> (m <span class=\"hljs-keyword\">of</span> matches) {\n  <span class=\"hljs-built_in\">console</span>.log(m);\n  <span class=\"hljs-comment\">// &lt;div id=&quot;topSection&quot;&gt;</span>\n  <span class=\"hljs-comment\">// &lt;div id=&quot;brandLogo&quot;&gt;</span>\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Autre point : Array, TypedArray, Map, Set sont des Iterable mais définissent\naussi des méthodes qui retournent également des Iterable (ça va, vous suivez\ntoujours ?) :</p>\n<ul>\n<li>entries() retourne un ensemble des clés/valeurs</li>\n<li>keys() retourne les clés</li>\n<li>values() retourne les valeurs</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">for</span> (cleVals <span class=\"hljs-keyword\">of</span> arr.entries()) {\n  <span class=\"hljs-built_in\">console</span>.log(cleVals);\n  <span class=\"hljs-comment\">// [0, &quot;l&quot;]</span>\n  <span class=\"hljs-comment\">// [1, &quot;o&quot;]</span>\n  <span class=\"hljs-comment\">// [2, &quot;l&quot;]</span>\n}\n</code></pre>\n<p>Détail important, <code>Object</code> n'est pas Iterable mais il n'est pas impossible de\nvoir apparaitre dans l'ES7 les méthodes entries(), keys() et values() sur Object\n(cf.\n<a href=\"https://github.com/tc39/proposal-object-values-entries\">la proposition spec</a>).</p>\n<h1>Conclusion</h1>\n<p>J’espère que cet article a bien illustré l’importance de ce protocole dans le\nlangage. Nous avons vu ci-dessus que de nombreux concepts du langage tirent déjà\navantage de ce protocole mais il est au moins aussi important de noter que cela\npermet d’établir une convention sur laquelle des librairies externes peuvent\ns’appuyer.</p>\n<p>Elles peuvent le faire de 2 manières :</p>\n<ul>\n<li>en proposant des sources de données qui implémentent le protocole (ex: liste\nchaînée)</li>\n<li>en tant que consommateur du protocole (ex: un algorithme de tri)</li>\n</ul>\n<h1>Un dernier verre pour la route</h1>\n<p>Les articles suivants vous permettront d'aller encore plus loin dans le sujet.\nVous y apprendrez notamment qu’un iterator peut retourner en option 2 autres\nméthodes, qu’un générateur est à la fois un Iterable et un Iterator, qu’un\nIterable peut être infini ou encore des exemples d’implémentations divers et\nvariés :</p>\n<ul>\n<li><a href=\"http://www.2ality.com/2015/02/es6-iteration.html\">Iterables and iterators in ECMAScript 6</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">Iteration Protocols</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/\">ES6 in depth : iterators and the for of loop</a></li>\n<li><a href=\"https://ponyfoo.com/articles/es6-iterators-in-depth\">ES6 iterators in depth</a></li>\n</ul>\n<p>La pratique restant le meilleur moyen de se former, le site\n<a href=\"http://es6katas.org/\">ES6 Katas</a> est très bien fait pour s'exercer.</p>\n"}