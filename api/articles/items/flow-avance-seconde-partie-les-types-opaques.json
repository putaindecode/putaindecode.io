{"slug":"flow-avance-seconde-partie-les-types-opaques","filename":"2018-01-02-flow-avance-seconde-partie-les-types-opaques","title":"Flow avancé - Seconde partie: les types opaques","date":"Tue, 02 Jan 2018 00:00:00 GMT","draft":false,"meta":{"date":"2018-01-02T00:00:00.000Z","title":"Flow avancé - Seconde partie: les types opaques","author":"zoontek","oldSlug":"js/flow/advanced-part-2","slug":"flow-avance-seconde-partie-les-types-opaques"},"body":"<p>Vous avez digéré le premier article, peut-être même débuté avec\n<a href=\"https://flow.org/\">flow</a> depuis, mais vous mourez d'envie de découvrir ce que\nvous pouvez faire de plus avec votre nouvel outil préféré ? Tant mieux, puisque\nnous sommes là pour parler d'une fonctionnalité assez avancée, apparue avec la\nversion 0.51 et, à l'heure où j'écris ces lignes, indisponible dans TypeScript:\nles types opaques.</p>\n<p>Si vous n'avez pas installé flow au sein de votre projet, je vous renvoie au\n<a href=\"/fr/articles/js/flow/advanced-part-1/\">premier article</a> qui vous expliquera\ntrès bien comment faire.</p>\n<h2>Transparence de types</h2>\n<p>Si on parle de types opaques, c'est bien parce que les types transparents\nexistent. D'ailleurs par défaut, tout alias de type défini l'est. Mais que\nsont-ils ? Simple: ce sont des types compatibles entre eux et donc\ninterchangeables.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype FirstName = string;\ntype LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">&quot;Acthernoene&quot;</span>;\nyellFirstName(name);\n</code></pre>\n<p>Dans cet exemple, les types <code>FirstName</code> et <code>LastName</code> étant tout deux des alias\nde <code>string</code>, on peut sans problème utiliser la variable <code>name</code> de type\n<code>LastName</code> là où la function <code>yellFirstName</code> attend un paramètre de type\n<code>FirstName</code>. Pas cool.</p>\n<h2>Rendons tout cela opaque</h2>\n<p>Nous allons donc modifier l'exemple précédent et…</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">&quot;Acthernoene&quot;</span>;\nyellFirstName(name);\n</code></pre>\n<p>…toujours pas d'erreur ? Du calme, c'est normal. Les types <code>FirstName</code> et\n<code>LastName</code> étant accessibles car dans le même module JS, flow sait que ceux-ci\nsont des alias de type <code>string</code>. Modifions l'exemple et créons un deuxième\nmodule.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\ntype User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./module&quot;</span>;\n\nyellFirstName(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// ⚠️ Erreur: &quot;string. Ce type est incompatible avec le type de paramètre attendu FirstName&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">&quot;Acthernoene&quot;</span>, <span class=\"hljs-string\">&quot;Mathieu&quot;</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n</code></pre>\n<p>On voit ici qu'il n'est en fait possible d'utiliser le type <code>FirstName</code> qu'après\nson assignation au sein du module où celui-ci est défini. Un autre exemple: si\nl'on venait à rendre le type <code>User</code> opaque, alors nous ne pourrions pas accéder\nà <code>user.firstName</code>, la propriété étant inaccessible autrement que par une\nfonction qui manipulera le type <code>User</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nopaque type User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellUserFirstName</span>(<span class=\"hljs-params\">user: User</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(user.firstName.toUpperCase());\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName, yellUserFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./module&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">&quot;Acthernoene&quot;</span>, <span class=\"hljs-string\">&quot;Mathieu&quot;</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// ⚠️ Erreur: &quot;Propriété `firstName`. La propriété n&#x27;est pas accessible sur le type User&quot;</span>\nyellUserFirstName(user); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n</code></pre>\n<h2>Tu n'aurais pas un exemple plus concret ?</h2>\n<p>Bien sûr que si ! Nous pouvons utiliser les types opaques pour implémenter un\ntype <code>UUID</code> très basique:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// uuid.js</span>\n\n<span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;uuid/v4&quot;</span>; <span class=\"hljs-comment\">// On installe 2 packages</span>\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;validator&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID = string;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./uuid&quot;</span>;\n\nUUID.check(<span class=\"hljs-string\">&quot;a duck&quot;</span>); <span class=\"hljs-comment\">// ⚠️ Erreur: &quot;string. Ce type est incompatible avec le type de paramètre attendu UUID&quot;</span>\nUUID.check(<span class=\"hljs-string\">&quot;df7cca36-3d7a-40f4-8f06-ae03cc22f045&quot;</span>); <span class=\"hljs-comment\">// ⚠️ Erreur: &quot;string. Ce type est incompatible avec le type de paramètre attendu UUID&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// ⚠️ Erreur: &quot;Appel de méthode `toUpperCase`. La méthode ne peut pas être appelée sur un type UUID&quot;</span>\n</code></pre>\n<h1>C'est tout de même assez restrictif…je voudrais ne pas devoir tout réimplémenter</h1>\n<p>Ne vous inquiétez pas, les développeurs à l'origine de flow ont tout prévu et\npour remédier à cela il existe ce qu'on appelle le sous-typage (ou <em>SubTyping</em>\ndans la langue de Shakespeare). Ainsi, nous allons dire à flow que chaque <code>UUID</code>\nest un <code>string</code> mais que la réciproque ce sera pas vraie pour autant.</p>\n<p>Reprenons l'exemple précédent.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;uuid/v4&quot;</span>;\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;validator&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID: string = string; <span class=\"hljs-comment\">// Seul cette ligne change, on y ajoute un sous-type string</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./uuid&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// Pas d&#x27;erreur: même si uuid est un UUID, il est utilisable comme un type string</span>\n</code></pre>\n<h2>Que retenir de tout ça ?</h2>\n<p>Comme on a pu le voir, les types opaques élèvent clairement le niveau du\ntype-game dans le milieu du JavaScript. Forcément utiles pour imposer\nl'utilisation de fonctions pour créer / manipuler certaines données, ils\ns'avéreront assez vite indispensables pour structurer davantage votre JS et\naméliorer sa maintenabilité.</p>\n<p>Je vous encourage d'ailleurs à vous en servir quasiment partout (ça sera assez\nchiant au début, mais vous me remercierez plus tard) !</p>\n<p>La bise, et rendez-vous pour une troisième partie 😘</p>\n"}