{"slug":"flow-avance-seconde-partie-les-types-opaques","filename":"2018-01-02-flow-avance-seconde-partie-les-types-opaques","title":"Flow avanc√© - Seconde partie: les types opaques","date":"Tue, 02 Jan 2018 00:00:00 GMT","draft":false,"meta":{"date":"2018-01-02T00:00:00.000Z","title":"Flow avanc√© - Seconde partie: les types opaques","author":"zoontek","oldSlug":"js/flow/advanced-part-2","slug":"flow-avance-seconde-partie-les-types-opaques"},"body":"<p>Vous avez dig√©r√© le premier article, peut-√™tre m√™me d√©but√© avec\n<a href=\"https://flow.org/\">flow</a> depuis, mais vous mourez d'envie de d√©couvrir ce que\nvous pouvez faire de plus avec votre nouvel outil pr√©f√©r√© ? Tant mieux, puisque\nnous sommes l√† pour parler d'une fonctionnalit√© assez avanc√©e, apparue avec la\nversion 0.51 et, √† l'heure o√π j'√©cris ces lignes, indisponible dans TypeScript:\nles types opaques.</p>\n<p>Si vous n'avez pas install√© flow au sein de votre projet, je vous renvoie au\n<a href=\"/fr/articles/js/flow/advanced-part-1/\">premier article</a> qui vous expliquera\ntr√®s bien comment faire.</p>\n<h2>Transparence de types</h2>\n<p>Si on parle de types opaques, c'est bien parce que les types transparents\nexistent. D'ailleurs par d√©faut, tout alias de type d√©fini l'est. Mais que\nsont-ils ? Simple: ce sont des types compatibles entre eux et donc\ninterchangeables.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype FirstName = string;\ntype LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">&quot;Acthernoene&quot;</span>;\nyellFirstName(name);\n</code></pre>\n<p>Dans cet exemple, les types <code>FirstName</code> et <code>LastName</code> √©tant tout deux des alias\nde <code>string</code>, on peut sans probl√®me utiliser la variable <code>name</code> de type\n<code>LastName</code> l√† o√π la function <code>yellFirstName</code> attend un param√®tre de type\n<code>FirstName</code>. Pas cool.</p>\n<h2>Rendons tout cela opaque</h2>\n<p>Nous allons donc modifier l'exemple pr√©c√©dent et‚Ä¶</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">&quot;Acthernoene&quot;</span>;\nyellFirstName(name);\n</code></pre>\n<p>‚Ä¶toujours pas d'erreur ? Du calme, c'est normal. Les types <code>FirstName</code> et\n<code>LastName</code> √©tant accessibles car dans le m√™me module JS, flow sait que ceux-ci\nsont des alias de type <code>string</code>. Modifions l'exemple et cr√©ons un deuxi√®me\nmodule.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\ntype User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./module&quot;</span>;\n\nyellFirstName(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: &quot;string. Ce type est incompatible avec le type de param√®tre attendu FirstName&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">&quot;Acthernoene&quot;</span>, <span class=\"hljs-string\">&quot;Mathieu&quot;</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n</code></pre>\n<p>On voit ici qu'il n'est en fait possible d'utiliser le type <code>FirstName</code> qu'apr√®s\nson assignation au sein du module o√π celui-ci est d√©fini. Un autre exemple: si\nl'on venait √† rendre le type <code>User</code> opaque, alors nous ne pourrions pas acc√©der\n√† <code>user.firstName</code>, la propri√©t√© √©tant inaccessible autrement que par une\nfonction qui manipulera le type <code>User</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nopaque type User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellUserFirstName</span>(<span class=\"hljs-params\">user: User</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(user.firstName.toUpperCase());\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName, yellUserFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./module&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">&quot;Acthernoene&quot;</span>, <span class=\"hljs-string\">&quot;Mathieu&quot;</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: &quot;Propri√©t√© `firstName`. La propri√©t√© n&#x27;est pas accessible sur le type User&quot;</span>\nyellUserFirstName(user); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n</code></pre>\n<h2>Tu n'aurais pas un exemple plus concret ?</h2>\n<p>Bien s√ªr que si ! Nous pouvons utiliser les types opaques pour impl√©menter un\ntype <code>UUID</code> tr√®s basique:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// uuid.js</span>\n\n<span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;uuid/v4&quot;</span>; <span class=\"hljs-comment\">// On installe 2 packages</span>\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;validator&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID = string;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./uuid&quot;</span>;\n\nUUID.check(<span class=\"hljs-string\">&quot;a duck&quot;</span>); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: &quot;string. Ce type est incompatible avec le type de param√®tre attendu UUID&quot;</span>\nUUID.check(<span class=\"hljs-string\">&quot;df7cca36-3d7a-40f4-8f06-ae03cc22f045&quot;</span>); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: &quot;string. Ce type est incompatible avec le type de param√®tre attendu UUID&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// ‚ö†Ô∏è Erreur: &quot;Appel de m√©thode `toUpperCase`. La m√©thode ne peut pas √™tre appel√©e sur un type UUID&quot;</span>\n</code></pre>\n<h1>C'est tout de m√™me assez restrictif‚Ä¶je voudrais ne pas devoir tout r√©impl√©menter</h1>\n<p>Ne vous inqui√©tez pas, les d√©veloppeurs √† l'origine de flow ont tout pr√©vu et\npour rem√©dier √† cela il existe ce qu'on appelle le sous-typage (ou <em>SubTyping</em>\ndans la langue de Shakespeare). Ainsi, nous allons dire √† flow que chaque <code>UUID</code>\nest un <code>string</code> mais que la r√©ciproque ce sera pas vraie pour autant.</p>\n<p>Reprenons l'exemple pr√©c√©dent.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;uuid/v4&quot;</span>;\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;validator&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID: string = string; <span class=\"hljs-comment\">// Seul cette ligne change, on y ajoute un sous-type string</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./uuid&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d&#x27;erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// Pas d&#x27;erreur: m√™me si uuid est un UUID, il est utilisable comme un type string</span>\n</code></pre>\n<h2>Que retenir de tout √ßa ?</h2>\n<p>Comme on a pu le voir, les types opaques √©l√®vent clairement le niveau du\ntype-game dans le milieu du JavaScript. Forc√©ment utiles pour imposer\nl'utilisation de fonctions pour cr√©er / manipuler certaines donn√©es, ils\ns'av√©reront assez vite indispensables pour structurer davantage votre JS et\nam√©liorer sa maintenabilit√©.</p>\n<p>Je vous encourage d'ailleurs √† vous en servir quasiment partout (√ßa sera assez\nchiant au d√©but, mais vous me remercierez plus tard) !</p>\n<p>La bise, et rendez-vous pour une troisi√®me partie üòò</p>\n"}