{"slug":"developper-avec-create-react-app-et-une-api-nodejs","filename":"2017-11-07-developper-avec-create-react-app-et-une-api-nodejs","title":"Développer avec Create React App et une API Node.js","date":"Tue, 07 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-07T00:00:00.000Z","title":"Développer avec Create React App et une API Node.js","author":"tmaziere","oldSlug":"js/react/create-react-app-et-api","slug":"developper-avec-create-react-app-et-une-api-nodejs"},"body":"<h2>tl;dr</h2>\n<p>Dans un environnement de développement, pour lancer dans le même temps votre\napplication React et une API basée sur Node.js, vous pouvez imbriquer\njudicieusement les deux dépôts Git, puis utiliser un script NPM et quelques\npackages bien pratiques tels que <em>concurrently</em> et <em>nodemon</em> pour lancer les\ndeux serveurs d'une seule commande. Pratique ! D'autant que pour contourner les\nrestrictions d'accès liées à la\n<a href=\"https://fr.wikipedia.org/wiki/Same-origin_policy\"><em>politique de même origine</em></a>,\n<strong>create-react-app</strong> permet le paramétrage d'un <em>proxy</em> pour vos requêtes API.</p>\n<h2>Est-ce que ça me concerne ?</h2>\n<p>La généralisation des architectures dites &quot;API first&quot; répond à des impératifs\nhumains et techniques très divers. En ce qui concerne l'organisation du travail\ndes développeurs, c'est l'assurance de pouvoir scinder l'implémentation de\nl'accès aux données -aux ressources- d'une part, et le travail sur l'UI/UX,\nd'autre part. Un premier groupe peut concevoir une API robuste et proposer un\n&quot;contrat&quot; clair à l'équipe <em>frontend</em> qui accède aux données avec un référentiel\nunique, que l'application soit web ou mobile.</p>\n<p>De cette façon, la conception de l'interface utilisateur est libérée d'une\ngrande partie des contraintes qui régissent les architectures MVC\ntraditionnelles. Le développeur peut ainsi mieux se concentrer sur la qualité de\nsa réponse aux spécifications fonctionnelles.</p>\n<p>Si l'architecture de votre projet est de ce type, et que vous attaquez la\nconception d'un frontend\n<a href=\"https://fr.wikipedia.org/wiki/Application_web_monopage\">SPA</a> React avec\n<a href=\"https://github.com/facebookincubator/create-react-app\">create-react-app</a>\n(quelle bonne idée !), ce qui suit peut vous éclairer. Nous allons voir comment\nil est possible d'accéder sans se compliquer la vie à une API RESTful basée sur\nNode.js, en imbriquant correctement ses dépôts.</p>\n<h2>Deux dépôts : le frontend, l’API</h2>\n<p>Le principe est le suivant : vous ne souhaitez pas forcément modifier l'API qui\nest implémentée par une autre équipe, ou par un collègue, mais vous devez y\naccéder facilement depuis votre application React.</p>\n<p>Vous allez pour cela devoir travailler sur deux dépôts Git clonés : celui du\n<em>frontend</em> React contiendra par exemple celui de l'API, et un <em>script NPM</em> se\nchargera de lancer les deux applications, sur deux ports différents.</p>\n<p><em>Faut-il utiliser un framework en particulier pour le backend ?</em>  <br />\nAbsolument pas ! Pour ma part je travaille plus volontiers avec <a href=\"https://loopback.io/\">LoopBack</a>,\nmais tout ce que qui s'appuie sur Node.js fait l'affaire.</p>\n<h2>Organisation locale du code</h2>\n<p>Mettons que votre projet React s'appelle <strong>my-react-frontend</strong> et que l'API\nqu'il consomme répond au doux nom de <strong>my-node-api</strong>.</p>\n<p><strong>my-react-frontend</strong> est cloné à la racine, c'est le projet parent. Il contient\nau moins les répertoires <code>src/</code>, <code>public/</code> et <code>node_modules/</code> générés par\n<em>create-react-app</em>.</p>\n<p><code>build/</code> peut également être présent si vous avez déjà lancé au moins une fois\nla commande <code>npm run build</code>.</p>\n<p>A la racine de <strong>my-react-frontend</strong>, clonez le dépôt <strong>my-node-api</strong>.</p>\n<p>Vous devez obtenir :</p>\n<pre><code>my-react-frontend/\n-- my-node-api/\n-- node_modules/\n-- public/\n-- src/\n...\n</code></pre>\n<p>Ne nous attardons pas trop sur <code>my-node-api</code>, qui peut être implémenté de très\nnombreuses manières. Partons du principe qu'une fois lancé, le serveur expose\nles ressources dont votre application a besoin sur <code>http://localhost:3001</code>. Et\ndisons juste que si l'équipe <em>backend</em> vous signale une mise à jour, vous ferez\nsimplement :</p>\n<pre><code class=\"hljs language-Shell\">cd my-node-api/\ngit pull\n</code></pre>\n<p><em>Faut-il forcément organiser les dépôts de cette façon ?</em>  <br />\nPas du tout. Mais l'intérêt de cette configuration, c'est que le <em>backend</em> est &quot;dans\nsa bulle&quot; et que les développeurs qui le font évoluer n'ont pas à organiser le code\nen fonction de ce <em>frontend</em> en particulier.</p>\n<p>Dernière chose importante : pensez à ajouter <code>my-node-api/</code> au fichier\n<code>.gitignore</code> du projet React. Il ne faudrait évidemment pas qu'il versionne le\n<em>backend</em>.</p>\n<h2>Passez moi sur le CORS</h2>\n<p>En production, il est fréquent d'utiliser le même serveur pour servir\nl'application React et l'API sous-jacente. Dans cette configuration, le\nmécanisme de <em>Cross-origin resource sharing</em>\n(<a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">CORS</a>), basé sur\ndes headers HTTP, n'a pas à être implémenté.</p>\n<p>En développement, par contre, il est plus pratique de dissocier les serveurs\npour bénéficier de toutes les fonctionnalités de l'écosystème React.</p>\n<p>Pour répondre à cette contrainte, <em>create-react-app</em> propose\n<a href=\"https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development\">un mécanisme</a>\nqui permet de mettre en place un <strong>proxy</strong> d'API.</p>\n<p>En partant du principe que votre frontend écoute sur le port 3000, et le serveur\nAPI sur le port 3001, il suffit d'ajouter un paramètre au premier niveau du\n<code>package.json</code> :</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">&quot;proxy&quot;</span>: <span class=\"hljs-string\">&quot;http://localhost:3001&quot;</span>\n}\n</code></pre>\n<p>De cette façon, vous pourrez utiliser un chemin relatif pour accéder à vos\nressources. Si une requête ne concerne pas un <em>asset</em> statique, elle sera\nrelayée vers votre <em>backend</em>. <code>fetch('/api/bananas')</code>, par exemple, requêtera\nnotre API sur <code>http://localhost:3001/api/bananas</code>.</p>\n<h2>Tout lancer en une seule commande</h2>\n<p>Nous utiliserons pour cela un script NPM défini dans le <code>package.json</code> situé à\nla racine du projet React.</p>\n<p>Deux petits outils seront nécessaires pour créer le script <em>ad hoc</em> :</p>\n<ul>\n<li>le package <a href=\"https://www.npmjs.com/package/concurrently\"><code>concurrently</code></a> qui\npermet de lancer plusieurs scripts en une seule commande. Faites par exemple\nun <code>npm install --save-dev concurrently</code>.</li>\n<li>le package <a href=\"https://www.npmjs.com/package/nodemon\"><code>nodemon</code></a> qui scrute votre\n<em>backend</em> Node.js et relance le serveur automatiquement en cas de modification\ndu code. Faites donc un <code>npm install --save-dev nodemon</code>, vous ne le\nregretterez pas.</li>\n</ul>\n<p>Tout est prêt ! Ouvrez <code>package.json</code> et ajoutez dans les <code>scripts</code>:</p>\n<pre><code class=\"hljs language-json\">&quot;start-with-api&quot;: &quot;concurrently \\&quot;react-scripts start\\&quot; \\&quot;PORT=3001 nodemon ./my-node-api/server/server.js\\&quot;&quot;\n</code></pre>\n<p>Le chemin d'accès au script serveur est à adapter en fonction de vos propres\nchoix techniques ! Notez que dans ce cas précis, on passe une variable\nd'environnement <code>PORT</code> que le script serveur utilise pour écraser son port\nd'écoute par défaut.</p>\n<p>Au final, le <code>package.json</code> doit ressembler à ceci :</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;my-react-frontend&quot;</span>,\n  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,\n  <span class=\"hljs-attr\">&quot;private&quot;</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">&quot;proxy&quot;</span>: <span class=\"hljs-string\">&quot;http://localhost:3001&quot;</span>,\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: {\n    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;react-scripts start&quot;</span>,\n    <span class=\"hljs-attr\">&quot;start-with-api&quot;</span>:\n      <span class=\"hljs-string\">&quot;concurrently \\&quot;react-scripts start\\&quot; \\&quot;PORT=3001 nodemon ./my-node-api/server/server.js\\&quot;&quot;</span>,\n    <span class=\"hljs-attr\">&quot;build&quot;</span>: <span class=\"hljs-string\">&quot;react-scripts build&quot;</span>,\n    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;react-scripts test --env=jsdom&quot;</span>,\n    <span class=\"hljs-attr\">&quot;eject&quot;</span>: <span class=\"hljs-string\">&quot;react-scripts eject&quot;</span>\n  },\n  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: {\n    <span class=\"hljs-attr\">&quot;react-scripts&quot;</span>: <span class=\"hljs-string\">&quot;1.0.14&quot;</span>,\n    <span class=\"hljs-attr\">&quot;concurrently&quot;</span>: <span class=\"hljs-string\">&quot;3.5.0&quot;</span>,\n    <span class=\"hljs-attr\">&quot;nodemon&quot;</span>: <span class=\"hljs-string\">&quot;1.12.1&quot;</span>\n  },\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: {\n    <span class=\"hljs-attr\">&quot;react&quot;</span>: <span class=\"hljs-string\">&quot;^16.0.0&quot;</span>,\n    <span class=\"hljs-attr\">&quot;react-dom&quot;</span>: <span class=\"hljs-string\">&quot;^16.0.0&quot;</span>\n  }\n}\n</code></pre>\n<p>Pour mémoire, nous n'avons ajouté que deux lignes : &quot;proxy&quot; et\n&quot;scripts/start-with-api&quot;.</p>\n<h2>Une astuce pour les pressés</h2>\n<p>Si le backend ne joue pas un grand rôle dans votre application ou si -plus\nprobablement- vous souhaitez démarrer sans attendre que le véritable backend\nsoit disponible, je vous conseille de tester l'excellent\n<a href=\"https://github.com/typicode/json-server\"><code>json-server</code></a>.</p>\n<p>Cet élégant package offre la possibilité de créer un fichier JSON avec quelques\ndonnées factices (<em>data fixtures</em>) et de les mettre à disposition de votre\napplication à la façon d'une API RESTful, grâce à un simple\n<code>json-server --watch db.json</code>.</p>\n<p>Il va sans dire qu'en modifiant légèrement le script <em>start-with-api</em>, vous\ndisposerez en quelques secondes d'un <em>backend</em> au poil pour votre nouvelle\napplication.</p>\n"}