{"slug":"2021-01-29-ecrivez-du-code-stupide","filename":"2021-01-29-ecrivez-du-code-stupide","title":"Écrivez du code stupide","date":"Fri, 29 Jan 2021 00:00:00 GMT","draft":false,"meta":{"title":"Écrivez du code stupide","date":"2021-01-29T00:00:00.000Z","author":"bloodyowl"},"body":"<p>Dans les premières années de nos carrières, on se concentre souvent sur le fait\nde faire du code dont on peut être fier. Du code propre. Du code élégant. Du\ncode intelligent.</p>\n<p>J'ai passé des heures à essayer que mon code fasse des trucs intelligents, à\nessayer d'éviter la répétition à tout prix avec de la factorisation, à écrire\ndes abstractions dans tous les sens, m'assurant que j'écrivais toujours le bout\nde code le plus court pour une tâche donnée.</p>\n<p>J'en ai aujourd'hui plus rien à secouer. Du tout.</p>\n<p>J'en suis arrivé à un petit mantra:</p>\n<div style=\"font-size: 32px; text-align: center;\">\n  <strong>Faites des plans intelligents.</strong><br>\n  <strong>Écrivez du code stupide.</strong>\n</div>\n<h2>Pourquoi → Comment → Quoi</h2>\n<p>J'aime beaucoup la conférence TED\n<a href=\"https://www.youtube.com/watch?v=u4ZoJKF_VuA\">«Start with why»</a> de Simon Sinek\n(vous l'avez très certainement déjà vue), et bien que ça parle de boites, je\npense que l'idée générale peut s'appliquer à beaucoup de domaines.</p>\n<p>Pour paraphraser un peu: <strong>partez de la vision, puis trouvez un moyen de la concrétiser, puis faites-le</strong>.</p>\n<p><img src=\"/public/images/articles/2021-01-29-ecrivez-du-code-stupide/GoldenCircle.png\" alt=\"Why, how and what\" /></p>\n<p>Bien sûr Sinek parle d'un principe général, mais dans notre cas ça marche aussi\npour des cas précis.</p>\n<h3>Pourquoi</h3>\n<p>Savoir le <strong>pourquoi</strong>, c'est ce qui nous fait comprendre dès le départ quelle\n<strong>valeur</strong> on est censé amener. Le <strong>pourquoi</strong> c'est notre ligne directrice, ce\nqu'on vise. Quand on sait le <strong>pourquoi</strong>, même si on se retrouve bloqué dans la\ntechnique, ça nous donne l'opportunité de trouver et de proposer des\nalternatives qui offrent une valeur équivalente.</p>\n<h3>Comment</h3>\n<p>Une fois qu'on sait <strong>pourquoi</strong> on va faire quelque chose, on peut se\nconcentrer sur le <strong>comment</strong>. <strong>Comment</strong> est-ce qu'on rend ça réel ?\n<strong>Comment</strong> ça va marcher ? <strong>Comment</strong> notre fonctionnalité, notre idée ou\nnotre fix va s'intégrer dans le projet ? <strong>Comment</strong> la solution un s'évalue\nface à la solution deux ?</p>\n<h3>Quoi</h3>\n<p>Une fois qu'on a planifié le <strong>comment</strong>, le <strong>quoi</strong> est la partie la moins\nintéressante. C'est un boulot de traduction. On écrit dans un langage ce qu'on a\nexprimé dans un autre.</p>\n<p>Faire les choses dans cet ordre a de multiples avantages pour l'organisation et\nles gens qui la composent :</p>\n<ul>\n<li>les gens connaissent la valeur qu'ils vont apporter dès le départ</li>\n<li>avec l'objectif en vue, les gens ont en général de meilleures idées</li>\n<li>les &quot;mauvaises&quot; idées sont éliminées tôt dans le processus</li>\n</ul>\n<h2>Notre boulot n'est pas une question de code</h2>\n<p>Ce que je considère comme étant un·e bon·ne développeur·se, c'est pas quelqu'un\nqui va écrire le one-liner le plus efficace, mais quelqu'un qui est doué·e pour\naller du <strong>pourquoi</strong> au <strong>comment</strong>, et arrive simplement à faire le <strong>quoi</strong>.</p>\n<p>Pour arriver là, je pense qu'à un certain point, on doit tous et toutes arrêter\nd'avoir quoi que ce soit à faire du &quot;beau code&quot;. Dans ce sens, les outils de\nnormalisation comme <a href=\"https://prettier.io\">Prettier</a> sont à mon avis une des plus\ngrosses avancées qu'on ait faites dans les années récentes, parce qu'ils nous\nont permis de concentrer notre énergie ailleurs que sur les effets de bord sans\nintérêt du <strong>quoi</strong>.</p>\n<p>Notre boulot, c'est de transformer une <strong>vision</strong> en <strong>réalité</strong>.</p>\n<p>Le code n'est pas une fin en soi. C'est pour ça que je crois fermement au <strong>code\nstupide</strong>.</p>\n<h2>C'est quoi du &quot;code stupide&quot;?</h2>\n<p>Ce que j'appelle <strong>code stupide</strong>, c'est du code qui est:</p>\n<ul>\n<li><strong>facile à lire</strong>: pour que vos collègues (ou votre futur vous) puissent\ncomprendre facilement</li>\n<li><strong>explicite</strong>: c'est pas grave si votre nom de variable ou de fonction fait 30\nbornes de long. Ne mettez pas dans un commentaire ce que vous pouvez mettre\ndans un nom.</li>\n<li><strong>honnête</strong>: n'essayez <strong>pas</strong> de cacher la complexité métier pour en faire\nune fausse simplicité. La seule chose que vous accomplirez c'est faire en\nsorte que les gens doivent aller dans pleins d'endroits dans le code pour\ncomprendre les idées.</li>\n<li><strong>supprimable</strong>: pour ne pas arriver dans la situation où personne n'ose\ntoucher à un bout de code, ne sachant pas si ça va casser quelque chose</li>\n</ul>\n<p>Pour prendre un exemple trivial, dans la codebase React de ma boite, on fait du\n<strong>prop-drilling</strong>, ce qui veut dire qu'on passe toute la donnée depuis le\ncomposant à la racine à ses descendants via les props. Fut un temps je trouvais\nça affreux. Aujourd'hui, certains se battraient encore contre ça, parce que ça\nn'a pas <strong>l'air propre</strong>, qu'on ferait mieux d'utiliser un <strong>data store\nséparé</strong>.</p>\n<p>Bien sûr. C'est stupide.</p>\n<p>C'est la manière la plus stupide de passer de la donnée d'un composant à ses\ndescendants. <strong>C'est aussi le plus simple</strong>. N'importe qui ayant bossé sur une\ncodebase React sait comment passer une prop à un composant. N'importe qui lisant\nla source d'un composant sait <strong>exactement</strong> de quelles données il a besoin en\nquelques secondes. Si on utilisait un data store, cette personne devrait\nprobablement naviguer entre 3 ou 4 fichiers juste pour comprendre ce qui se\npasse.</p>\n<p>Quand vous écrivez du <strong>code intelligent</strong>, la personne que vous avez le plus de\nchances de balader, c'est le vous du futur, quand vous allez revenir sur votre\nbout de code <em>super malin</em> dont vous vous souviendrez pas et sur lequel vous\nallez passer plusieurs heures à essayer de le piger.</p>\n<p>Que votre bout de code soit intelligent ou stupide, ça ne change rien pour\nl'utilisateur final. Ce n'est que du code source. Si un bout de code stupide\nvous permet d'ajouter de une valeur plus rapidement à votre produit, pourquoi\nperdre du temps ? Si le bout de code stupide est facilement compréhensible,\npourquoi l'obfusquer en essayant de le rendre plus malin qu'il n'a besoin de\nl'être ?</p>\n<p><img src=\"/public/images/articles/2021-01-29-ecrivez-du-code-stupide/EffortValue.png\" alt=\"Effort on value\" /></p>\n<p><strong>Le code stupide réduit mécaniquement l'effort</strong> immédiat et futur, rendant\nla valeur que vous apportez plus accessible.</p>\n<p>Si on était des machines à écrire du code, on apporterait pas une immense\nvaleur.</p>\n<p>On est doué·e·s quand on prend un peu de recul et qu'on a une vue d'ensemble.</p>\n<div style=\"font-size: 32px; text-align: center;\">\n  <strong>Faites des plans intelligents.</strong><br>\n  <strong>Écrivez du code stupide.</strong>\n</div>\n<p><em>→ Cet article est également disponible\n<a href=\"https://bloodyowl.io/blog/2021-01-09-write-dumb-code/\">en anglais</a> sur mon\nblog</em></p>\n"}