{"slug":"pourquoi-j-ai-arrete-d-utiliser-css","filename":"2016-06-16-pourquoi-j-ai-arrete-d-utiliser-css","title":"Pourquoi j'ai arrêté d'utiliser CSS","date":"Thu, 16 Jun 2016 00:00:00 GMT","draft":false,"meta":{"date":"2016-06-16T00:00:00.000Z","title":"Pourquoi j'ai arrêté d'utiliser CSS","author":"bloodyowl","oldSlug":"css/stop-css","slug":"pourquoi-j-ai-arrete-d-utiliser-css"},"body":"<p>CSS est un langage horriblement dangereux, parce qu'il mêle des concepts\ncomplètement pétés et une folle capacité à faire confondre facilité et\nsimplicité aux gens qui l'utilisent.</p>\n<h2>Qu'est-ce qui ne va pas ?</h2>\n<p>À l'origine, CSS a été conçu pour styler des documents, pas des applications. Du\ncoup lorsqu'on doit <em>scale</em>, c'est rapidement douloureux.</p>\n<h3>Les sélecteurs</h3>\n<p>Les sélecteurs sont des <strong>variables globales mutables</strong>. Lorsque vous faites :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.selector</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n}\n</code></pre>\n<p>C'est comme si en JavaScript vous faisiez :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.selector = (<span class=\"hljs-built_in\">window</span>.selector || []).concat({\n  <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">&quot;1rem&quot;</span>,\n});\n</code></pre>\n<p>Ça veut dire que :</p>\n<ul>\n<li>La définition d'un style associé à un sélecteur peut être redéfinie ailleurs</li>\n<li>Si on associe plusieurs styles à un sélecteur, les derniers définis dans le\nCSS auront toujours la priorité</li>\n<li>Quelqu'un peut péter les styles d'un composant pour peu qu'il ne sache pas\nqu'un sélecteur est utilisé ailleurs</li>\n</ul>\n<h3>La spécificité</h3>\n<p>Alors ça, c'est particulièrement drôle : la spécificité d'un sélecteur va\ndéfinir la priorité d'application d'un style.</p>\n<table>\n<thead>\n<tr><th>Sélecteur</th><th>Spécificité</th></tr>\n</thead>\n<tbody>\n<tr><td><code>*</code></td><td>0,0,0,0</td></tr>\n<tr><td><code>li</code></td><td>0,0,0,1</td></tr>\n<tr><td><code>li:first-line</code></td><td>0,0,0,2</td></tr>\n<tr><td><code>ul li</code></td><td>0,0,0,2</td></tr>\n<tr><td><code>ul ol+li</code></td><td>0,0,0,3</td></tr>\n<tr><td><code>h1 + *[rel=up]</code></td><td>0,0,1,1</td></tr>\n<tr><td><code>ul ol li.red</code></td><td>0,0,1,3</td></tr>\n<tr><td><code>li.red.level</code></td><td>0,0,2,1</td></tr>\n<tr><td><code>#x34y</code></td><td>0,1,0,0</td></tr>\n</tbody>\n</table>\n<p>Si le style est défini dans l'attribut <code>style</code>, la spécificité est de 1,0,0,0.\nSi une valeur associée à une propriété est suffixée d'un <code>!important</code>, elle\nprend quoi qu'il arrive l'ascendance.</p>\n<p>Si on résume, on nage en plein délire, la priorité se définit dans l'ordre par :\nla présence de <code>!important</code>, la façon de définir le style, la spécificité du\nsélecteur utilisé puis par l'ordre de définition dans l'ensemble des CSS de la\npage. Évidemment, à l'époque où on n'avait qu'une pauvre petite feuille de style\npour l'ensemble de son site, ça marchait ; plus maintenant.</p>\n<h3>Les régressions</h3>\n<p>Prenons un exemple tout bête :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.item</span> {\n  <span class=\"hljs-attribute\">display</span>: block;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n\n<span class=\"hljs-selector-class\">.some-context</span> <span class=\"hljs-selector-class\">.item</span> {\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n</code></pre>\n<p>Quelqu'un de la team modifie <code>.item</code> :</p>\n<pre><code class=\"hljs language-diff\"> .item {\n   display: block;\n   font-size: 1rem;\n   color: blue;\n<span class=\"hljs-addition\">+  border: 1px solid red;</span>\n }\n\n .some-context .item {\n   display: inline-block;\n   color: red;\n}\n</code></pre>\n<p>Super, une regression dans <code>some-context</code>. Face à ça, deux possibilités :</p>\n<ul>\n<li>Vous vous foutez d'avoir des régressions qui pètent votre site</li>\n<li>À chaque changement minime du CSS vous vérifiez l'intégralité du site et\ntestez tous les comportements dans tous les contextes.</li>\n</ul>\n<h3>Le choix de priorisation des styles</h3>\n<p>Ce serait pas mal de décider quel <code>className</code> est appliqué en priorité :</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;blue red&quot;</span>&gt;</span>text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;red blue&quot;</span>&gt;</span>text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>mais bien évidemment non, comme vu plus haut, c'est le foutu ordre de définition\ndes sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les\nfeuilles de style à la demande, selon les actions utilisateur.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.blue</span> {\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n<span class=\"hljs-selector-class\">.red</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n</code></pre>\n<p>C'est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous\nfaites un :</p>\n<pre><code class=\"hljs language-css\">.blue {\n  color: blue;\n}\n\n.red {\n  color: red;\n}\n\n.my-selector {\n  @extend .red;\n  @extend .blue;\n}\n</code></pre>\n<p>Vous imaginez que <code>.blue</code> étant appliqué après dans <code>.my-selector</code>, il va\nprendre la priorité. EH BAH NON, c'est <code>.red</code>, parce que sa déclaration est\nsituée après <code>.blue</code>.</p>\n<p>Si ce constat peut aussi permettre à ceux et celles qui utilisent des CSS\natomiques d'arrêter immédiatement :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.relative</span> {\n  <span class=\"hljs-attribute\">position</span>: relative;\n}\n<span class=\"hljs-selector-class\">.absolute</span> {\n  <span class=\"hljs-attribute\">position</span>: absolute;\n}\n<span class=\"hljs-selector-class\">.static</span> {\n  <span class=\"hljs-attribute\">position</span>: static;\n}\n</code></pre>\n<p>Dans le cas précédent, si vous ajoutez une classe <code>relative</code> à un élement ayant\ndéjà la classe <code>static</code>, ça ne changera rien du tout, parce que <code>.static</code> est\ndéfini après <code>.relative</code>. Génial, non ?</p>\n<h3>Le futur de CSS</h3>\n<p>Les variables sont une feature qui a été très demandée à CSS. Mais cette feature\nva débarquer avec son lot de souci :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:root</span> {\n  <span class=\"hljs-attribute\">--mainColor</span>: blue;\n}\n\n<span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--mainColor);\n}\n</code></pre>\n<p>C'est super, mais si quelqu'un vient ajouter :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:root</span> {\n  <span class=\"hljs-attribute\">--mainColor</span>: red;\n}\n</code></pre>\n<p>quelque part, il y a deux cas :</p>\n<ul>\n<li>soit c'est chargé avant, et ça ne fait rien</li>\n<li>soit c'est chargé après, et ça override toutes les propriétés utilisant\n<code>--mainColor</code>. On est bien contents.</li>\n</ul>\n<h2>Vous ne pouvez pas vous permettre de laisser tomber CSS ?</h2>\n<p>Dans ce cas, forcez vous à utiliser la\n<a href=\"/fr/articles/css/bem/\">méthodologie BEM</a>. Ça ne réglera pas tout, mais au moins\ncela vous permettra d'éviter un maximum de conneries en vous forçant à découper\nen composants isolés, et à mieux maîtriser la priorisation, puisque le scope\nauquel vous devrez y veiller sera considérablement réduit :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* Header.css */</span>\n<span class=\"hljs-selector-class\">.Header</span> {\n}\n\n<span class=\"hljs-selector-class\">.Header-nav</span> {\n}\n\n<span class=\"hljs-comment\">/* Nav.css */</span>\n<span class=\"hljs-selector-class\">.Nav</span> {\n}\n\n<span class=\"hljs-selector-class\">.Nav-item</span> {\n}\n\n<span class=\"hljs-selector-class\">.Nav-item--active</span> {\n}\n</code></pre>\n<p>C'est quand même plus pratique à comprendre, non ?</p>\n<p>Encore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les\n<a href=\"/fr/articles/css/modules/\">CSS modules</a>, qui limiteront de même le scope\nd'application de vos feuilles de style.</p>\n<h2>Vous pouvez vous permettre de laisser tomber CSS ?</h2>\n<p>JavaScript vous permet déjà de bénéficier d'un système de modules, de variables,\nde conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça,\nvous maitrisez la priorisation, parce c'est que c'est vous qui décidez ce qui\ns'applique :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> { active, disabled } = <span class=\"hljs-built_in\">this</span>.props;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n          <span class=\"hljs-attr\">...styles.myComponent</span>,\n          <span class=\"hljs-attr\">...</span>(<span class=\"hljs-attr\">active</span> ? <span class=\"hljs-attr\">styles.active</span> <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>),\n          <span class=\"hljs-attr\">...</span>(<span class=\"hljs-attr\">disabled</span> &amp;&amp; !<span class=\"hljs-attr\">active</span> ? <span class=\"hljs-attr\">styles.disabled</span> <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>),\n        }}\n      &gt;</span>\n        tadaa\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> styles = {\n  <span class=\"hljs-attr\">myComponent</span>: {\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">18</span>,\n  },\n  <span class=\"hljs-attr\">active</span>: {\n    <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n  },\n  <span class=\"hljs-attr\">disabled</span>: {\n    <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.5</span>,\n  },\n};\n</code></pre>\n<p>Par ailleurs, avec certaines bibliothèques permettant naturellement l'usage\nd'inline-styles (comme React), cela vous donne la possibilité d'avoir le style\net le markup dans le même fichier, sans avoir besoin de naviguer entre les\nonglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si\nça vous fait plaisir).</p>\n<p>En résumé, utiliser JS pour définir et appliquer les styles vous permet de\nprendre le contrôle sur le styling de vos composants, tout en apportant le\nconfort d'un langage offrant naturellement de nombreux avantages. Si vous êtes\nbloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos\npossibilités. Le but, c'est d'éliminer les\n<a href=\"https://github.com/necolas/react-native-web/blob/master/website/guides/style.md\">7 maux de CSS</a>.</p>\n<p>Bisous bisous.</p>\n<h2>Edit</h2>\n<p>Afin de répondre aux diverses incompréhensions et commentaires en réponse à\nl’article, voilà un follow-up qui va tenter d’aller plus en profondeur dans la\ncritique de CSS.</p>\n<p>Je vais donc répondre à\n<a href=\"http://www.glazman.org/weblog/dotclear/index.php?post/2016/06/18/Pourquoi-il-n-aurait-pas-du-arrêter-d-utiliser-CSS\">l’article de Daniel Glazman</a>,\nancien co-chairman du CSS Working Group.</p>\n<p>Le premier point n’a rien à voir avec le sujet, mais l’auteur fait un parallèle\nentre la réassignation dans JS et la mutabilité et absence de scope des\nsélecteurs CSS. La comparaison n’a pas lieu d’être, parce que JS est un langage\nde programmation. De plus, en JS, les variables ont une portée, et l’opérateur\n<code>const</code> existe pour prévenir la réassignation. <code>&lt;/digression&gt;</code></p>\n<p>Le grand problème de l’état actuel des sélecteurs CSS, c’est qu’ils n’offrent\nnaturellement aucune API (hors <em>Shadow DOM</em>) permettant de limiter le scope d’un\nsélecteur sans augmenter sa spécificité. Si je veux ajouter des propriétés de\nstyle à un élément comportant un certain sélecteur dans un certain contexte, je\nsuis obligé d’avoir connaissance de tous les sélecteurs correspondant\npotentiellement à cet éléments, de vérifier leur spécificité, et possiblement\nd’adapter le sélecteur simple que j’envisageais à l’origine pour pallier le\nmanque de spécificité. Super, ma codebase contient maintenant des sélecteurs\ndifférents de leur sens original dans le simple but de les appliquer.</p>\n<p>Lorsque je lis la réaction épidermique de l’auteur face à BEM, une méthodologie\najoutant un namespace pour simuler ce scope côté utilisateur qui apporte un\nminimum de sécurité lorsque l’on travaille sur un projet à grande échelle,\nj’avoue un peu flipper quant à la conception des spécifications CSS.</p>\n<p>BEM est une réponse de la communauté d’utilisateurs à plusieurs soucis qu’ils\nont rencontrés dans leurs utilisations variées de CSS. On dirait même dans sa\nréponse qu’il n’a pas pris le temps de se renseigner sur la nature de la\nméthodologie, qui ne consiste selon lui qu’à ajouter des indentations dont on se\nfout parce que CSSOM les ignore. WTF.</p>\n<p>Ignorer le feedback que constitue l’apparition de cette méthodologie et dénigrer\nles utilisateurs pour qui elle règle des problèmes posés par le laxisme du\nlangage, ça ne fait pas avancer le langage, et ça ne donnera certainement pas\nenvie de retourner à CSS.</p>\n<p>Concernant la spécificité des sélecteurs, évidemment qu’une quantité\nastronomique de sites utilise les sélecteurs CSS, simplement parce qu’ils n’ont\npas eu d’alternative viable. Ça n’en fait pas une fonctionnalité bien conçue\npour autant.</p>\n<p>Sur les régressions, l’idée à comprendre, c’est que l’absence de scope et de\nnamespace dans le langage peut créer des régressions potentiellement partout\ndans un large site, parce qu’un sélecteur est global. Il n’y a pas moyen de\nsécuriser un rayon d’action pour travailler, à moins de gérer le namespace\nsoi-même, dans le sélecteur.</p>\n<p>Concernant le choix de priorisation des styles, c'est un fait que l'ordre de la\n<code>DOMTokenList</code> n’a pas d'importance actuellement, et je ne fais que déplorer\nqu’en utilisant des sélecteurs, le choix de l’application des styles ne puisse\npas se faire à l’endroit où l’élément est utilisé, avec la connaissance précise\nde son contexte.</p>\n<p>Sur le futur de CSS, le reproche que je dresse n'est pas comme ce qui est\ninterprété dans le post de l'auteur, disant que je râle parce que si l'on fait\nun parallèle avec JS, on aurait :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\nalert(a);\n<span class=\"hljs-comment\">// alerts 2</span>\n</code></pre>\n<p>C’est un comportement parfaitement attendu. Et ce n’est pas ce que j’ai dit, je\nreproche à CSS de faire en sorte que, si l’on fait encore le parallèle :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// coucou c&#x27;est CSS</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\nalert(a);\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-comment\">// alerts 2</span>\n</code></pre>\n<p>Sur ma proposition alternative, outre être <em>“une horreur non-maintenable,\nverbeuse et error-prone”</em>, on va regarder ce que ça donne sur un cas plus simple\n:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-comment\">// un système de modules analysable statiquement</span>\n<span class=\"hljs-keyword\">import</span> { mainBlue, mainRed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../utils/Colors&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> props =&gt; {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-comment\">// on peut appliquer un style dont le rayon d&#x27;action est par définition</span>\n    <span class=\"hljs-comment\">// limité à l’élément sur lequel on le place</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.container}</span>&gt;</span>\n      {list.map((item, index) =&gt; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.item}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>\n            <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n              <span class=\"hljs-attr\">...styles.text</span>,\n              // <span class=\"hljs-attr\">appliquer</span> <span class=\"hljs-attr\">un</span> <span class=\"hljs-attr\">style</span> <span class=\"hljs-attr\">conditionn</span>é <span class=\"hljs-attr\">par</span> <span class=\"hljs-attr\">le</span> <span class=\"hljs-attr\">contexte</span> <span class=\"hljs-attr\">est</span> <span class=\"hljs-attr\">tr</span>è<span class=\"hljs-attr\">s</span> <span class=\"hljs-attr\">simple</span>\n              // <span class=\"hljs-attr\">et</span> <span class=\"hljs-attr\">permet</span> <span class=\"hljs-attr\">de</span> <span class=\"hljs-attr\">prioriser</span> à <span class=\"hljs-attr\">la</span> <span class=\"hljs-attr\">d</span>é<span class=\"hljs-attr\">finition</span> <span class=\"hljs-attr\">du</span> <span class=\"hljs-attr\">markup</span>\n              <span class=\"hljs-attr\">...</span>(<span class=\"hljs-attr\">index</span> % <span class=\"hljs-attr\">2</span> === <span class=\"hljs-string\">0</span> &amp;&amp; <span class=\"hljs-attr\">styles.oddText</span>),\n            }}\n          &gt;</span>\n            {item.text}\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      ))}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-comment\">// la feuille de style est limitée au module</span>\n<span class=\"hljs-keyword\">const</span> styles = {\n  <span class=\"hljs-attr\">container</span>: {\n    <span class=\"hljs-attr\">display</span>: <span class=\"hljs-string\">&quot;flex&quot;</span>,\n    <span class=\"hljs-attr\">flexDirection</span>: <span class=\"hljs-string\">&quot;row&quot;</span>,\n  },\n  <span class=\"hljs-attr\">item</span>: {\n    <span class=\"hljs-attr\">flexBasis</span>: <span class=\"hljs-number\">200</span>,\n  },\n  <span class=\"hljs-attr\">text</span>: {\n    <span class=\"hljs-comment\">// peut utiliser des variables qui ne seront pas écrasées si j&#x27;en définis</span>\n    <span class=\"hljs-comment\">// une avec le même nom ailleurs dans l&#x27;app</span>\n    <span class=\"hljs-attr\">color</span>: mainBlue,\n  },\n  <span class=\"hljs-attr\">oddText</span>: {\n    <span class=\"hljs-attr\">color</span>: mainRed,\n  },\n};\n</code></pre>\n<p>C’est juste une application d’une approche centrée sur les composants.\nL’important, c’est d’isoler ces composants pour les rendre facilement\nréutilisables, prévenir les effets de bord, et passer moins de temps à essayer\nde travailler avec des propriétés du langage qui nous gênent dans notre travail\nde tous les jours. Réduire la liberté d’utilisation permet ici d’apporter des\npropriétés (immutabilité des styles, application déterministe des styles, scope)\nqui nous permettent de raisonner notre code de manière beaucoup plus simple.</p>\n<p>Si l’on regarde du côté des CSS modules, qu’est-ce que ça fait exactement ? La\nmême chose. Le tooling va limiter le scope d’une feuille de style en rendant\nopaques et globalement uniques les sélecteurs. Le CSS peut être utilisé en\ntarget de compilation sans problème, et la plupart des solutions rendant son\nutilisation confortable font une chose simple : contraindre à une utilisation\nplus stricte en masquant des parties trop laxistes du langage. C’est ce que le\ntooling JS a connu depuis quelques années, et on ne s’en porte que mieux.</p>\n<p>Le dernier argument utilisé est que « si le monde entier a adopté CSS (y compris\nle monde de l'édition qui vient pourtant de solutions assez radicalement\ndifférentes du Web), c'est bien parce que c'est bien et que ça marche ».\nQu’est-ce qu’on peut répondre sinon que CSS a été adopté avant que les besoins\ndu web n'aient suffisamment évolué pour que CSS dans son état actuel ait un\nénorme potentiel de fragilisation d’une codebase. Ne pas remettre en question le\nlangage parce que ses utilisateurs n’ont pas d’alternative, c’est condamner le\nlangage. C’est comme si la SNCF disait « BOARF ça sert à rien de faire arriver\nles trains à l’heure, vu que tout le monde le prend déjà c’est que c’est nickel\n». Du coup, faut pas venir s’étonner que certains de ces utilisateurs aillent\nchercher des alternatives ailleurs.</p>\n<p>En conclusion, je déplore vraiment l'absence d'intérêt apparent de l'auteur pour\nécouter le feedback des utilisateurs sur les problèmes d'un langage. Il faut\nregarder ailleurs, et ne pas ignorer ou mépriser ce que les utilisateurs font de\nleur côté pour travailler plus sainement, ça pourrait même donner des idées pour\naméliorer ce qui fait perdre du temps aux utilisateurs.</p>\n"}