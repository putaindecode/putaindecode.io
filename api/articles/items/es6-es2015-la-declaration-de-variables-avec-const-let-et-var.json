{"slug":"es6-es2015-la-declaration-de-variables-avec-const-let-et-var","filename":"2015-12-01-es6-es2015-la-declaration-de-variables-avec-const-let-et-var","title":"ES6, ES2015 : la déclaration de variables avec const, let et var","date":"Tue, 01 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-01T00:00:00.000Z","title":"ES6, ES2015 : la déclaration de variables avec const, let et var","author":"Nyalab","oldSlug":"js/es2015/const-let-var","slug":"es6-es2015-la-declaration-de-variables-avec-const-let-et-var"},"body":"<p>ES6 (aussi appelé ES2015) vous apporte de nouvelles façons de déclarer vos\nvariables grâce à <code>let</code> et <code>const</code> mais garde aussi la déclaration par <code>var</code>\ndans la spécification du langage.</p>\n<p>Première étape, on oublie tout ce qu'on sait sur <code>var</code>.</p>\n<h1>Déclarations</h1>\n<h2>const</h2>\n<p><code>const</code> vous permet de déclarer une variable à assignation unique bindée\nlexicalement. Bon, ça fait un peu pompeux, alors pour les devs au fond de la\nsalle à côté du radiateur, ça veut simplement dire que vous pouvez déclarer une\nvariable qui ne contiendra qu'une valeur et qui sera scopée au niveau du bloc.</p>\n<dl>\n<dt>Si vous avez déjà lu des posts ou des ressources parlant de <code>const</code>, méfiez-vous</dt>\n<dd>ce ne sont pas des vraies constantes au sens <em>valeur</em> de variable. Ce sont des\nconstantes au niveau référence. C'est à dire que le contenu d'un tableau ou d'un\nobjet déclaré avec <code>const</code> bloque la réassignation de la variable, mais ne rend\npas la valeur immuable.\n</dd>\n</dl>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">&quot;bar&quot;</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">const</span> foo <span class=\"hljs-comment\">// SyntaxError, la variable a besoin d&#x27;être assignée</span>\n    <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">&quot;qux&quot;</span>\n    foo = <span class=\"hljs-string\">&quot;norf&quot;</span> <span class=\"hljs-comment\">// SyntaxError, la variable ne peut pas être réassignée</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo)\n    <span class=\"hljs-comment\">// &quot;qux&quot;, la variable appartient au scope de son bloc (le &quot;if&quot;)</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// &quot;bar&quot;, la variable appartient au scope de la fonction &quot;fn&quot;</span>\n}\n</code></pre>\n<p>Le fonctionnement <code>const</code> peut être utilisé de manière cool dans le cas\nd'itérables :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> el <span class=\"hljs-keyword\">of</span> arr) {\n    <span class=\"hljs-built_in\">console</span>.log(el);\n  }\n}\n</code></pre>\n<p>En effet, on pourrait croire qu'un <code>let</code> doit être utilisé ici, mais la\ndéclaration est évaluée à chaque passage de l'itérateur, <code>const</code> est donc un\nmeilleur choix !</p>\n<h2>let</h2>\n<p><code>let</code> vous permet de faire pareil que <code>const</code> mais sans la contrainte\nd'assignation unique. Vous devriez donc instinctivement voir que les cas\nd'utilisation pour <code>let</code> sont les mêmes que ceux de <code>var</code>, son ancêtre.\nD'ailleurs, vous entendrez souvent : <code>let</code> est le nouveau <code>var</code> (<em><code>let</code> is the\nnew <code>var</code></em>). C'est en partie vrai car il est capable de faire les mêmes choses,\nmais en mieux, car il a cette caractéristique d'être scopé au bloc courant.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&quot;bar&quot;</span>;\n  <span class=\"hljs-keyword\">var</span> foo2 = <span class=\"hljs-string\">&quot;bar&quot;</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">let</span> foo; <span class=\"hljs-comment\">// pas d&#x27;erreur, foo === undefined</span>\n    <span class=\"hljs-keyword\">var</span> foo2;\n    <span class=\"hljs-comment\">// Attention, les déclarations &quot;var&quot; ne sont pas scopées au niveau bloc</span>\n    <span class=\"hljs-comment\">// foo2 est en réalité écrasé !</span>\n    foo = <span class=\"hljs-string\">&quot;qux&quot;</span>;\n    foo2 = <span class=\"hljs-string\">&quot;qux&quot;</span>;\n    <span class=\"hljs-built_in\">console</span>.log(foo);\n    <span class=\"hljs-comment\">// &quot;qux&quot;, la variable appartient au scope de son blocs (le &quot;if&quot;)</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo2);\n    <span class=\"hljs-comment\">// &quot;qux&quot;</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(foo);\n  <span class=\"hljs-comment\">// &quot;bar&quot;, la variable appartient au scope de son bloc (la fonction &quot;fn&quot;)</span>\n  <span class=\"hljs-built_in\">console</span>.log(foo2);\n  <span class=\"hljs-comment\">// &quot;qux&quot;</span>\n}\n</code></pre>\n<p>Vous pouvez par exemple utiliser <code>let</code> pour vos boucles, la variable servant à\nl'itération est désormais scopée au niveau de cette boucle et n'entrera pas en\nconflit avec votre code autour. Plus de problème de <code>i</code> déjà pris !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = i; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n    <span class=\"hljs-built_in\">console</span>.log(i);\n  }\n  <span class=\"hljs-built_in\">console</span>.log(i);\n  <span class=\"hljs-comment\">// 0</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = i; j &lt; <span class=\"hljs-number\">10</span>; j++) {}\n  <span class=\"hljs-built_in\">console</span>.log(j);\n  <span class=\"hljs-comment\">// j is not defined</span>\n}\nfn2(); <span class=\"hljs-comment\">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span>\n</code></pre>\n<p>Note : l'exemple avec <code>const</code> dans une boucle <code>for ... of</code> ne peut être\nreproduit ici. En effet, la boucle <code>for</code> classique est impérative, et la\ndéclaration n'est effectuée qu'une seule fois au début de la boucle. Un <code>const</code>\nn'est donc pas utilisable.</p>\n<h2>var</h2>\n<p>On a vu <code>const</code>, on a vu <code>let</code>. Avec ces deux nouveaux outils, il ne reste pas\nde grande place pour <code>var</code>. À mon avis, le seul cas d'utilisation valable pour\n<code>var</code> est lors de l'utilisation de <code>try</code>/<code>catch</code>, et ce n'est pas dans le cadre\nd'un bug, mais juste de syntaxe et de préférence\n(<a href=\"https://twitter.com/getify/status/658662478528643072\">exemple</a>).</p>\n<h1>Piège du hoisting et de la TDZ (<em>Temporal Dead Zone</em>)</h1>\n<p>Pour rappel, JavaScript possède un mécanisme de hoisting, par exemple, vous\npouvez écrire :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo); <span class=\"hljs-comment\">// undefined (au lieu de ReferenceError)</span>\n  <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">&quot;bar&quot;</span>;\n}\n</code></pre>\n<p>Concrètement, le moteur d'exécution JavaScript va lire toutes les déclarations\net remonter celles avec <code>var</code> au début du scope de votre fonction (attention,\ncela concerne les déclarations, pas les affectations).</p>\n<p><code>let</code> et <code>const</code> ne bénéficient pas de ce mécanisme de hoisting, ce qui peut\nmener à des problèmes de TDZ (<em>Temporal Dead Zone</em>). Vu que la déclaration de\nvotre variable n'est pas remontée au scope de la fonction, il existe un moment\noù votre variable n'existe pas. Ce moment, c'est la TDZ.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo);\n  <span class=\"hljs-comment\">// ReferenceError, on est dans la TDZ pour la variable foo</span>\n  <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">&quot;bar&quot;</span>;\n}\n</code></pre>\n<h1>Outro</h1>\n<p>Comment choisir quelle déclaration de variable utiliser ? C'est très simple :</p>\n<ul>\n<li>Utilisez une déclaration par <code>const</code> (99% du temps, c'est le bon choix)</li>\n<li>Si au fil de votre code vous changez sa valeur, modifiez pour un <code>let</code> (1%)</li>\n<li>Si vous avez trouvé le pire cas d'utilisation du monde, changez pour un <code>var</code>\n(je vous laisse faire le calcul)</li>\n</ul>\n"}