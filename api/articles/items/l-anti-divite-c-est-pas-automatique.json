{"slug":"l-anti-divite-c-est-pas-automatique","filename":"2018-10-09-l-anti-divite-c-est-pas-automatique","title":"L'anti-divite, c'est pas automatique","date":"Tue, 09 Oct 2018 00:00:00 GMT","draft":false,"meta":{"date":"2018-10-09T00:00:00.000Z","title":"L'anti-divite, c'est pas automatique","author":"bloodyowl","oldSlug":"html/anti-divite-pas-automatique","slug":"l-anti-divite-c-est-pas-automatique"},"body":"<p>Dans la spécification HTML, l'élément <code>&lt;div /&gt;</code> est décrit comme\n<a href=\"https://html.spec.whatwg.org/multipage/grouping-content.html#the-div-element\">n'ayant aucun sens particulier</a>.\nC'est un élément extrêmement générique, à tel point qu'on pourrait le nommer\n<code>&lt;view /&gt;</code> :</p>\n<ul>\n<li>son style par défaut est extrêmement léger (<code>display: block</code>, c'est tout) et\nfacile à reset ;</li>\n<li>il accepte à peu près tout élément comme enfant.</li>\n</ul>\n<p>Présenté comme ça, <code>&lt;div /&gt;</code> semble être la brique de base parfaite pour créer un\nsystème de composants. Si on utilise principalement cet élément, on pourra\nimbriquer tous nos composants comme on le souhaite sans être contraint par le\ncontexte.</p>\n<p>Pourtant, voilà une bonne dizaine d'années qu'on entend parler de\n<a href=\"https://fr.wiktionary.org/wiki/divite\">divite</a>, ou &quot;fait d'utiliser trop de\ndiv&quot;. Parmi les deux citations sur le Wiktionnaire :</p>\n<blockquote>\n<p>En premier lieu, il faut donc surtout éviter le syndrome de la « divite »,\nc’est-à-dire de considérer <code>&lt;div&gt;</code> comme un élément bon à tout faire, et ne\nl’exploiter qu’en dernier recours lorsqu’aucun autre élément n’existe. <br />\n— (Rodolphe Rimelé , HTML 5 : Une référence pour le développeur web, 2011)</p>\n</blockquote>\n<blockquote>\n<p>La &quot;divite aiguë&quot; (l’utilisation abusive de balises div) est souvent le\nsymptôme d’un code mal structuré et excessivement compliqué. <br /> — (Simon\nCollison, Cameron Moll, Andy Budd , Maitrise des CSS)</p>\n</blockquote>\n<h2>Une <code>&lt;div /&gt;</code> pour le styling</h2>\n<p>Après avoir lu ces deux citations, vous êtes peut-être en train de vous dire\n&quot;Ciel ! C'est horrible, mon application est criblée de <code>&lt;div&gt;</code> est-ce que\nc'est grave ? Dois-je à tout prix arrêter d'utiliser des <code>&lt;div&gt;</code> ?&quot;</p>\n<p>Si vous utilisez des <code>&lt;div /&gt;</code> pour du styling, vous pouvez continuer à le\nfaire parce que c'est exactement ce qu'on veut : qu'un élément qui est juste\nlà pour appliquer des styles n'ait pas d'importance sémantique.</p>\n<p>Un certain courant de l'intégration préconise d'utiliser CSS avec toutes sortes\nd'astuces pour éviter à tout prix d'avoir des <code>&lt;div&gt;</code> (ou plus généralement des\néléments) pour le styling.</p>\n<p>Plus jeune, j'avais tendance à suivre cette approche et me suis heurté à une\nproblématique de taille par la suite:</p>\n<p>c'est 👏 juste 👏 pas 👏 pratique</p>\n<p>Prenons un exemple simple. J'ai la structure suivante:</p>\n<pre><code class=\"hljs language-javascript\">&lt;&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Article</span> /&gt;</span></span>\n&lt;/&gt;\n</code></pre>\n<p>L'équipe de design souhaite les séparer visuellement de <code>10px</code>. Deux approches\ns'offrent à moi.</p>\n<p><img src=\"/public/images/articles/2018-10-09-l-anti-divite-c-est-pas-automatique/component-style.png\" alt=\"marginRight ou Spacer\" /></p>\n<ol>\n<li>J'ajoute un <code>&lt;Spacer /&gt;</code> entre les deux éléments, qui sera une <code>&lt;div /&gt;</code>\navec la hauteur souhaitée pour décaler du contenu visuellement, <code>&lt;Header /&gt;</code>\net <code>&lt;Article /&gt;</code> continuent leurs vies : l'impact de ma modification est\nlocalisé, il n'y aura donc pas de régression.</li>\n<li>J'ajoute une <code>marginBottom</code> à <code>&lt;Header /&gt;</code> (ou un <code>marginTop</code> à\n<code>&lt;Article /&gt;</code>)\n<ul>\n<li>soit j'ajoute l'altération systématiquement, ce qui entrainera\npossiblement des regressions visuelles aux autres endroits où mes <code>Header</code>\nou <code>Article</code> sont utilisés ;</li>\n<li>soit j'ajoute un paramètre <code>marginTop</code> ou <code>marginBottom</code>, et ajoute de la\ncomplexité au composant ;</li>\n<li>soit je permets de passer un <code>style</code> et je devrai vérifier qu'il n'y a pas\nde conflit à chaque fois que je mettrai le composant à jour,</li>\n<li>soit je permets de passer un <code>className</code> : j'aurai la même vérification à\nfaire, en gardant en tête la spécificité des sélecteurs.</li>\n</ul></li>\n</ol>\n<p>Les vieux de la vieille de l'intégration vous diront que c'est ridicule\nmaintenant qu'il y a CSS, que c'est une\n<a href=\"https://en.wikipedia.org/wiki/Spacer_GIF\"><code>technique d'antan</code></a> pour les layouts\nen tableaux. Il y a cependant une différence primordiale: <strong>le contexte</strong>. À\nl'époque, le <code>spacer.gif</code> était un hack malin pour contourner une contrainte\ntechnique ; aujourd'hui, utiliser un <code>&lt;Spacer /&gt;</code> est un moyen de limiter la\nresponsabilité d'autres composants, de manière à les rendre plus facilement\nréutilisables.\n<a href=\"https://twitter.com/sophiebits/status/759898608913174528\">Certains points de vue</a>\nautour de ce qu'un composant devrait autoriser comme style sont particulièrement\nintéressants lorsqu'ils sont mis dans cette perspective.</p>\n<h2>Une <code>&lt;div /&gt;</code> pour les boutons</h2>\n<blockquote>\n<p>Just use a <code>&lt;button /&gt;</code>  <br />\n— Most people</p>\n</blockquote>\n<p>Utiliser un élément <code>&lt;div /&gt;</code> ou <code>&lt;a /&gt;</code> pour représenter un <code>button</code>\n(sémantiquement : une action sur la page) est très souvent mal perçu.</p>\n<p>Prenons quelques cas où nous pourrions être amenés à avoir besoin de déroger au\n<code>&lt;button /&gt;</code> :</p>\n<ul>\n<li>mon bouton doit être situé dans du contenu phrasé, je n'ai selon la\nspécification pas le droit d'y mettre un élément <code>&lt;button /&gt;</code>, je vais donc\navoir tendance à utiliser un <code>&lt;a /&gt;</code> ou un <code>&lt;span /&gt;</code> ;</li>\n<li>je veux arranger les éléments enfants du bouton avec un layout flex horizontal\nnon aligné au centre (je vous laisse profiter de\n<a href=\"https://jsfiddle.net/bloodyowl/Lfcut68p/10/\">l'exemple</a>, même avec les deux\ntrès bien nommées propriétés <code>all: unset</code> et <code>appearance: none</code>, MÊME AVEC ÇA,\nvous pouvez voir qu'all n'est pas unset et que les appearances sont trompeuses) ;</li>\n<li>j'ai une approche par composants, et je n'ai pas le temps de vérifier à chaque\nfois que j'utilise un bouton que tous ses enfants sont du contenu phrasé : j'ai\nun composant existant représenté par une <code>&lt;div /&gt;</code>, je ne vais pas m'amuser à\nrajouter un paramètre à ce composant et à tous les composants qu'il utilise\npour qu'ils rendent des <code>&lt;span /&gt;</code> plutôt que des <code>&lt;div /&gt;</code>.</li>\n</ul>\n<p>Puisque ces cas existent et sont légitimes: comment fabrique-t-on un composant\n<code>&lt;Button /&gt;</code> accessible et qui marche dans tous les cas ?</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> Button = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ onPress, onKeyUp, onClick, ...props }</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;button&quot;</span> // <span class=\"hljs-attr\">les</span> <span class=\"hljs-attr\">synth</span>è<span class=\"hljs-attr\">ses</span> <span class=\"hljs-attr\">vocales</span> <span class=\"hljs-attr\">comprennent</span> <span class=\"hljs-attr\">qu</span>&#x27;<span class=\"hljs-attr\">il</span> <span class=\"hljs-attr\">s</span>&#x27;<span class=\"hljs-attr\">agit</span> <span class=\"hljs-attr\">d</span>&#x27;<span class=\"hljs-attr\">un</span> <span class=\"hljs-attr\">bouton</span>\n    <span class=\"hljs-attr\">tabIndex</span>=<span class=\"hljs-string\">{0}</span> // <span class=\"hljs-attr\">l</span>&#x27;é<span class=\"hljs-attr\">l</span>é<span class=\"hljs-attr\">ment</span> <span class=\"hljs-attr\">est</span> <span class=\"hljs-attr\">navigable</span> <span class=\"hljs-attr\">au</span> <span class=\"hljs-attr\">clavier</span>\n    <span class=\"hljs-attr\">onKeyUp</span>=<span class=\"hljs-string\">{event</span> =&gt;</span> {\n      /* Space &amp; Enter */\n      if (event.keyCode === 32 || event.keyCode === 13) {\n        onPress();\n      }\n      if (onKeyUp) {\n        onKeyUp(event);\n      }\n    }}\n    onClick={event =&gt; {\n      onPress();\n      if (onClick) {\n        onClick(event);\n      }\n    }}\n    {...props}\n  /&gt;</span>\n);\n</code></pre>\n<blockquote>\n<p>NOTE : Vous pouvez également faire un <code>&lt;InlineButton /&gt;</code> pour les cas où vous\navez besoin qu'il s'agisse d'un contenu phrasé.</p>\n</blockquote>\n<p>Comme vous pouvez le voir : <code>&lt;button /&gt;</code> et <code>&lt;div /&gt;</code> sont radicalement\ndifférents lorsqu'ils sont lus par VoiceOver.</p>\n<p><img src=\"/public/images/articles/2018-10-09-l-anti-divite-c-est-pas-automatique/button.png\" alt=\"button hello\" /></p>\n<p><img src=\"/public/images/articles/2018-10-09-l-anti-divite-c-est-pas-automatique/div.png\" alt=\"button hello\" /></p>\n<p>Ce composant sera interprété de la même façon qu'un <code>&lt;button /&gt;</code> et vous libère\ndes contraintes de ce dernier. Énorme avantage en plus: vous n'avez à faire\nl'abstraction qu'une seule fois !</p>\n<h2>Les <code>&lt;div /&gt;</code> de décoration</h2>\n<p>On peut souvent trouver des <code>&lt;div /&gt;</code> chargées de simple décoration (des ombres\nportées déportées de l'élément où elles sont accrochées visuellement pour atteindre\n60FPS, des zigouigouis, des pétouilles…), et on se verra souvent conseillé de\nplutôt utiliser des pseudo-elements comme <code>:before</code> et <code>:after</code>.</p>\n<p>Pour commencer, je trouve ça beaucoup plus lisible d'avoir un élément pour le\ngérer :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> Card = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ children }</span>) =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;Card&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;Card-shadow&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;Card-content&quot;</span>&gt;</span>{children}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n</code></pre>\n<p>que d'avoir à aller dans la feuille de style pour aller voir mon zigouigoui qui\nporte le nom <code>:before</code> ou <code>:after</code>, ce qui ne m'aide pas des masses à visualiser\nson intérêt. Avec un élément, je peux en plus très facilement le transformer en\nun composant si j'ai besoin qu'il ait un cycle de vie ou un état local !</p>\n<p>Qui plus est, je n'ai pas forcément la possibilité technique d'utiliser CSS, je\npeux devoir utiliser des styles inline, les pseudo-éléments n'y seront pas\ndisponibles.</p>\n<h2>Une <code>&lt;div /&gt;</code> pour les champs texte ?!</h2>\n<p>Si je veux un champ texte qui grandit avec son contenu (qui apporte de nombreux\navantages pour l'utilisateur) avec des éléments sémantiques, je dois utiliser un\n<code>&lt;textarea /&gt;</code> et mesurer sa nouvelle taille supposée (soit sur l'élément lui-même,\nen définissant sa hauteur à <code>0</code> à chaque keystroke pour mesurer sa taille,\nsoit en utilisant la même technique sur un élément masqué dans le DOM possédant\nles mêmes propriétés de layout). Ces techniques de mesures sont contraignantes :\non doit garder en tête le layout, le <code>box-sizing</code> de l'élément et notre\ninterface risque d'avoir des effets visuellement désagréables comme des &quot;sauts&quot;\nde l'élément.</p>\n<p>Là encore, utiliser une <code>&lt;div contentEditable /&gt;</code> non contrôlée peut nous\nsimplifier la vie:</p>\n<pre><code class=\"hljs language-javascript\">&lt;&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">htmlFor</span>=<span class=\"hljs-string\">&quot;input&quot;</span>&gt;</span>Mon champ<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;input&quot;</span>\n    <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;textbox&quot;</span>\n    <span class=\"hljs-attr\">contentEditable</span>=<span class=\"hljs-string\">{true}</span>\n    <span class=\"hljs-attr\">onInput</span>=<span class=\"hljs-string\">{event</span> =&gt;</span> this.setState({ value: event.target.innerText })}\n  /&gt;</span>\n&lt;/&gt;\n</code></pre>\n<p>Pour implémenter un placeholder, une <code>&lt;div /&gt;</code> en position absolute fera\nl'affaire.</p>\n<p>Apprenons à aimer à nouveau la <code>&lt;div /&gt;</code>, si toutefois on prend bien soin de son\naccessibilité. Utiliser des <code>&lt;div /&gt;</code> comme briques principales, c'est rendre\ncomposable toute son application.</p>\n<p>Les éléments dits sémantiques sont souvent des boîtes noires, contenant leur\nnature sémantique, leur style et leur comportement, et si l'on veut les changer,\non doit annuler des comportement non déterminés à l'avance (c'est l'équivalent\nconceptuel de <code>preventDefault</code> : &quot;annule quelque chose, mais je ne sais pas\nquoi&quot;). Utiliser des <code>&lt;div /&gt;</code> avec des attributs <code>role</code> et <code>aria-*</code> change\ncomplètement le paradigme : notre élément sera une vue pour lequel <strong>nous</strong>\nspécifions le style, le comportement et la sémantique.</p>\n<p>C'est une façon différente de penser son application web : construire du\nspécifique avec des briques génériques plutôt que de rendre générique des\nbriques spécifiques.</p>\n<p>N'ayons plus une peur déraisonnée d'utiliser des <code>&lt;div /&gt;</code>, apprenons juste à les\nrendre sémantiques.</p>\n<p>Bisous bisous.</p>\n"}