{"slug":"es6-es2015-les-valeurs-par-defaut-des-arguments","filename":"2015-12-03-es6-es2015-les-valeurs-par-defaut-des-arguments","title":"ES6, ES2015 : les valeurs par défaut des arguments","date":"Thu, 03 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-03T00:00:00.000Z","title":"ES6, ES2015 : les valeurs par défaut des arguments","author":"naholyr","oldSlug":"js/es2015/defaults","slug":"es6-es2015-les-valeurs-par-defaut-des-arguments"},"body":"<p>Fatigués de taper <code>if (typeof x === 'undefined') x = defaultValue</code> ? Là encore\nES6 va nous apporter une solution élégante.</p>\n<h1>Valeurs par défaut</h1>\n<p>L'opérateur <code>=</code> permet maintenant en plus d'affecter une valeur à une variable\nde définir une valeur par défaut à un paramètre.</p>\n<h2>Paramètres de fonction</h2>\n<p>Il est maintenant possible de spécifier une valeur par défaut à un paramètre de\nfonction. Cette valeur sera utilisée si le paramètre n'est pas fourni, ou qu'il\nest explicitement défini à <em>undefined</em>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incr</span>(<span class=\"hljs-params\">value, step = <span class=\"hljs-number\">1</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> value + step;\n}\n\nincr(<span class=\"hljs-number\">41</span>); <span class=\"hljs-comment\">// 42</span>\nincr(<span class=\"hljs-number\">41</span>, <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// 42</span>\nincr(<span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">9</span>); <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<h3>Valeurs par défaut dynamiques</h3>\n<p>On peut spécifier une expression en tant que valeur par défaut. Cette expression\nsera évaluée <strong>à l'appel de la fonction</strong>, pas lors de sa déclaration.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> defaultWho = <span class=\"hljs-string\">&quot;world!&quot;</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hello</span>(<span class=\"hljs-params\">who = defaultWho.toUpperCase()</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello &quot;</span> + who;\n}\n\nhello(); <span class=\"hljs-comment\">// &#x27;Hello WORLD!&#x27;</span>\ndefaultWho = <span class=\"hljs-string\">&quot;Anyone?&quot;</span>;\nhello(); <span class=\"hljs-comment\">// &#x27;Hello ANYONE?&#x27;</span>\n</code></pre>\n<h3>Réutilisation des paramètres précédents</h3>\n<p>Dans l'expression d'une valeur par défaut, on peut réutiliser les paramètres\n<strong>précédents</strong> de la fonction :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x = <span class=\"hljs-number\">1</span>, y = x + <span class=\"hljs-number\">1</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + y;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">x = y + <span class=\"hljs-number\">1</span>, y = <span class=\"hljs-number\">1</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + y;\n}\n\nfoo(); <span class=\"hljs-comment\">// 1 + (1 + 1) → 3</span>\nbar(); <span class=\"hljs-comment\">// (undefined + 1) + 1 → NaN</span>\n</code></pre>\n<h3>Cas particulier : TDZ (Temporal Dead Zone)</h3>\n<p>Une <em>temporal dead zone</em> désigne une zone du programme où une variable &quot;existe&quot;\nmais n'est pas encore accessible tant qu'elle n'a pas reçu de valeur.</p>\n<p>L'exemple suivant semble très logiquement invalide :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x = x</span>) </span>{\n  <span class=\"hljs-comment\">// throws ReferenceError?</span>\n}\n</code></pre>\n<p>En effet, au moment de l'appel à la fonction, <code>x</code> n'a pas encore été défini, et\nne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple\ndevrait\n<a href=\"http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters\">lever une erreur</a>.</p>\n<p>Néanmoins, les règles de portée font que ce programme est également invalide :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x = x</span>) </span>{\n  <span class=\"hljs-comment\">// Le &#x27;x&#x27; référencé ici est le paramètre</span>\n}\n</code></pre>\n<p>On est bien, dès l'évaluation des valeurs par défaut, dans le scope de la\nfonction, et dans ce scope <code>x</code> fait référence au paramètre (pas encore défini)\net pas à la variable du dessus.</p>\n<p><strong>ProTip: ne réutilisez pas 3 fois le même nom de variable</strong> (ça pourra aussi\naider à la compréhension).</p>\n<h2>Décomposition</h2>\n<p>De la même manière que pour les paramètres de fonction, les affectations par\ndécomposition (<a href=\"/fr/articles/js/es2015/destructuring/\">destructuring</a>) peuvent\nbénéficier de valeurs par défaut.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">z</span>: <span class=\"hljs-number\">42</span> };\n<span class=\"hljs-keyword\">const</span> { x = <span class=\"hljs-number\">1</span>, y = x + <span class=\"hljs-number\">1</span>, z, w } = obj;\nw; <span class=\"hljs-comment\">// undefined</span>\nx; <span class=\"hljs-comment\">// 1</span>\ny; <span class=\"hljs-comment\">// 2</span>\nz; <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<p>Pour rappel, l'affectation de l'exemple précédent aurait été écrit de cette\nmanière en ES5 :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> x = obj.x === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-number\">1</span> : obj.x;\n<span class=\"hljs-keyword\">var</span> y = obj.y === <span class=\"hljs-literal\">undefined</span> ? x + <span class=\"hljs-number\">1</span> : obj.y;\n<span class=\"hljs-keyword\">var</span> z = obj.z;\n<span class=\"hljs-keyword\">var</span> w = obj.w;\n</code></pre>\n<h1>Enjoy!</h1>\n<p>Il n'y a <em>a priori</em> plus aucune raison de croiser un test sur <code>undefined</code> dans\nvotre code une fois passé à ES6.</p>\n<p>Un petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43\nimplémente les valeurs par défaut, et encore seulement pour les paramètres de\nfonctions. Il faudra donc utiliser <a href=\"http://babeljs.io\">Babel</a> ou Traceur pour en\nprofiter.</p>\n"}