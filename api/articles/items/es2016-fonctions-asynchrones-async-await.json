{"slug":"es2016-fonctions-asynchrones-async-await","filename":"2015-12-14-es2016-fonctions-asynchrones-async-await","title":"ES2016 (?): fonctions asynchrones (async/await)","date":"Mon, 14 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-14T00:00:00.000Z","title":"ES2016 (?): fonctions asynchrones (async/await)","author":"naholyr","oldSlug":"js/es2016/async-await","slug":"es2016-fonctions-asynchrones-async-await"},"body":"<p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu'elle\nne fait pas partie des propositions acceptées cette année : les fonctions\nasynchrones (async/await). La\n<a href=\"https://tc39.github.io/ecmascript-asyncawait/\">spécification</a> est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.</p>\n<h2>Fonctions asynchrones</h2>\n<p>Pour les traitements asynchrones, vous connaissez déjà\n<a href=\"/fr/articles/js/es2015/promises/\">les promesses</a> qui ont évidemment remplacé\nles callbacks dans votre code. Si vous n'avez pas déjà fait la bascule vers les\npromesses (ne serait-ce que pour la propagation d'erreur),\n<a href=\"/fr/articles/js/es2015/generators/\">les générateurs</a> ont dû finir de vous\nconvaincre grâce aux\n<a href=\"/fr/articles/js/es2015/generators/#use-case-co-routines\">coroutines</a>.</p>\n<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>\n<h2>Exemple de traitement asynchrone : Promise</h2>\n<p>Partons du programme suivant exécuté le 6 décembre dernier dont l'API est basée\nsur les promesses :</p>\n<ul>\n<li>Il récupère tous les utilisateurs prénommés Nicolas</li>\n<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> usersP = getUsers(query);\n  <span class=\"hljs-comment\">// On récupère le champ &quot;email&quot; de tous les utilisateurs</span>\n  <span class=\"hljs-keyword\">const</span> emailsP = usersP.then(<span class=\"hljs-function\"><span class=\"hljs-params\">users</span> =&gt;</span> users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> u.email));\n  <span class=\"hljs-comment\">// Pour chaque email…</span>\n  <span class=\"hljs-keyword\">const</span> sentP = emailsP.then(<span class=\"hljs-function\"><span class=\"hljs-params\">emails</span> =&gt;</span>\n    emails.map(<span class=\"hljs-function\"><span class=\"hljs-params\">email</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// … on envoie un mail</span>\n      <span class=\"hljs-keyword\">return</span> sendMail(email, <span class=\"hljs-string\">&quot;Bonne fête&quot;</span>);\n    }),\n  );\n  <span class=\"hljs-comment\">// On attend que tous les envois soient résolus</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP);\n}\n\nsendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&quot;Nicolas&quot;</span> })\n  .then(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK&quot;</span>))\n  .catch(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;FAIL&quot;</span>));\n</code></pre>\n<h2>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>\n<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// …</span>\n}\n</code></pre>\n<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le\nmot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est &quot;mise en pause&quot; jusqu'à la résolution\n(ou le rejet) de la promesse :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">await</span> aPromise;\n  <span class=\"hljs-comment\">// on n&#x27;arrivera à cette ligne que lorsque &quot;aPromise&quot; sera résolue</span>\n}\n</code></pre>\n<p>Évidemment, l'expression a alors pour valeur celle de résolution de la promesse,\net en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> aPromise;\n    <span class=\"hljs-comment\">// Ici &quot;aPromise&quot; est résolue avec la valeur &quot;result&quot;</span>\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-comment\">// Ici &quot;aPromise&quot; est rejetée avec l&#x27;erreur &quot;err&quot;</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// cette ligne n&#x27;est atteinte qu&#x27;après résolution/rejet</span>\n}\n</code></pre>\n<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et\n<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>\n<h2>Notre premier exemple, avec les fonctions asynchrones</h2>\n<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-keyword\">await</span> getUsers(query);\n  <span class=\"hljs-keyword\">const</span> emails = users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> u.email);\n  <span class=\"hljs-keyword\">const</span> sentP = emails.map(<span class=\"hljs-function\"><span class=\"hljs-params\">email</span> =&gt;</span> sendMail(email, <span class=\"hljs-string\">&quot;Bonne fête&quot;</span>));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP);\n}\n\n<span class=\"hljs-comment\">// Attention, on ne peut pas utiliser &quot;await&quot; hors d&#x27;une fonction &quot;async&quot;</span>\n<span class=\"hljs-comment\">// il faut donc &quot;wrapper&quot; notre code autour d&#x27;une fonction asynchrone</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">await</span> sendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&quot;Nicolas&quot;</span> });\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK&quot;</span>);\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;FAIL&quot;</span>);\n  }\n}\n\nmain();\n</code></pre>\n<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.</p>\n<h2>Attention au piège de l'exécution en série !</h2>\n<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xP = getX(); <span class=\"hljs-comment\">// Requête Ajax</span>\n<span class=\"hljs-keyword\">const</span> yP = getY(); <span class=\"hljs-comment\">// Requête BDD</span>\n<span class=\"hljs-keyword\">const</span> resultP = <span class=\"hljs-built_in\">Promise</span>.all([xP, yP]).then(sum);\n</code></pre>\n<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.</p>\n<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> getX() <span class=\"hljs-comment\">// Requête Ajax…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> getY() <span class=\"hljs-comment\">// Requête BDD…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n</code></pre>\n<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le\nmoment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xP = getX() <span class=\"hljs-comment\">// Requête Ajax démarrée…</span>\n<span class=\"hljs-keyword\">const</span> yP = getY() <span class=\"hljs-comment\">// Requête BDD démarrée…</span>\n\n<span class=\"hljs-comment\">// Version 1 :</span>\n<span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> xP <span class=\"hljs-comment\">// …requête Ajax terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> yP <span class=\"hljs-comment\">// …requête BDD terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n\n<span class=\"hljs-comment\">// Version 2 avec un tableau :</span>\n<span class=\"hljs-keyword\">const</span> vars = [<span class=\"hljs-keyword\">await</span> xP, <span class=\"hljs-keyword\">await</span> yP]\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n\n<span class=\"hljs-comment\">// Version 3 avec Promise.all :</span>\n<span class=\"hljs-keyword\">const</span> vars = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all([xP, yP])\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n</code></pre>\n<h2>Et aujourd'hui ?</h2>\n<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un code\nbasé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à inclure\n<code>babel-polyfill</code> en fichier d'entrée).</p>\n<h2>Conclusion</h2>\n<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !</p>\n<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée pour\nce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)</p>\n"}