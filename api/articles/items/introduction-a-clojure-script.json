{"slug":"introduction-a-clojure-script","filename":"2018-05-22-introduction-a-clojure-script","title":"Introduction à Clojure(Script)","date":"Tue, 22 May 2018 00:00:00 GMT","draft":false,"meta":{"date":"2018-05-22T00:00:00.000Z","title":"Introduction à Clojure(Script)","author":"jeans11","oldSlug":"clojure/intro","slug":"introduction-a-clojure-script"},"body":"<p>La mise en oeuvre d’applications web, mobile, etc implique bien souvent la même\naction: <strong>manipuler des données</strong>. Cette tâche se trouve aussi bien au niveau du\nback-end que du front-end. Par exemple, le back transforme, collecte, met à\ndisposition les données alors que le front s’attache à récupérer ces dernières\net les mettre en forme. Les données peuvent être de différentes formes: chaînes\nde caractères, nombres, listes, maps, etc. Le monde réel est bien souvent\nconfronté à des données beaucoup plus complexes. La manipulation des données est\nun des exercices dans lesquels Clojure(Script) excelle.</p>\n<h3>Clojure(Script) ???</h3>\n<p>Clojure(Script), kesako ?</p>\n<p>En fait, il faut lire <strong>Clojure</strong> et <strong>ClojureScript</strong>.</p>\n<p><a href=\"https://clojure.org/\"><strong>Clojure</strong></a> est un langage compilé, dynamiquement typé,\ns’exécutant sur la JVM (compile vers du bytecode). Il a été crée par Rich Hickey\n(même si vous avez des croyances différentes, vous pouvez regarder une conf de\nce monsieur,\n<a href=\"https://www.youtube.com/watch?v=2V1FtfBDsLU\">c’est très très intéressant</a> !).\nC’est un langage purement fonctionnel et immutable, taillé pour la programmation\nconcurrente (mais pas que).</p>\n<p><a href=\"https://clojurescript.org/\"><strong>ClojureScript</strong></a> c’est Clojure compilant vers du\nJavaScript via Google Closure.</p>\n<blockquote>\n<p>Clojure peut donc être utilisé en back et en front.</p>\n</blockquote>\n<p><strong>Tous les exemples de code qui vont suivre fonctionnent de la même manière pour\nClojure et ClojureScript.</strong></p>\n<h3>Un peu de code</h3>\n<h4>Primitives</h4>\n<p>Comme tous les langages, Clojure comporte des primitives:</p>\n<pre><code class=\"hljs language-clojure\">;integer\n1\n;float\n1.0\n;string\n&quot;Hello&quot;\n;keyword (les keywords sont simplement des symbols. Ils sont généralement\n;utilisés pour définir des constantes ainsi que les keys des maps)\n:hello\n;vector\n[1 2 3]\n;liste (séquence)\n(1 2 3)\n;set\n#{1 2 3}\n;map\n{:label &quot;Hello&quot;}\n</code></pre>\n<h4>Une histoire de parenthèses</h4>\n<p>Clojure reprend la syntaxe de LISP, c’est-à-dire que le langage s’écrit en\nutilisant ses propres structures de données (homoiconicité). Une opération est\ndonc faite de liste:</p>\n<pre><code class=\"hljs language-clojure\">(+ 1 1)\n=&gt; 2\n</code></pre>\n<p>En Clojure, les opérations emploient la notation <em>prefixe</em> qui diffère de la\nnotation <em>infixe</em> que l'on trouve en JavaScript par exemple:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>\n=&gt; <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>Contrairement à la notation <em>infixe</em> où l'opérateur est placé entre les\narguments, la notation <em>prefixe</em> place l'opérateur avant les arguments. En\nClojure, les appels de fonctions se feront toujours de cette façon:</p>\n<pre><code class=\"hljs language-clojure\">(operator arg1 arg2 ...)\n\n;Autres exemples d&#x27;opérations\n\n(- 2 1)\n=&gt; 1\n\n(* 2 2)\n=&gt; 4\n\n(/ 4 2)\n=&gt; 2\n\n(= 1 1)\n=&gt; true\n</code></pre>\n<p>En Clojure, les opérateurs <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code> sont avant tout des fonctions.\nMême si la syntaxe est faite de listes, il y a une différence syntaxique entre\nun appel de fonction et la définition d'une liste</p>\n<pre><code class=\"hljs language-clojure\">;Une opération\n(+ 1 1)\n=&gt; 2\n\n;Une liste\n&#x27;(+ 1 1) ;(quote (+ 1 1))\n=&gt; (+ 1 1)\n\n;Une liste simple\n&#x27;(1 2 3)\n=&gt; (1 2 3)\n\n(1 2 3)\n=&gt; ;Error\n</code></pre>\n<p>Le dernier exemple provoque une erreur car Clojure tente d'exécuter la fonction\n<code>1</code> avec les paramètres <code>2</code> et <code>3</code>. L'utilisation de <code>'</code> ou <code>quote</code> permet de ne\npas évaluer l'opération mais simplement de la retourner sous forme de liste.</p>\n<h4>Les variables</h4>\n<p>Les variables (bindings) sont créées avec le mot clé <code>def</code>.</p>\n<pre><code class=\"hljs language-clojure\">(def level (* 2 10))\nlevel\n=&gt; 20\n\n(def pikachu (str &quot;Oh! Pikachu is level &quot; level))\npikachu\n=&gt; &quot;Oh! Pikachu is level 20&quot;\n</code></pre>\n<p>Les variables sont immuables:</p>\n<pre><code class=\"hljs language-clojure\">;Définition d&#x27;un binding dans le scope global\n(def pikachu &quot;pikachu&quot;)\n\n;Définition d&#x27;un binding local à la fonction `let`\n(let [pikachu (upper-case pikachu)]\n  pikachu) ;Le `let` retourne la dernière valeur\n=&gt; &quot;PIKACHU&quot;\n\n;Le binding global n&#x27;a pas été altéré.\npikachu\n=&gt; &quot;pikachu&quot;\n</code></pre>\n<p><code>let</code> est une fonction qui définit des variables temporaires seulement dans son\nscope local (jusqu'à la fin de la parenthèse fermante). À l'intérieur du <code>let</code>,\nla variable <code>pikachu</code> sera toujours égale à <code>PIKACHU</code>, à l'extérieur elle\nprendra la valeur <code>pikachu</code>. Le code ci-dessous provoque une erreur:</p>\n<pre><code class=\"hljs language-clojure\">(let [raichu &quot;Raichu&quot;]\n  raichu)\n=&gt; &quot;Raichu&quot;\n\n;Le binding `raichu` n&#x27;existe pas dans le scope global\nraichu\n=&gt; ;Error\n</code></pre>\n<h4>Structures conditionnelles</h4>\n<p>En Clojure chaque instruction retourne une valeur, même les structures\nconditionnelles:</p>\n<pre><code class=\"hljs language-clojure\">(def pokemon-name &quot;Pikachu&quot;)\n\n;Simple condition\n(when (= pokemon-name &quot;Pikachu&quot;)\n  &quot;Oh! a Pikachu&quot;)\n=&gt; &quot;Oh! a Pikachu&quot;\n\n;Condition avec un else\n(if (= pokemon-name &quot;Raichu&quot;)\n  &quot;Oh! a Raichu!&quot;\n  &quot;Oh! it&#x27;s not a Raichu!&quot;)\n=&gt; &quot;Oh! it&#x27;s not a Raichu!&quot;\n\n;Fonctionne avec n&#x27;importe quel type de collection\n(for [pokemon [&quot;Pikachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;]]\n  (upper-case pokemon))\n=&gt; (&quot;PIKACHU&quot; &quot;ROUCOUL&quot; &quot;CHENIPAN&quot;)\n</code></pre>\n<h4>Les collections</h4>\n<p>Clojure dispose de plusieurs types de\n<a href=\"https://clojure.org/reference/data_structures#Collections\">collection</a>.</p>\n<ul>\n<li>Les listes simples sont des collections dont l’accès et l'insertion du <em>head</em>\nest efficient. En contrepartie, l’accès à un élement de la liste est moins\nperformant que pour un vecteur.</li>\n</ul>\n<pre><code class=\"hljs language-clojure\">(def my-list &#x27;(&quot;Pikachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;))\n;conj ajoute l&#x27;élement en début de liste\n(conj my-list &quot;Arcko&quot;)\n=&gt; (&quot;Arko&quot; &quot;Pikachu&quot; &quot;Roucoul&quot;  &quot;Chenipan&quot;)\n\n(first my-list)\n=&gt; &quot;Pikachu&quot;\n\n;La liste est scannée avant d&#x27;accèder à l&#x27;élement.\n(nth my-list 1)\n=&gt; &quot;Roucoul&quot;\n\n(map upper-case my-list)\n=&gt; (&quot;PIKACHU&quot; &quot;ROUCOUL&quot; &quot;CHENIPAN&quot;)\n</code></pre>\n<ul>\n<li>Les vecteurs sont des collections optimisées pour l'accès à un élement\narbitraire (via les indexes):</li>\n</ul>\n<pre><code class=\"hljs language-clojure\">(def my-vec [&quot;Pikachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;])\n;conj ajoute l&#x27;élément à la fin du vecteur\n(conj my-vec &quot;Arcko&quot;)\n=&gt; [&quot;Pikachu&quot; &quot;Roucoul&quot;  &quot;Chenipan&quot; &quot;Arcko&quot;]\n\n;Le vecteur accède directement l&#x27;élement.\n(nth my-vec 1) ;(my-vec 1)\n=&gt; &quot;Roucoul&quot;\n\n(map upper-case my-vec)\n=&gt; (&quot;PIKACHU&quot; &quot;ROUCOUL&quot; &quot;CHENIPAN&quot;)\n</code></pre>\n<ul>\n<li>Les sets sont des collections stockant chaque élément de manière unique\n(rendant la duplication impossible):</li>\n</ul>\n<pre><code class=\"hljs language-clojure\">(def my-set #{&quot;Pickachu&quot; &quot;Roucoul&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;})\n=&gt; #{&quot;Pickachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;}\n\n;Les sets sont particulièrement utiles pour tester la présence d&#x27;un élément\n(my-set &quot;Dracaufeu&quot;)\n=&gt; nil ;null\n\n(my-set &quot;Roucoul&quot;)\n=&gt; &quot;Roucoul&quot;\n\n(when (my-set &quot;Pikachu&quot;) &quot;Oh! Great! You have a Pikachu&quot;)\n=&gt; &quot;Oh! Great! You have a Pikachu&quot;\n</code></pre>\n<blockquote>\n<p>En Clojure, les fonctions s'appliquant sur des collections peuvent également\nêtre utilisées sur des maps. Ces dernières sont alors converties en liste de\nvecteur <code>([key value] [key value])</code>.</p>\n</blockquote>\n<h4>Les fonctions</h4>\n<p>Clojure étant un langage fonctionnel, les fonctions sont évidemment <em>first-class\ncitizen</em>, ce qui veut dire qu'elles peuvent être passées en argument et être\nretournées par d'autres fonctions.</p>\n<pre><code class=\"hljs language-clojure\">;Définition d&#x27;une fonction\n(defn make-pokemon-appear\n  &quot;Display a savage pokemon&quot; ;docstring\n  [pokemon-name] ;arguments\n    (str &quot;Oh! a savage &quot; pokemon-name &quot; appear&quot;)) ;Retourne la dernière ligne\n\n(make-pokemon-appear &quot;Pikachu&quot;)\n=&gt; &quot;Oh! a savage Pikachu appear&quot;\n\n(defn random-pokemon-appearance\n  &quot;Choose a random pokemon to appear&quot;\n  [f pokemon-coll]\n    (f (rand-nth pokemon-coll))\n\n(random-pokemon-appearance\n  make-pokemon-appear\n  [&quot;Pikachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;])\n=&gt; &quot;Oh! a savage Chenipan appear&quot;\n\n;Les fonctions anonymes existent aussi en Clojure\n(def add-level-to-pokemon\n  (fn [pokemon-name]\n    (str pokemon-name &quot; level &quot; (rand-int 100))))\n\n(random-pokemon-appearance\n  make-pokemon-appear\n  (map add-level-to-pokemon [&quot;Pikachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;]))\n=&gt; &quot;Oh! a savage Roucoul level 6 appear&quot;\n</code></pre>\n<p>Le mot-clé <code>(defn name ...)</code>(sucre syntaxique pour <code>def name (fn ...)</code>) est\nutilisé pour créer une fonction. Les arguments d’une fonction sont définis dans\nun vecteur. Une fonction peut contenir une chaîne de caractères la documentant\n(à la manière de python).</p>\n<pre><code class=\"hljs language-clojure\">;La fonction doc permet d&#x27;extraire la docstring d&#x27;une fonction\n(doc make-pokemon-appear)\n=&gt; ([pokemon-name])\n     Display a savage pokemon\n</code></pre>\n<p>Par défaut en Clojure, les fonctions ne sont pas <em>autocurried</em>. Toutefois, une\nfonction peut être &quot;décomposée&quot;:</p>\n<pre><code class=\"hljs language-clojure\">(def default-random-pokemon-appear\n  (partial random-pokemon-appear make-pokemon-appear))\n\n(default-random-pokemon-appear [&quot;Pikachu&quot; &quot;Roucoul&quot; &quot;Chenipan&quot;])\n=&gt; &quot;Oh! a savage Pikachu appear&quot;\n</code></pre>\n<p><code>partial</code> retourne une fonction <em>partielle</em> de la fonction passée en paramètre.\nLa signature initiale de la fonction <code>random-pokemon-appear</code> est <code>([f coll])</code>\n(une fonction et une collection). En utilisant <code>partial</code>,\n<code>default-random-pokemon-appear</code> devient une fonction avec la signature\n<code>([coll])</code>. Le premier paramètre <code>f</code> ayant déjà été affecté, il n’est plus\nnécessaire de le passer à la fonction.</p>\n<h4>Les maps</h4>\n<p>En Clojure, les maps sont créées de la façon suivante:</p>\n<pre><code class=\"hljs language-clojure\">(def dracolosse\n  {:id 149\n   :name &quot;Dracolosse&quot;\n   :level 67\n   :types #{:dragon :flying}})\n\n(:name dracolosse)\n=&gt; &quot;Dracolosse&quot;\n\n(:level dracolosse)\n=&gt; 67\n\n(get dracolosse :types)\n=&gt; #{:dragon :flying}\n</code></pre>\n<p>Les keywords peuvent faire office de fonction pour les maps. Ils sont très\nutilisés pour les keys. Toutefois, les chaînes de caractères sont utilisables\nmais ne peuvent pas être employées en opérateur comme c'est le cas pour les\nkeywords.</p>\n<pre><code class=\"hljs language-clojure\">(def dracolosse\n  {&quot;id&quot; 149\n   &quot;name&quot; &quot;Dracolosse&quot;\n   &quot;level&quot; 67\n   &quot;types&quot; #{:dragon :flying}})\n\n(get dracolosse &quot;name&quot;)\n=&gt; &quot;Dracolosse&quot;\n\n(&quot;name&quot; dracolosse)\n=&gt; ;Error\n</code></pre>\n<p>Puisque les structures de données Clojure sont immutables, une update retourne\nun nouvel objet, et l'objet original reste intact:</p>\n<pre><code class=\"hljs language-clojure\">;Ajouter `2` au `level` de `dracolosse`\n(update dracolosse :level + 2)\n=&gt; {:id 149\n    :name &quot;Dracolosse&quot;\n    :level 69\n    :types #{:dragon :flying}}\n\n;La map original reste intact\ndracolosse\n=&gt; {:id 149\n    :name &quot;Dracolosse&quot;\n    :level 67\n    :types #{:dragon :flying}}\n</code></pre>\n<p>La première ligne peut paraître un peu bizarre au premier abord. La signature de\nla fonction <code>update</code> est la suivante: <code>([map key f x y z &amp; mores]) -&gt; new map</code>.\nLa fonction prend donc en paramètre une <code>map</code> (un objet), sur laquelle appliquer\nla transformation, suivie de la <code>key</code> (string ou keyword) à modifier par la\nfonction <code>f</code>. Les autres paramètres (<code>x</code>, <code>y</code>, <code>z</code>) sont en fait les arguments\noptionnels que peut recevoir la fonction de transformation (<code>f</code>). Ainsi, les\ndifférentes opérations retournent strictement la même valeur:</p>\n<pre><code class=\"hljs language-clojure\">(update dracolosse :level (fn [level] (+ level 2)))\n\n(update dracolosse :level #(+ % 2)))\n\n(update dracolosse :level + 2)\n</code></pre>\n<blockquote>\n<p><code>#(+ % 2)</code> est simplement du sucre syntaxique pour une fonction anonyme. Le\n<code>%</code> correspond au paramètre de la fonction.</p>\n</blockquote>\n<p>Un programme est souvent ammené à opérer une série de modifications sur un même\nobjet. Chaîner des opérations est possible grâce aux\n<a href=\"https://clojure.org/guides/threading_macros\">threading macros</a>:</p>\n<pre><code class=\"hljs language-clojure\">(-&gt; dracolosse\n    (update :level + 2)) ;Ajouter `2` au `level`\n    (assoc :height 268)) ;Associer la key `height` avec la valeur 268\n=&gt; {:name &quot;Dracolosse&quot;\n    :height 268\n    :level 69\n    :types #{:dragon :flying}}\n</code></pre>\n<blockquote>\n<p>Le &quot;chaînage&quot; d'opérations existe dans d'autres langages comme par exemple\nOCaml avec l'opérateur <code>|&gt;</code> (qui arrive prochainement dans la nouvelle version\nd'ECMAScript).</p>\n</blockquote>\n<p>La macro <code>-&gt;</code> place le résultat de l’instruction précédente dans le premier\nargument de la fonction courante. Après compilation, le code précédent donne:</p>\n<pre><code class=\"hljs language-clojure\"> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">assoc</span></span>\n   (<span class=\"hljs-name\">update</span>\n     dracolosse\n     <span class=\"hljs-symbol\">:level</span>\n     + <span class=\"hljs-number\">2</span>)\n   <span class=\"hljs-symbol\">:height</span> <span class=\"hljs-number\">268</span>)\n</code></pre>\n<blockquote>\n<p>Une macro est une sorte de fonction qui permet de générer du code lors de la\nphase de compilation (détaillé dans un futur article).</p>\n</blockquote>\n<h4>Les namespaces</h4>\n<p>Clojure permet de créer des\n<a href=\"https://clojure.org/reference/namespaces\"><strong>namespaces</strong></a> pouvant contenir un\nensemble d’instructions:</p>\n<pre><code class=\"hljs language-clojure\">;Déclaration du namespace\n(ns my-namespace.utils)\n\n(defn group-by-type\n  &quot;Take a coll of pokemons and group by it by types&quot;\n  [pokemons]\n  (reduce\n   (fn [acc {:keys [types] :as pokemon}]\n     (merge-with\n      into\n      acc\n      (into {} (map #(vector % [pokemon]) types))))\n   {}\n   pokemons))\n\n;Utilisation du namespace\n(use &#x27;my-namespace.utils)\n\n(def pokemons\n  [{:id &quot;149&quot; :name &quot;Dracolosse&quot; :types #{:dragon :flying}}\n   {:id &quot;376&quot; :name &quot;Metalosse&quot; :types #{:psy :steel}}\n   {:id &quot;169&quot; :name &quot;Nostenfer&quot; :types #{:poison :flying}}\n   {:id &quot;248&quot; :name &quot;Tyranocif&quot; :types #{:rock :darkness}}])\n\n(def pokemons-by-type (group-by-type pokemons))\n\n;Le nombre de pokemons de type vol\n(count (:flying pokemons-by-types))\n=&gt; 2\n\n;Le nom des pokemons de type dragon\n(map :name (:dragon pokemons-by-types))\n=&gt; (&quot;Dracolosse&quot; &quot;Drattack&quot;)\n\n;Le nombre de pokemon par type\n(into\n  {}\n  (map\n    (fn [[type pokemons]] (vector type (count pokemons))\n    pokemons-by-types)\n=&gt; {:dragon 2 :flying 2 :poison 1 :psy 1 :steel 1 :rock 1 :darkness 1}\n</code></pre>\n<p>Dans l’exemple, ci-dessus, <code>ns</code> permet de créer le namespace\n<code>my-namespace.utils</code>. Pour utiliser le namespace dans un autre, Clojure offre\nplusieurs possiblités:</p>\n<pre><code class=\"hljs language-clojure\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">ns</span></span> my-namespace.core\n  <span class=\"hljs-comment\">;Charger toutes les fonctions du namespace</span>\n  (<span class=\"hljs-symbol\">:use</span> my-namespace.utils)\n  <span class=\"hljs-comment\">;Préfixer les fonctions du namespace</span>\n  (<span class=\"hljs-symbol\">:require</span> [my-namespace.utils <span class=\"hljs-symbol\">:as</span> utils])\n  <span class=\"hljs-comment\">;Charger uniquement la ou les fonction(s)</span>\n  (<span class=\"hljs-symbol\">:require</span> [my-namespace.utils <span class=\"hljs-symbol\">:refer</span> [group-by-type]]))\n</code></pre>\n<h4>Le destructuring</h4>\n<p>Clojure dispose d’un puissant mécanisme de\n<a href=\"https://clojure.org/guides/destructuring\"><strong>destructuring</strong></a>:</p>\n<pre><code class=\"hljs language-clojure\">(<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">ns</span></span> my-namespace.utils\n  (<span class=\"hljs-symbol\">:require</span> [clojure.string <span class=\"hljs-symbol\">:refer</span> [join]]))\n\n(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">pokemon-&gt;string</span>\n  <span class=\"hljs-string\">&quot;Take a pokemon and return it to string&quot;</span>\n  <span class=\"hljs-comment\">;Des bindings locals sont crées en fonction des keys de la map</span>\n  <span class=\"hljs-comment\">;{label key label key}</span>\n  <span class=\"hljs-comment\">;`:as` (optionnel) permet de conserver une trace de l&#x27;objet</span>\n  [{id <span class=\"hljs-symbol\">:id</span> pokemon-name <span class=\"hljs-symbol\">:name</span> types <span class=\"hljs-symbol\">:types</span> <span class=\"hljs-symbol\">:as</span> pokemon}]\n  (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">let</span></span> [types-string\n        (<span class=\"hljs-name\">join</span> <span class=\"hljs-string\">&quot;&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">-&gt;&gt;</span></span> types (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">map</span></span> name) (<span class=\"hljs-name\">interpose</span> <span class=\"hljs-string\">&quot;/&quot;</span>)]\n    (<span class=\"hljs-name\"><span class=\"hljs-builtin-name\">str</span></span> pokemon-name <span class=\"hljs-string\">&quot;|&quot;</span> id <span class=\"hljs-string\">&quot;:&quot;</span> types-string <span class=\"hljs-string\">&quot; pokemon&quot;</span>)))\n\n(<span class=\"hljs-name\">pokemon-&gt;string</span> dracolosse)\n=&gt; <span class=\"hljs-string\">&quot;Dracolosse|149: dragon/flying pokemon\n</span></code></pre>\n<p>Dans l’exemple, ci-dessus, la destructuration s’opère sur une map. Il est\npossible de destructurer d’autres structures de données comme les vecteurs par\nexemple:</p>\n<pre><code class=\"hljs language-clojure\">(def pokemons-by-type (group-by-type pokemons))\n\npokemon-by-type\n=&gt; {:dragon ({...} {...}) :psy ({...}) ...}\n\n(into\n  {}\n  (map\n    (fn [[type pokemons]]\n      (vector type (map :name pokemons)))\n    pokemons-by-type))\n=&gt; {:dragon (&quot;Dracolosse&quot; &quot;Drattack&quot;) :psy (&quot;Metalosse&quot;) ...}\n</code></pre>\n<blockquote>\n<p><code>(into {} (...))</code> convertit une collection dans le type indiqué en premier\nparamètre.</p>\n</blockquote>\n<p>C’est tout pour cette première partie sur Clojure. Pour en découvrir un peu plus\nsur le langage, vous pouvez jeter un oeil à la\n<a href=\"https://clojuredocs.org/\">documention</a>. Dans les prochains articles, nous\nverrons d'autres aspects du langage, notamment l'interopérabilité avec Java pour\nClojure et avec JavaScript pour ClojureScript, le REPL-driven-development, le\ntesting, les macros ainsi que l'utilisation de React.</p>\n<p>En attendant, attrapez-les tous ! ;)</p>\n"}