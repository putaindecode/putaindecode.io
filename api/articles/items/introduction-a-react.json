{"slug":"introduction-a-react","filename":"2014-06-04-introduction-a-react","title":"Introduction à React","date":"Wed, 04 Jun 2014 00:00:00 GMT","draft":false,"meta":{"date":"2014-06-04T00:00:00.000Z","title":"Introduction à React","author":"bloodyowl","oldSlug":"js/react","slug":"introduction-a-react"},"body":"<p>Cela fait maintenant un an que React est open-sourced. C'est l'occasion de\nprésenter le petit dernier de la vague MV*.</p>\n<h2>Les différentes approches d'UI</h2>\n<h3>Backbone</h3>\n<p><a href=\"http://backbonejs.org\">Backbone</a> apporte une simplification dans la déclaration\nd'évenements, il reste cependant très peu impliqué dans le rendering. Le choix\nde laisser l'utilisateur décider de tout concernant <code>Backbone.View</code> est positif\npour de nombreux projets, mais rend la gestion du DOM pénible.</p>\n<p>Pour faire du data-binding, <code>Backbone</code> ne propose naturellement rien, et l'on\ndoit faire appel à des mixins supplémentaires pour le mettre en place sans\ns'arracher les cheveux.</p>\n<p>De plus, c'est souvent un moteur de templating comme Handlebars ou Jade qui\ngénére la vue originale. On se retrouve donc avec un joli\n<code>this.$el.html(this.template(data))</code> dans la méthode <code>render()</code> qui va provoquer\ndes jolies horreurs visuelles (ie. les images se rechargent, les videos sont\nréinitialisées).</p>\n<p>En somme, Backbone est très sympathique pour structurer son code proprement,\nmais concernant l'UI, n'aide absolument pas à réduire la compléxité liée aux\nétats du DOM.</p>\n<h3>Angular</h3>\n<p><a href=\"https://angularjs.org\">Angular</a> propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing) et\non déclare ses bindings très simplement avec une syntaxe <code>{{mustache}}</code>.</p>\n<p>On déclare les évenements à l'aide d'attributs <code>ng-{eventName}</code>.</p>\n<p>Sur le papier, angular est donc très sympathique (je ne prendrais pas parti sur\nle dirty checking).</p>\n<h3>Ember</h3>\n<p><a href=\"http://emberjs.com\">Ember</a> est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de <code>data-binding</code> à l'aide de\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/range\">DOM Ranges</a>. Il propose\ndes conventions fortes, et contrairement à la plupart des <em>a priori</em>, est très\nsimple à prendre en main. Les subviews sont très simples à utiliser à l'aide\nd'<code>{{outlet}}</code>.</p>\n<p>Pour résumer, ember et angular proposent de vraies solutions pour la gestion de\nl'UI. Cependant les deux conservent cette démarche :</p>\n<ul>\n<li>on <em>render</em> (génère et insère le bout de DOM) une fois</li>\n<li>on update les bindings</li>\n</ul>\n<h3>React</h3>\n<p><a href=\"http://facebook.github.io/react/\">React</a> change complètement d'approche. Il\npart d'un constat simple : le fait que le DOM ait constamment un état différent,\nc'est chiant à gérer.</p>\n<p>Du coup, et si on appelait <code>.render()</code> à chaque modification ? Ça a l'air\nstupide, hein ? Pas tant que ça en fait.</p>\n<p>React implémente un <strong>DOM virtuel</strong>, une représentation interne du DOM\nextrêmement rapide. La méthode <code>render</code> retourne des objets correspondant à la\nreprésentation interne du DOM virtuel.</p>\n<p>Un composant React reçoit des <code>props</code>, ses paramètres, et peut avoir un <code>state</code>,\nun état local. Lorsque l'on définit un composant React, on peut y mettre un état\npar défaut en définissant une propriété <code>state</code> dans la <code>class</code>.</p>\n<p>Après cela, on peut mettre à jour l'état avec la méthode <code>this.setState</code>, en y\npassage les valeurs de l'état à changer afin de mettre à jour le DOM.</p>\n<p>Le principal avantage est que l'on est certain, du fait de l'appel systématique\nà <code>render</code>, que notre composant React aura la représentation attendue pour un\nétat donné, et ce à n'importe quel point dans le temps.</p>\n<p>Un des autres avantages de React est son algorithme de diff interne. Le DOM\nvirtuel va être comparé avec la version visible, et React effectue à l'aide\nd'opérations simples les seuls changements nécessaires.</p>\n<p>Cela résoud des problématiques comme la position du curseur dans un champ texte\nqui reçoit sa valeur de JavaScript; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le\nfocus. Du même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.</p>\n<p>React peut être utilisé avec JSX, un <em>superset</em> de js qui permet d'écrire les\ntemplates avec une syntaxe XML (voir l'exemple plus bas), ce qui permet de le\nprendre en main très rapidement.</p>\n<h2>Créons un component react :</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> cx <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;classnames&quot;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">View</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// état initial</span>\n  state = {\n    <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-literal\">false</span>,\n  };\n  <span class=\"hljs-keyword\">static</span> defaultProps = {\n    <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&quot;?&quot;</span>,\n  };\n  toggle = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-comment\">// on crée un nouvel état (les états de react sont immutable)</span>\n    <span class=\"hljs-comment\">// et on déclenche le render</span>\n    <span class=\"hljs-built_in\">this</span>.setState({\n      <span class=\"hljs-attr\">checked</span>: !<span class=\"hljs-built_in\">this</span>.state.checked,\n    });\n  };\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-comment\">// `cx` (classnames sur npm) permet de générer une chaîne &quot;className&quot; à</span>\n    <span class=\"hljs-comment\">// partir d&#x27;objets ayant pour clé un className et pour valeur un booléen</span>\n    <span class=\"hljs-keyword\">const</span> classes = cx({\n      <span class=\"hljs-string\">&quot;list-item&quot;</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-string\">&quot;list-item--valid&quot;</span>: <span class=\"hljs-built_in\">this</span>.state.checked,\n    });\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{classes}</span>&gt;</span>\n        {/* notre binding tout simple */}\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n          <span class=\"hljs-attr\">checked</span>=<span class=\"hljs-string\">{this.state.checked}</span>\n          <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>\n          <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{this.toggle}</span>\n        /&gt;</span>\n        {this.props.label}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class=\"hljs-comment\">// on mount le component, et on passe le label</span>\nReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">&quot;HelloWorld&quot;</span> /&gt;</span></span>, <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;id&quot;</span>));\n</code></pre>\n<h2>Sum up des avantages de React</h2>\n<p>React a bien compris ces points :</p>\n<ul>\n<li>le DOM est lent, du moins en écriture, et limiter les interactions avec ce\ndernier est essentiel ;</li>\n<li>devoir continuellement penser à l'état du DOM à l'instant <code>n</code> n'est pas une\npréoccupation que nous devrions avoir en développant l'UI de nos composants ;</li>\n<li>les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\nchaque changement) et de composition (composer une classe de différentes\nfonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\ngrands intérêts, trop peu utilisés en front-end.</li>\n</ul>\n<p>React n'impose pas de bibliothèque pour les data et la communication des\nmodules. Il existe une bibliothèque nommée <a href=\"https://redux.js.org\">redux</a>,\naujourd'hui standard, permettant de gérer ces aspecs facilement.</p>\n<p>Last but not least, vous pouvez render vos composants React depuis le serveur et\nla lib sera assez intelligente pour reconnaitre les composants déjà générés pour\nne pas les render systématiquement, c'est pas beau, ça ?</p>\n"}