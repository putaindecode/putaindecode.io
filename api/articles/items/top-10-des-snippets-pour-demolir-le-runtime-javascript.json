{"slug":"top-10-des-snippets-pour-demolir-le-runtime-javascript","filename":"2017-11-13-top-10-des-snippets-pour-demolir-le-runtime-javascript","title":"Top 10 des snippets pour démolir le runtime JavaScript","date":"Mon, 13 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-13T00:00:00.000Z","title":"Top 10 des snippets pour démolir le runtime JavaScript","author":"bloodyowl","oldSlug":"js/top-10-snippets-demolir-runtime","slug":"top-10-des-snippets-pour-demolir-le-runtime-javascript"},"body":"<p>(ou juste faire une blague à vos collègues)</p>\n<h2>10. L'array vide magique</h2>\n<p>Cette technique fonctionne grace à l'héritage prototypal et au fait que pour une\nobscure raison, <code>Array.prototype</code> est un array (qui hérite de lui même, allez\nsavoir). Il suffit d'appeler une des méthodes mutatives d'<code>Array.prototype</code> sur\nlui-même :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Array</span>.prototype.push(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n</code></pre>\n<p>Puisque dans le corps de <code>Array.prototype.push()</code>, <code>this</code> correspond à\n<code>Array.prototype</code>, c'est dans celui-ci que seront injectés les éléments.</p>\n<pre><code class=\"hljs language-javascript\">[][<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>Et hop. À noter que vu l'implémentation de la plupart des fonctions travaillant\navec des <em>arrays</em>, ça devrait pas causer grand dommage puisque <code>length</code> est géré\nau niveau de l'array, et pas de son prototype. Ceci-dit ça peut surprendre en\nfaisant mumuse dans la console.</p>\n<h2>9. L'objet magique</h2>\n<p>Souvent, dans une boucle <code>for(name in object)</code>, on appelle\n<code>object.hasOwnProperty(name)</code> pour vérifier si la propriété appartient bien à\nl'objet et qu'il ne s'agit pas juste d'un truc hérité.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-comment\">// peut se combiner avec un petit</span>\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; <span class=\"hljs-number\">10</span>; index++) {\n  <span class=\"hljs-built_in\">Object</span>.prototype[index] = <span class=\"hljs-literal\">undefined</span>;\n}\n</code></pre>\n<p>Même concept que pour l'exemple précédent, avec l'héritage prototypal. Le petit\ncôté rigolo ici, c'est que c'est un pattern très courant en JavaScript,\nnotamment dans les bibliothèques que vous utilisez probablement. Et c'est là\nqu'on se rend compte que de mettre la fonction qui vérifie si une propriété est\nhéritée ou non dans l'héritage, c'est pas forcément l'idée du siècle.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> object = {};\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> object) {\n  <span class=\"hljs-keyword\">if</span> (object.hasOwnProperty(object)) {\n    <span class=\"hljs-built_in\">console</span>.log(key);\n  }\n}\n<span class=\"hljs-comment\">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span>\n</code></pre>\n<h2>8. Le DOM fou</h2>\n<p>Celui-là est plutôt sympa quand vous ou vos bibliothèques DOM de prédilection\ntouchez un peu aux élements. Vu que l'appel à <code>Math.random()</code> rend l'opération\naussi déterministe que l'application de styles assignés à des sélecteurs CSS\nchargés de manière asynchrone, vous risquez de jolies surprises.</p>\n<pre><code class=\"hljs language-javascript\">Element.prototype.appendChild = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> Element.prototype.insertBefore.call(\n    <span class=\"hljs-built_in\">this</span>,\n    element,\n    <span class=\"hljs-built_in\">this</span>.childNodes[<span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-built_in\">this</span>.childNodes.length)],\n  );\n};\n</code></pre>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; <span class=\"hljs-number\">10</span>; index++) {\n  <span class=\"hljs-built_in\">document</span>.body.appendChild(<span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-built_in\">String</span>(index)));\n}\n<span class=\"hljs-comment\">// &quot;1895234760&quot; (par exemple)</span>\n</code></pre>\n<h2>7. Simple mais efficace, faire de la console une no-op</h2>\n<p>Bizarrement, j'ai déjà vu des sites qui faisaient ça en production (e.g. Twitter\nsi je me rappelle correctement). Vous rendez inopérable la console, ce qui peut\nfaire une très bonne blague à vos collègues en cachant ça dans un vieux commit\navec l'option <code>amend</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-built_in\">console</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>[key] = <span class=\"hljs-function\">() =&gt;</span> {};\n});\n</code></pre>\n<h2>6. Supprimer les stack traces des erreurs</h2>\n<p>Là, on est vraiment sur le petit truc horrible, parce que vous pouvez mettre un\npetit moment avant de le réaliser. Le constructeur <code>Error</code> vient normalement\najouter une propriété <code>stack</code> qui vous permet de retrouver le chemin qu'a\nemprunté le code avant de jeter une erreur. Eh ben fini, à vous le debug à\nl'aveugle !</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Error</span>(<span class=\"hljs-params\">message</span>) </span>{\n    <span class=\"hljs-built_in\">this</span>.message = message;\n  }\n  <span class=\"hljs-built_in\">Error</span>.prototype = <span class=\"hljs-built_in\">window</span>.Error.prototype;\n  <span class=\"hljs-built_in\">window</span>.Error = <span class=\"hljs-built_in\">Error</span>;\n})();\n</code></pre>\n<h2>5. Rendre l'asynchrone synchrone</h2>\n<p>Il est assez courrant d'avoir des <code>setTimeout(func)</code> ou <code>setTimeout(func, 0)</code>\n(les deux sont équivalents). Ça permet s'assurer qu'on décale un peu l'execution\nd'une fonction, et souvent de s'assurer que si elle jette une erreur, elle\nn'empêchera pas le reste de s'executer.</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> originalTimeout = <span class=\"hljs-built_in\">window</span>.setTimeout;\n  <span class=\"hljs-built_in\">window</span>.setTimeout = <span class=\"hljs-function\">(<span class=\"hljs-params\">func, duration, ...args</span>) =&gt;</span>\n    !duration\n      ? func(...args)\n      : originalTimeout.call(<span class=\"hljs-built_in\">window</span>, func, duration, ...args);\n})();\n</code></pre>\n<p>Avec ce snippet, petites surprises bizarres assurées. Et c'est un bug présent\ndans quelques bibliothèques implémentant une fonction <code>domReady</code>, et qui font:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">domReady</span>(<span class=\"hljs-params\">func</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">document</span>.readyState === <span class=\"hljs-string\">&quot;complete&quot;</span>) {\n    func();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">&quot;DOMContentLoaded&quot;</span>, func);\n  }\n}\n</code></pre>\n<p>Avec une implémentation comme celle qu'on voit au dessus, <code>func</code> aura un\ncomportement différent si le DOM est chargé ou non:</p>\n<pre><code class=\"hljs language-javascript\">domReady(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>();\n});\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-comment\">// Logue 1 si le DOM est prêt, parce que l&#x27;execution de func par le handler DOMContentLoaded est asynchrone</span>\n<span class=\"hljs-comment\">// Logue rien du tout si func() est appelé en synchrone par la première branche de domReady</span>\n</code></pre>\n<h2>4. Le réseau qui ne répond jamais</h2>\n<p>Les <code>Promise</code>, c'est bien relou à débugger lorsque ça reste infiniment en\n&quot;pending&quot;: on ne sait pas forcément pourquoi, surtout si c'est derrière une API\nopaque, comme <code>fetch</code>. Plaisir garanti, parce qu'avec ça sur la page, c'est\nprobablement le dernier endroit où on va intuitivement chercher la source la\nbug.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.fetch = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">() =&gt;</span> {});\n</code></pre>\n<h2>3. Faire marcher les event listener au hasard</h2>\n<p>C'est particulièrement horrible quand un bug n'est pas reproduit à tous les\ncoups: pourquoi ne pas attacher les évenements au hasard ?</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> originalAddEventListener = Element.prototype.addEventListener;\n  Element.prototype.addEventListener = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...args</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Math</span>.random() &lt; <span class=\"hljs-number\">0.75</span>) {\n      originalAddEventListener.call(<span class=\"hljs-built_in\">this</span>, ...args);\n    }\n  };\n})();\n</code></pre>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>));\n</code></pre>\n<h2>2. Faire foirer parseInt de temps en temps</h2>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> originalParseInt = <span class=\"hljs-built_in\">window</span>.parseInt;\n  <span class=\"hljs-built_in\">window</span>.parseInt = <span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> (<span class=\"hljs-built_in\">Math</span>.random() &gt; <span class=\"hljs-number\">0.9</span> ? originalParseInt(n) : <span class=\"hljs-literal\">NaN</span>);\n})();\n</code></pre>\n<p>Pour un bon petit moment à pas comprendre ce qui se passe. Je suis sûr que <code>NaN</code>\nn'est pas toujours géré dans tous les cas dans la plupart des scripts qui\ntournent aujourd'hui en prod.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&quot;1&quot;</span>); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&quot;1&quot;</span>); <span class=\"hljs-comment\">// NaN</span>\n</code></pre>\n<h2>1. (De)serialiser les URL</h2>\n<p>Pour ce coup, c'est bien de prévoir les deux fonctions utilisées par tout le\nmonde pour encoder et décoder les URLs. Vu que si l'une ne marche pas, le\nreflexe est souvent de tester la deuxième, bon arrachage de cheveux en\nperspective.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.decodeURIComponent = <span class=\"hljs-built_in\">window</span>.encodeURIComponent = <span class=\"hljs-built_in\">window</span>.escape = <span class=\"hljs-built_in\">window</span>.unescape = <span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =&gt;</span>\n  <span class=\"hljs-built_in\">String</span>(a);\n</code></pre>\n<h2>Bonus: pour rendre tout ça crédible</h2>\n<p>Si dans la console de développement, vous tapez le nom d'une fonction accessible\ndans le scope, le navigateur va appeler <code>Function.prototype.toString</code> sur cette\nfonction pour en récupérer l'allure. Couvrez vos arrières en replaçant la\nméthode :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Function</span>.prototype.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`function <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">this</span>.name || <span class=\"hljs-string\">&quot;&quot;</span>}</span>() {\n    [native code]\n}`</span>;\n};\n</code></pre>\n<pre><code class=\"hljs language-javascript\">() =&gt; {};\n<span class=\"hljs-comment\">/* function () {\n    [native code]\n} */</span>\n</code></pre>\n<p>Pour faire un peu de zèle, vous pouvez également déclarer ces fonctions dans un\n<code>eval</code> pour brouiller les pistes sur l'endroit où elles ont été déclarées.</p>\n<p>Voilà, vous avez toutes les clés pour faire des petites blagues à vos collègues.</p>\n<p>Et n'oubliez pas, JavaScript c'est super, mais faisez gaffe quand même, parce\nque dans un langage encourageant la mutabilité, qui utilise des globales et de\nl'héritage par dessus le marché, il suffit d'un petit bout de code innocent pour\nque plus rien ne marche.</p>\n<p>Bisous.</p>\n"}