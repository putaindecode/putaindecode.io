{"slug":"external-interface-call-flash-backbone","filename":"2013-12-05-external-interface-call-flash-backbone","title":"ExternalInterface.call() de Flash (et Backbone), toute une histoire","date":"Thu, 05 Dec 2013 00:00:00 GMT","draft":false,"meta":{"date":"2013-12-05T00:00:00.000Z","title":"ExternalInterface.call() de Flash (et Backbone), toute une histoire","author":"kud","oldSlug":"flash/bug-externalinterface-call-backbone","slug":"external-interface-call-flash-backbone"},"body":"<p>Je voulais vous parler d'un bug qui m'a bien emmerdé récemment et comme\nj'aimerais que vous ne perdiez pas de temps avec cela, un article s'imposait.</p>\n<p><em>Note de la direction : j'y connais rien en Flash (et je ne crois pas avoir trop\nenvie de connaître en fait).</em></p>\n<p>Dans la boite où je travaille, nous utilisons Flash en tant que lecteur vidéo\nétant donné qu'il est pour le moment très difficile de faire lire sur toutes les\nplateformes des vidéos au format <em>H.264</em> et/ou passant par du <em>HLS</em>. Longue\nhistoire qui fera office d'un autre article. (Je dis ça à chaque fois, haha).</p>\n<h2>Le pitch</h2>\n<p>Avec notre <em>flasheur</em> attitré, nous nous sommes mis en tête de créer un objet\n<em>event</em> qui permettrait au Flash de déclencher des évènements lorsqu'il le\nsouhaite afin de communiquer avec l'application JavaScript et que celui-ci fasse\nen conséquence. Cet objet, nous l'avons appelé <code>App.FlashManager</code> et plus\nprécisemment <code>App.FlashManager.Events</code> dans le cas des évènements. Nous\nutilisons <strong>Backbone.js</strong> pour gérer ce principe d'évènement mais vous en avez\nd'<a href=\"http://microjs.com/#event\">autres</a> de disponible. En pratique, voilà ce que\nça donne :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// on crée un objet vide</span>\nApp.FlashManager.Events = {};\n\n<span class=\"hljs-comment\">// on lui ajoute les fonctionnalités des events Backbone</span>\n_.extend(App.FlashManager.Events, Backbone.Events);\n</code></pre>\n<p>En soi, pas de souci, tout se passe bien à ce moment, nous avons un\n<a href=\"http://backbonejs.org/#Events\">objet d'évènement façon Backbone</a>. Il pourra\nalors s'écouter lui-même, écouter un autre objet, mais aussi déclencher des\névènements.</p>\n<h2>Côté Flash</h2>\n<p>La base est en place, maintenant on souhaite que le Flash déclenche un\névènement. On passe par l'objet <code>ExternalInterface</code> :</p>\n<pre><code class=\"hljs language-javascript\">ExternalInterface.call(<span class=\"hljs-string\">&quot;window.App.FlashManager.Events.trigger&quot;</span>, <span class=\"hljs-string\">&quot;my-event&quot;</span>);\n<span class=\"hljs-comment\">// http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/external/ExternalInterface.html#call</span>\n</code></pre>\n<p>Et là, bug.</p>\n<h2>Pourquoi bug ?</h2>\n<p>Pour le moment, je ne sais pas vraiment. Je me pencherai plus sur le sujet dès\nque j'ai un peu de temps, mais ce que je sais, c'est que\n<code>ExternalInterface.call()</code> ne s'attend pas à recevoir ce que <strong>Backbone.js</strong> lui\npropose. Lorsque vous faites <code>.trigger()</code>, <strong>Backbone.js</strong> renvoie\nl'<a href=\"https://github.com/jashkenas/backbone/blob/master/backbone.js#L144-L153\">objet en cours</a>,\nce qui provoque un énooooorme bug dans le plugin Flash de votre navigateur.</p>\n<h2>La solution côté JavaScript</h2>\n<p>Pour contrer cela, je vous propose la solution suivante qui est de ne pas\nutiliser directement l'objet <code>Backbone.Events|View</code> mais plutôt de passer par\nune interface, un objet proxy.</p>\n<p>Voici le schéma :</p>\n<ul>\n<li>Créer un objet simple qui contient les mêmes noms de méthodes que les objets\névènements <strong>Backbone.js</strong> (en gros, se mapper sur l'API Backbone)</li>\n<li>Utiliser <strong>Backbone.js</strong> dans les méthodes de cet objet <em>Proxy</em></li>\n</ul>\n<p>Exemple :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Bridge between flash and js</span>\nApp.FlashManager = {};\nApp.FlashManager.Events = {};\n\n<span class=\"hljs-comment\">// Backbone events used for Flash</span>\nApp.InternalFlashManager = {};\nApp.InternalFlashManager.Events = {};\n\n_.extend(App.InternalFlashManager.Events, Backbone.Events);\n\nApp.FlashManager.Events.trigger = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name, opts</span>) </span>{\n  App.InternalFlashManager.Events.trigger(name, opts);\n\n  <span class=\"hljs-comment\">// Must return nothing not to loop JavaScript engine, important!</span>\n  <span class=\"hljs-keyword\">return</span>;\n};\n</code></pre>\n<h2>Oh et...</h2>\n<p>...il existe une version ayant plus ou moins le même souci que moi disponible là\n:\n<a href=\"https://coderwall.com/p/e-8niw\">ExternalInterface#call in a deadly loop (<strong>flash</strong>toXML)</a>.</p>\n<h2>Conclusion</h2>\n<p>De manière générale (hors <strong>Backbone.js</strong>), lorsque vous utilisez\n<code>ExternalInterface.call()</code>, faites en sorte que votre JavaScript retourne\nquelque chose de simple (un objet ayant que des attributs, pas de fonctions, ou\nencore un booléen ou un <em>integer</em>).</p>\n"}