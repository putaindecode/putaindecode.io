{"slug":"introduction-a-reasonml","filename":"2017-10-02-introduction-a-reasonml","title":"Introduction à ReasonML (ou pourquoi j'ai arrêté d'utiliser JavaScript)","date":"Mon, 02 Oct 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-10-02T00:00:00.000Z","title":"Introduction à ReasonML (ou pourquoi j'ai arrêté d'utiliser JavaScript)","author":"bloodyowl","oldSlug":"reason/introduction-reason","slug":"introduction-a-reasonml"},"body":"<p>Les bugs c'est chiant, surtout quand on sait qu'on aurait pu les éviter. Avec\nJavaScript, c'est plus facile d'en avoir que de les éviter.</p>\n<p>JavaScript, on ne peut pas y échapper parce que c'est partout, parce que c'est\nle langage de programmation le plus utilisé sur Terre, et parce que c'est le\nseul truc qui (pour l'instant) tourne nativement dans le navigateur. Et puis\nc'est pas si mal, c'est facile de l'apprendre en bidouillant un peu, c'est très\npermissif et pas trop frustrant pour débuter.</p>\n<p>Le problème c'est que c'est facile d'en faire, mais c'est très dur d'en faire\n<strong>bien</strong> (moins que CSS, mais quand même). On s'est tous déjà retrouvé avec\n<code>undefined is not a function</code>, <code>null is not an object</code> ou un bon gros\n<code>[object Object]</code> qui traîne dans la console.</p>\n<h2>Pourquoi est-ce que c'est comme ça ?</h2>\n<p>JavaScript est un langage dynamiquement et faiblement typé, ce qui veut dire :</p>\n<ul>\n<li>qu'une fonction ne sait pas ce qu'elle prend ou retourne comme type\nd'arguments, c'est à vous de gérer</li>\n<li>que le programme n'en a aucune idée non plus tant qu'il n'execute pas la\nportion de code</li>\n</ul>\n<p>Tout ça fait qu'il est très difficile de faire confiance à du code JavaScript.</p>\n<figure>\n<img src=\"/public/images/articles/2017-10-02-introduction-a-reasonml/js.png\" alt=\"js\" />\n<figcaption>Source: MIT</figcaption>\n</figure>\n<p>Il existe Flow et TypeScript (dont on a parlé dans un\n<a href=\"/fr/articles/js/flow/\">précédent article</a> et un\n<a href=\"fr/articles/podcast/3/\">podcast</a>), deux projets qui permettent d'apporter du\ntypage statique pour sécuriser son code. Ils contraignent votre usage de\nJavaScript, mais devront toujours se battre contre sa permissivité.</p>\n<p>Ça revient au final à coller des rustines sur vos pneus avant d'aller rouler sur\ndes clous, ça va vous protéger un peu, mais ça reste de base pas bien malin\nd'aller rouler sur des clous.</p>\n<p>Il existe des langages qui ont la judicieuse idée de balayer la route pour virer\nles clous avant d'y aller : les langages typés fortement et statiquement (10\npoints pour Gryffondor pour cette métaphore filée).</p>\n<p>OCaml est un de ces langages. Il est de la famille ML et a été créé en France\ndans les années 90. Il est à peu près aussi âgé que JavaScript mais est beaucoup\nplus sage. Il est certes fortement et statiquement typé, mais il infère la\nplupart des types du programme (ce qui veut dire que vous n'avez pas à\nrenseigner les types partout, il va l'extrapoler dès qu'il le peut). En bonus,\nil possède de\n<a href=\"https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html\">bonnes data-structures</a>.</p>\n<p>Seulement voilà, OCaml, comme beaucoup de langages fonctionnels n'a pas vraiment\nmis l'accent sur l'accessibilité pour les débutants, et a une syntaxe qu'on peut\npour le moins qualifier de pas très friendly: elle n'a rien de bien mal, mais\nmettez quelqu'un qui vient de JS/PHP/Java devant, ça va pas lui causer des\nmasses:</p>\n<pre><code class=\"hljs language-ocaml\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">rec</span> qsort = <span class=\"hljs-keyword\">fun</span> <span class=\"hljs-keyword\">value</span> -&gt;\n  <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">value</span> <span class=\"hljs-keyword\">with</span>\n   | <span class=\"hljs-literal\">[]</span> -&gt; <span class=\"hljs-literal\">[]</span>\n   | pivot :: rest -&gt;\n       <span class=\"hljs-keyword\">let</span> is_less x = x &lt; pivot <span class=\"hljs-keyword\">in</span>\n       <span class=\"hljs-keyword\">let</span> left, right = <span class=\"hljs-type\">List</span>.partition is_less rest <span class=\"hljs-keyword\">in</span>\n       qsort left @ [pivot] @ qsort right;;\n</code></pre>\n<figure>\n<img src=\"/public/images/articles/2017-10-02-introduction-a-reasonml/giphy.gif\" alt=\"\" />\n<figcaption>fig. 1: dev JS devant du code OCaml</figcaption>\n</figure>\n<p>C'est là qu'intervient Reason, un projet initié par\n<a href=\"https://twitter.com/jordwalke\">le créateur de React</a>. Les premières itérations\nde React étaient d'ailleurs codées dans un langage cousin de OCaml, le SML.</p>\n<p>C'est en gros:</p>\n<ul>\n<li>OCaml</li>\n<li>avec une syntaxe <em>beginner-friendly</em></li>\n<li>avec un tooling le rendant plus simple à utiliser</li>\n<li>qui peut compiler vers JavaScript et de multiples plateformes</li>\n</ul>\n<p>Avec son type system, OCaml propose un langage <em>safe-by-design</em>, chose que même\navec une palanquée d'outils, on ne peut pas atteindre avec JavaScript.</p>\n<p>Le langage propose par défaut une approche fonctionnelle et immutable, mais\npermet cependant de choisir d'utiliser des structures mutables et de l'orienté\nobjet au besoin.</p>\n<h2>Le langage</h2>\n<p>Reason comporte plus de types de primitifs que JavaScript:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* pas un gros &quot;number&quot; fourre tout, magique */</span>\n<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">/* int */</span>\n<span class=\"hljs-number\">1.0</span>; <span class=\"hljs-comment\">/* float */</span>\n<span class=\"hljs-comment\">/* un caractère est d&#x27;un type différent de string */</span>\n<span class=\"hljs-string\">&quot;foo&quot;</span>; <span class=\"hljs-comment\">/* string */</span>\n<span class=\"hljs-character\">&#x27;a&#x27;</span>; <span class=\"hljs-comment\">/* char */</span>\n<span class=\"hljs-comment\">/* on trouve list ET array, chacun peut être utilisé pour différents cas */</span>\n<span class=\"hljs-literal\">[</span><span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span><span class=\"hljs-literal\">]</span>; <span class=\"hljs-comment\">/* list */</span>\n<span class=\"hljs-literal\">[|</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> <span class=\"hljs-literal\">|]</span>; <span class=\"hljs-comment\">/* array */</span>\n<span class=\"hljs-comment\">/* pas de null, mais des valeurs de type `option` qui contiennent\n  soit une valeur, soit rien */</span>\n<span class=\"hljs-constructor\">Some</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">/* option int */</span>\n<span class=\"hljs-constructor\">None</span>; <span class=\"hljs-comment\">/* option int */</span>\n</code></pre>\n<p>Puisqu'il est fortement typé, il est impossible de mixer les types comme en\nJavaScript, vous devrez obligatoirement les convertir:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-number\">1</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1.0</span>;\n<span class=\"hljs-comment\">/* Error:\n  This expression has type int but an expression was expected of type float */</span>\n<span class=\"hljs-number\">1</span> <span class=\"hljs-operator\">+</span> int_of_float(<span class=\"hljs-number\">1.0</span>);\n<span class=\"hljs-comment\">/* - : int = 2 */</span>\n</code></pre>\n<p>La plupart des opérations de transformations de type primitifs vers un autre\nsont accessibles dans le module <code>Pervasives</code> qui contient plein de petits\nutilitaires bien pratiques. Toutes les fonctions de ce module sont accessibles\ndirectement dans n'importe quel de vos fichiers.</p>\n<p>Les fonctions de Reason sont beaucoup plus puissantes qu'en JavaScript:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> add = (a, b) =&gt; a <span class=\"hljs-operator\">+</span> b;\n<span class=\"hljs-comment\">/* int =&gt; int =&gt; int */</span>\nadd(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-comment\">/* 3 */</span>\nadd(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2.0</span>);\n<span class=\"hljs-comment\">/* This expression has type float but an expression was expected of type int */</span>\n\n<span class=\"hljs-comment\">/* Les fonctions sont &quot;auto-curried&quot;, ce qui signifie qu&#x27;une fonction\n   qui n&#x27;a pas reçu tous ses paramètres retourne une nouvelle fonction\n  qui va recevoir les paramètres manquants */</span>\n<span class=\"hljs-keyword\">let</span> addOne = add(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-comment\">/* int =&gt; int */</span>\n\n<span class=\"hljs-comment\">/* Les fonctions peuvent avoir des paramètres nommés, optionnels et avec des valeurs par défaut */</span>\n<span class=\"hljs-keyword\">let</span> sayHi = (~name, ~punct=<span class=\"hljs-string\">&quot;!&quot;</span>, ()) =&gt; <span class=\"hljs-string\">&quot;Hello &quot;</span> <span class=\"hljs-operator\">++</span> name <span class=\"hljs-operator\">++</span> punct;\n<span class=\"hljs-comment\">/* name::string =&gt; string */</span>\nsayHi(~name=<span class=\"hljs-string\">&quot;you&quot;</span>, ());\n<span class=\"hljs-comment\">/* &quot;Hello you!&quot; */</span>\n<span class=\"hljs-comment\">/* L&#x27;ordre des arguments nommés n&#x27;a pas d&#x27;importance*/</span>\nsayHi(~punct=<span class=\"hljs-string\">&quot;?&quot;</span>, ~name=<span class=\"hljs-string\">&quot;you&quot;</span>, ());\n<span class=\"hljs-comment\">/* &quot;Hello you?&quot; */</span>\n</code></pre>\n<p>Pour définir l'équivalent d'un <em>plain-object</em> JavaScript en Reason, on utilise\ndes records:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* On doit typer les records */</span>\n<span class=\"hljs-keyword\">type</span> user = {\n  username: string,\n  age: int\n};\n\n<span class=\"hljs-comment\">/* Les records ont un nombre de clés fini, vous ne pouvez pas en\n  ommettre une ou en mettre une en trop */</span>\n<span class=\"hljs-keyword\">let</span> user = { username: <span class=\"hljs-string\">&quot;Bob&quot;</span> };\n<span class=\"hljs-comment\">/* Error: Some record fields are undefined: age */</span>\n\n<span class=\"hljs-keyword\">let</span> user = { username: <span class=\"hljs-string\">&quot;Bob&quot;</span>, age: <span class=\"hljs-number\">20</span> };\n\n<span class=\"hljs-comment\">/* Les records sont immutables par défaut */</span>\n<span class=\"hljs-keyword\">let</span> olderUser = {<span class=\"hljs-operator\">...</span>user, age: user.age <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span> };\n</code></pre>\n<p>Reason possède un système de module très puissant: par défaut, chaque fichier de\nvotre codebase est un module, mais vous pouvez également déclarer des modules\n<em>dans</em> un module.</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-module-identifier\">User</span> = {\n  <span class=\"hljs-keyword\">type</span> t = {\n    id: string,\n    username: string,\n    email: option(string)\n  };\n  <span class=\"hljs-keyword\">let</span> make = (~id, ~username, ~email) =&gt; {id, username, email};\n  <span class=\"hljs-keyword\">let</span> sayHi = (user) =&gt; <span class=\"hljs-string\">&quot;Hello &quot;</span> <span class=\"hljs-operator\">++</span> user.username <span class=\"hljs-operator\">++</span> <span class=\"hljs-string\">&quot;!&quot;</span>;\n};\n\n<span class=\"hljs-comment\">/* Pour utiliser un module, tapez son nom, tout simplement */</span>\n<span class=\"hljs-module-identifier\">User</span>.make(~id=<span class=\"hljs-string\">&quot;0&quot;</span>, ~username=<span class=\"hljs-string\">&quot;bloodyowl&quot;</span>, ~email=<span class=\"hljs-constructor\">None</span>)\n  <span class=\"hljs-comment\">/* (ah oui, le pipe existe déjà ici, pas besoin d&#x27;attendre ES2050)*/</span>\n  <span class=\"hljs-operator\">|&gt;</span> <span class=\"hljs-module-identifier\">User</span>.sayHi\n  <span class=\"hljs-operator\">|&gt;</span> print_endline;\n<span class=\"hljs-comment\">/* &quot;Hello bloodyowl&quot; */</span>\n\n<span class=\"hljs-comment\">/* On peut également rendre toutes les valeurs d&#x27;un module accessibles localement */</span>\n<span class=\"hljs-module-identifier\">User</span>.(\n  make(~id=<span class=\"hljs-string\">&quot;0&quot;</span>, ~username=<span class=\"hljs-string\">&quot;bloodyowl&quot;</span>, ~email=<span class=\"hljs-constructor\">None</span>)\n    <span class=\"hljs-operator\">|&gt;</span> sayHi\n    <span class=\"hljs-operator\">|&gt;</span> print_endline\n);\n\n<span class=\"hljs-comment\">/* Carrément les rendre accessibles globalement dans le module */</span>\n<span class=\"hljs-keyword\">open</span> <span class=\"hljs-module-identifier\">User</span>;\n\nmake(~id=<span class=\"hljs-string\">&quot;0&quot;</span>, ~username=<span class=\"hljs-string\">&quot;bloodyowl&quot;</span>, ~email=<span class=\"hljs-constructor\">None</span>)\n  <span class=\"hljs-operator\">|&gt;</span> sayHi\n  <span class=\"hljs-operator\">|&gt;</span> print_endline;\n\n<span class=\"hljs-comment\">/* Ou même étendre un module statiquement et proprement,\n  ça vous parle ça, Prototype et MooTools ?! */</span>\n<span class=\"hljs-keyword\">module</span> <span class=\"hljs-module-identifier\">UserThatCanSayBye</span> = {\n  <span class=\"hljs-keyword\">include</span> <span class=\"hljs-module-identifier\">User</span>;\n  <span class=\"hljs-keyword\">let</span> sayBye = (user) =&gt; <span class=\"hljs-string\">&quot;Bye &quot;</span> <span class=\"hljs-operator\">++</span> user.username <span class=\"hljs-operator\">++</span> <span class=\"hljs-string\">&quot;!&quot;</span>;\n};\n</code></pre>\n<p>Il existe également des functors, qui sont des sortes de fonctions retournant\ndes modules à partir d'autres modules, mais on ne l'abordera pas dans cet\narticle.</p>\n<p>Reason possède également des variants, il s'agit de types pouvant avoir\ndifférents cas. Prenons l'exemple d'un message de chat:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">type</span> image = {url: string, width: int, height: int};\n\n<span class=\"hljs-comment\">/* chaque cas du variant peut prendre des paramètres */</span>\n<span class=\"hljs-keyword\">type</span> message =\n  | <span class=\"hljs-constructor\">String</span>(string) <span class=\"hljs-comment\">/* soit une chaîne de caractères */</span>\n  | <span class=\"hljs-constructor\">Image</span>(image) <span class=\"hljs-comment\">/* soit une image */</span>\n  | <span class=\"hljs-constructor\">Emoji</span>(string); <span class=\"hljs-comment\">/* soit un gros emoji */</span>\n\n<span class=\"hljs-keyword\">let</span> stringMessage = <span class=\"hljs-constructor\">String</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>); <span class=\"hljs-comment\">/* On crée la valeur avec son constructeur */</span>\n<span class=\"hljs-keyword\">let</span> imageMessage = <span class=\"hljs-constructor\">Image</span>({url: <span class=\"hljs-string\">&quot;https://fakeimg.pl/300x300&quot;</span>, width: <span class=\"hljs-number\">300</span>, height: <span class=\"hljs-number\">300</span>});\n<span class=\"hljs-keyword\">let</span> emojiMessage = <span class=\"hljs-constructor\">Emoji</span>(<span class=\"hljs-string\">{js|🐫|js}</span>); <span class=\"hljs-comment\">/* Quand la string contient de caractères unicode,\n  on doit utiliser {js|votre string|js} */</span>\n</code></pre>\n<p>Ici, notre type <code>message</code> est bien délimité, et ses valeurs ne peuvent être que\ncelles que l'on a défini.</p>\n<p>Pour utiliser les valeurs d'un variant, on peut les extraire à l'aide de\n<code>switch</code>, qui va <em>pattern-matcher</em> pour nous permettre d'identifier et\nd'extraire les valeurs.</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-comment\">/* Petit bonus, l&#x27;exemple utilise ReasonReact, mais on détaillera ça dans un prochain article */</span>\n<span class=\"hljs-keyword\">let</span> component = <span class=\"hljs-module-identifier\">ReasonReact</span>.statelessComponent(<span class=\"hljs-string\">&quot;ChatMessage&quot;</span>);\n\n<span class=\"hljs-keyword\">let</span> make = (~message, _children) =&gt; {\n  <span class=\"hljs-operator\">...</span>component,\n  render: (_) =&gt;\n    &lt;div&gt;\n      (<span class=\"hljs-keyword\">switch</span> message {\n        | <span class=\"hljs-constructor\">String</span>(value) =&gt; <span class=\"hljs-module-identifier\">ReasonReact</span>.stringToElement(value)\n        | <span class=\"hljs-constructor\">Image</span>({url: src, width, height}) =&gt; &lt;img width height src /&gt;\n        <span class=\"hljs-comment\">/* Si par mégarde j&#x27;oublie un cas possible dans un switch, je vais avoir un joli warning du\n          compiler qui me dira:\n            This pattern-matching is not exhaustive.\n            Here is an example of a value that is not matched:\n              Emoji\n        */</span>\n        | <span class=\"hljs-constructor\">Emoji</span>(value) =&gt;\n          &lt;div style=(<span class=\"hljs-module-identifier\">ReactDOMRe</span>.<span class=\"hljs-module-identifier\">Style</span>.make(~fontSize=<span class=\"hljs-string\">&quot;40px&quot;</span>, ()))&gt;\n            (<span class=\"hljs-module-identifier\">ReasonReact</span>.stringToElement(value))\n          &lt;/div&gt;\n      })\n    &lt;/div&gt;\n};\n</code></pre>\n<p>En Reason, les <em>let bindings</em> ont automatiquement le block parent comme scope,\non peut du coup écrire des choses comme ceci :</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> value = {\n  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>;\n  a <span class=\"hljs-operator\">+</span> b; <span class=\"hljs-comment\">/* la dernière expression est toujours retournée par défaut */</span>\n};\n<span class=\"hljs-comment\">/* let value : int = 3 */</span>\na\n<span class=\"hljs-comment\">/* Error: Unbound value a */</span>\n</code></pre>\n<p>Voilà pour l'introduction à ReasonML, pour en découvrir un peu plus je vous\ninvite à aller lire la <a href=\"https://reasonml.github.io/\">documentation officielle</a>.\nOn verra dans les prochains articles comment fonctionne\n<a href=\"https://reasonml.github.io/reason-react\">ReasonReact</a> (les bindings Reason vers\nReact, avec quelques petites features sympathiques en plus), et comment\nl'adopter incrémentalement dans sa codebase pour avoir du code plus sûr, et\n<em>(spoilers)</em>, plus rapide que si vous l'écriviez à la main.</p>\n<p>Bisous bisous.</p>\n"}