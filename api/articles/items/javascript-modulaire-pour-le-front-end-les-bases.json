{"slug":"javascript-modulaire-pour-le-front-end-les-bases","filename":"2014-12-15-javascript-modulaire-pour-le-front-end-les-bases","title":"JavaScript modulaire pour le front-end : les bases","date":"Mon, 15 Dec 2014 00:00:00 GMT","draft":false,"meta":{"date":"2014-12-15T00:00:00.000Z","title":"JavaScript modulaire pour le front-end : les bases","author":"syvuilliot","oldSlug":"frontend/2015-etat-lieux-javascript-modulaire","slug":"javascript-modulaire-pour-le-front-end-les-bases"},"body":"<p>Quand on réalise des applications en JS pour les navigateurs web, on ne peut\nplus se contenter de mettre des tags <code>script</code> dans le bon ordre pour charger les\nbibliothèques tierces que l'on utilise comme pour un site web. C'est pourquoi il\nexiste des outils pour permettre d'écrire du JavaScript modulaire et réutiliser\nplus facilement les innombrables bibliothèques publiées par la communauté JS.</p>\n<p>Cependant, ce principe d'écriture modulaire et de publication de code n'étant\npas intégré dans le langage lui-même, de très nombreuses solutions existent plus\nou moins compatibles les unes avec les autres et aboutissant à une forte\nfragmentation de la communauté. Donc quand on décide de se mettre au JavaScript\nmodulaire, on trouve tout un tas d'articles (en anglais) parfois trop vieux\n(&quot;une étape de build n'est pas adaptée au navigateur&quot;), parfois trop subjectifs\n(&quot;J'aime pas la syntaxe AMD&quot;), parfois confus (&quot;utiliser les modules pour de\nl'injection de dépendances&quot;), parfois simplistes (&quot;AMD vs CommonJS&quot;).</p>\n<p>C'est pourquoi j'ai voulu partager mon expérience, en essayant d'abord de\nreposer les bases du problème, puis en vous faisant part de ce que j'estime être\nla solution la plus satisfaisante actuellement.</p>\n<p>D'abord, il faut faire la distinction entre 3 aspects du problème :</p>\n<ul>\n<li>le format d'écriture des modules (&quot;module authoring format&quot;)</li>\n<li>le système de gestion des packages (&quot;package management&quot;)</li>\n<li>la convention de résolution des dépendances de module</li>\n</ul>\n<h1>Format d'écriture des modules</h1>\n<p>Le module est la brique de base pour décomposer un gros fichier JS en plusieurs\nfichiers plus petits et focalisés sur une fonctionnalité précise. La plupart du\ntemps un module est un fichier JS qui fournit une fonction, un constructeur ou\nun objet de valeur. Et comme, pour fournir cette fonctionnalité, un module peut\navoir besoin d'autres modules, il existe un mécanisme pour déclarer ses\ndépendances.</p>\n<p>Actuellement, 2 standards principaux existent pour écrire ces modules : <strong>AMD</strong>\net <strong>CommonJS</strong>. Il est également possible d'utiliser la\n<a href=\"http://www.2ality.com/2014/09/es6-modules-final.html\">syntaxe retenue par ES6</a>\n(qui j'espère va enfin devenir le standard unique) mais pour l'instant, ça\ndemande encore une étape de &quot;transpilation&quot; en AMD ou CJS.</p>\n<p>Le format AMD (dans sa forme la plus courante) est :</p>\n<pre><code class=\"hljs language-js\">define([<span class=\"hljs-string\">&quot;moduleA&quot;</span>, <span class=\"hljs-string\">&quot;moduleB&quot;</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n  <span class=\"hljs-comment\">// j&#x27;utilise a et b</span>\n  <span class=\"hljs-keyword\">return</span> maFonctionTresUtile;\n});\n</code></pre>\n<p>Le format CommonJS (dans sa forme la plus courante) est :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;moduleA&quot;</span>);\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;moduleB&quot;</span>);\n<span class=\"hljs-comment\">// j&#x27;utilise a et b</span>\n<span class=\"hljs-built_in\">module</span>.exports = maFonctionTresUtile;\n</code></pre>\n<p>Ca n'est pas très différent dans l'esprit : tous les 2 permettent de décrire des\ndépendances et d'exporter une valeur. La différence principale réside dans le\nfait que :</p>\n<ul>\n<li>CommonJS prévoit une évaluation en une passe dans laquelle il faut résoudre\nles dépendances au fur et à mesure</li>\n<li>alors que AMD prévoit une évaluation en 2 passes :\n<ul>\n<li>une première pour récupérer uniquement la liste des dépendances</li>\n<li>et une seconde où on exécute le callback (le corps du module) avec les\ndépendances résolues. C'est pourquoi on parle de format &quot;synchrone&quot; dans le\npremier cas et &quot;asynchrone&quot; dans le second car on peut résoudre les\ndépendances de façon asynchrone en AMD.</li>\n</ul></li>\n</ul>\n<p>Dans les 2 cas, par contre, il y a besoin d'une <em>résolution des dépendances</em>,\nc'est à dire qu'un module ne peut pas être exécuté tel quel dans un navigateur\nen le chargeant via un tag <code>script</code>. Non, il faut un <em>loader</em>, c'est à dire un\noutil qui va charger le module qu'on lui demande et va résoudre les dépendances\nen cascade. Mais contrairement à ce que l'on pourrait croire, les règles de\nrésolution des dépendances n'ont rien à voir avec le format du module (on verra\nça plus tard).</p>\n<h1>Package management</h1>\n<p>Parlons maintenant des packages. En effet, pouvoir découper du code en modules,\nc'est bien ; mais ce qui est encore mieux c'est de pouvoir le partager avec\nd'autres pour qu'il soit facilement réutilisable et arrêter le syndrôme de :</p>\n<blockquote>\n<p>&quot;je recode un event emitter dans ma bibliothèque comme ça je n'ai pas de\ndépendance et c'est plus facile à consommer par mes utilisateurs&quot;</p>\n</blockquote>\n<p>C'est le problème n°1 des bibliothèques front qui présentent souvent comme un\nargument de ne pas avoir de dépendances. Sauf que, si on y réfléchit, ça veut\ndire que : soit c'est une bibliothèque très bas niveau, soit le mec a recodé des\ntrucs qui existent déjà au lieu de s'occuper de son sujet principal.</p>\n<p>C'est là qu'entre en jeu la notion de <em>package</em> (que je ne traduirai pas en\nfrançais, car ça ne servirait qu'à apporter de la confusion). Un package est un\nensemble de fichiers (pas forcément des fichiers JS d'ailleurs) avec des\nmétadonnées associées pour décrire principalement :</p>\n<ul>\n<li>où est stocké le package,</li>\n<li>qui est l'auteur,</li>\n<li>quelle est la licence,</li>\n<li>quelle est la version,</li>\n<li>et ... quelles sont les dépendances et leurs versions !</li>\n</ul>\n<p>Ici les dépendances sont des dépendances entre packages,\n<a href=\"http://fr.slideshare.net/domenicdenicola/client-side-packages\">ce qui n'a rien à voir avec les dépendances entre modules</a>.</p>\n<p>Pour faciliter l'utilisation des packages, on utilise un <em>package manager</em>, dont\nle rôle principal est, à partir d'un id de module (et éventuellement d'un numéro\nde version), de trouver l'adresse où se trouve les fichiers, les télécharger et\nles installer localement... et ceci de façon récursive pour les dépendances, ce\nqui est le gros avantage par rapport à le faire à la mano. Mais sinon, ça n'est\npas plus compliqué que ça dans le principe, et ça reste valable pour des\nfichiers JS ou non, front-end ou non.</p>\n<p>Les principaux package managers pour le front-end sont\n<a href=\"https://www.npmjs.com/\">npm</a> et <a href=\"http://bower.io\">bower</a>. La grande différence\nentre les deux est que <strong>npm installe les dépendances de façon relative</strong> : pour\nchaque package, les dépendances sont installées dans un sous-dossier\n(node_modules).</p>\n<ul>\n<li>mon-projet-avec-nmp\n<ul>\n<li>app.js</li>\n<li>node_modules\n<ul>\n<li>une-dependance\n<ul>\n<li>main.js</li>\n<li>nodes_modules\n<ul>\n<li>une-dependance-indirecte\n<ul>\n<li>main.js</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>une-autre-dependance\n<ul>\n<li>main.js</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n<p>Alors que <strong>bower prend le parti d'installer les dépendances à plat</strong> : le\npackage et ses dépendances et les dépendances des dépendances sont toutes\ninstallées au même niveau dans le même dossier.</p>\n<ul>\n<li>mon-projet-avec-bower\n<ul>\n<li>app.js</li>\n<li>bower_components\n<ul>\n<li>une-dependance\n<ul>\n<li>main.js</li>\n</ul></li>\n<li>une-autre-dependance\n<ul>\n<li>main.js</li>\n</ul></li>\n<li>une-dependance-indirecte\n<ul>\n<li>main.js</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n<p>L'approche bower semble être une bonne idée car si 2 packages ont la même\ndépendance (ou des dépendances compatibles semver), une seule est installée.\nAlors qu'avec npm chaque package installe sa propre dépendance.</p>\n<p>Cependant, s'il y a une incompatibilité de versions :</p>\n<blockquote>\n<p>le package A déclare une dépendance sur X en version 1 le package B déclare\nune dépendance sur X mais en version 2</p>\n</blockquote>\n<p>Avec bower, on est coincé : on ne peut installer qu'une seule version. Lors du\n<code>bower install</code>, il faudra choisir quelle version on garde : soit A devra\nutiliser X2, soit B devra utiliser X1.</p>\n<ul>\n<li>mon-app-avec-bower\n<ul>\n<li>bower_components\n<ul>\n<li>package-A</li>\n<li>package-B</li>\n<li>package-X\n<ul>\n<li>main.js // v1 ou v2 mais pas les 2</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n<p>Bower appelle cela de la <em>résolution de conflits</em>. Mais concrêtement, cela veut\ndire qu'on force une dépendance qui n'est pas supportée officiellement par le\npackage en question. Donc on se retrouve responsable de vérifier que le package\nB fonctionne correctement avec X1. Pas cool :-(</p>\n<p>Alors qu'avec npm les versions des dépendances sont respectées, il n'y a pas de\nquestion à se poser.</p>\n<ul>\n<li>mon-app-avec-npm\n<ul>\n<li>node_modules\n<ul>\n<li>package-A\n<ul>\n<li>node_modules\n<ul>\n<li>package-X\n<ul>\n<li>main.js // v1</li>\n</ul></li>\n</ul></li>\n</ul></li>\n<li>package-B\n<ul>\n<li>node_modules\n<ul>\n<li>package-X\n<ul>\n<li>main.js // v2</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n<h1>Résolution des dépendances de module</h1>\n<p>La question est alors :</p>\n<blockquote>\n<p>&quot;Pourquoi existe-t-il des package managers spécifiquement pour le web\nfront-end ?&quot;</p>\n</blockquote>\n<p>Réponse :</p>\n<blockquote>\n<p>&quot;Pour faciliter l'utilisation de modules publiés dans des packages dans le\ncontexte du front-end&quot;</p>\n</blockquote>\n<p>Super ! Mais concrêtement ?</p>\n<p>Et bien, venons en au coeur du problème : <em>la résolution des module-id en\nfichier</em>. Comme on l'a vu, pour charger un module dans le navigateur, il faut\nutiliser un loader. Et une de ses tâches est de <em>résoudre</em> les <code>module_id</code> en\nadresse de fichier.</p>\n<p>Au pire il faudrait explicitement dire au loader pour chaque <code>module_id</code> où est\nle fichier correspondant. Heureusement, ce n'est pas le cas, ni avec requireJS,\nni avec les loaders compatibles npm.</p>\n<h2>AMD</h2>\n<p>RequireJS et les autres loaders AMD vont assez loin en matière de\n<a href=\"http://requirejs.org/docs/api.html#config\">configuration</a> mais souvent , ça\nrevient à décrire des règles du style <em>tous les modules id qui commencent par\n<code>mon-package</code> sont à chercher dans le dossier <code>./mon-package</code></em>.</p>\n<p>En fait, ça n'est pas tout à fait vrai qu'il faille systématiquement configurer\nles règles de résolution avec RequireJS : il y a une règle par défaut qui\nstipule que les module_id sont résolus par rapport à une &quot;baseURL&quot; (qui par\ndéfaut est celle du fichier html). Donc si on installe tous les packages au même\nniveau, ça marche par défaut. C'est pour cela que bower est souvent utilisé pour\nles packages front-end en AMD car il installe les fichiers à plat et de cette\nfaçon on limite le besoin de configuration.</p>\n<h2>NPM</h2>\n<p>A l'opposé de cette approche très flexible, il y a nodeJS avec une\n<a href=\"https://github.com/substack/browserify-handbook#how-node_modules-works\">convention simple et statique</a>,\nqui dit en gros :</p>\n<ul>\n<li>si c'est une référence relative, il suffit de suivre le chemin</li>\n<li>si c'est une référence absolue, il faut chercher dans le dossier\n<code>node_modules</code> et ceci de façon récursive jusqu'à arriver à la racine</li>\n</ul>\n<p>Et donc zéro config, puisque ça n'est pas configurable. Ca peut paraître être\nune limitation mais c'est une force.</p>\n<h1>Conclusion</h1>\n<p>Si tous les packages en AMD utilisaient la règle de résolution par défaut et que\nl'on utilisait bower pour les installer, on n'aurait rien à configurer. Mais\ndans la pratique, ça n'est pas le cas et on se retrouve à devoir configurer les\nrègles de résolution non seulement pour ses propres dépendances (<em>pourquoi pas</em>)\nmais également pour les dépendances de ses dépendances (<em>et là ça ne va plus</em>).\nEt il reste toujours le problème des conflits de version liés à l'approche de\nmettre les dépendances à plat.</p>\n<p>D'un autre côté, il y a la convention nodeJS qui impose des règles simples, non\nmodifiables et qui n'a pas de problème de conflit de versions. C'est à dire\nqu'il suffit de faire <code>npm install mon-package</code> et ça marche. Une convention qui\nfait l'unanimité pour le backend JS.</p>\n<p>Côté front, on lui reproche de charger les dépendances sans les dédoublonner et\nde le faire en synchrone, ce qui n'est pas adapté quand le chargement des\nfichiers se fait via un réseau en http et pas directement depuis un disque local\ncomme sur un serveur.</p>\n<p>C'est pourquoi a été inventé <a href=\"http://http://browserify.org/\">browserify</a> qui\napporte actuellement <a href=\"/fr/articles/js/browserify/\">le meilleur des 2 mondes</a> :\ntoujours zéro config selon la convention nodeJS et un système de bundle/build\n(via une analyse syntaxique du code JS pour détecter les dépendances) afin\nd'assembler tous les modules en un seul fichier adapté au navigateur. On peut\nlui reprocher la nécessité d'une étape de build et le fait que le code source en\ndébug est en un seul fichier mais :</p>\n<ol>\n<li>de toute façon pour la prod, il y aura une étape de build et en dév, avec un\noutillage adapté (par exemple <code>watchify</code> qui rebuild en incrémental) ça\nn'est pas la mer à boire</li>\n<li>avec le support des sources-map dans les navigateurs, on peut maintenant\nretrouver en debug les mêmes noms de fichiers et les mêmes numéro de ligne\nque dans les fichiers d'origine et les points d'arrêt fonctionnent.</li>\n</ol>\n<p>Au final, ça en devient même un avantage, car le code que l'on exécute en dev\ndans le navigateur est très proche de ce que l'on aura en prod, en tout cas plus\nproche qu'avec requireJS pour lequel on développe sans build et pour lequel il\nfaut écrire à nouveau une config de build pour la mise en prod.</p>\n<h1>Conclusion de la conclusion</h1>\n<p>Ma conclusion est que le point crucial pour faciliter la réutilisation de\nmodules, c'est de <strong>minimiser les contraintes sur les utilisateurs</strong> et donc de\nse rapprocher d'un usage <em>plug and play</em>. Pour cela il faut une convention forte\nentre le package manager et le loader/builder de modules, afin d'éviter à\nl'utilisateur de devoir écrire des configs ... la plupart du temps. Bien sûr, la\nrecherche du &quot;zéro config&quot; n'est pas une fin et c'est particulièrement vrai côté\nfront où les contraintes de chargement de fichiers sont fortes. Et si vous\nvoulez diviser votre bundle en plusieurs fichiers ou si vous voulez des règles\nd'optimisation complexes pour votre build, il est normal de devoir mettre les\nmains dans le cambouis. Mais si au moins le cas d'usage le plus fréquent\n(compiler son appli en un seul fichier qui sera chargé via un tag <code>script</code>) est\nsimplifié au maximum, alors on pourra sûrement voir côté front, le même état\nd'esprit que côté back. Et je suis plutôt optimiste,\n<a href=\"https://medium.com/@trek/last-week-i-had-a-small-meltdown-on-twitter-about-npms-future-plans-around-front-end-packaging-b424dd8d367a\">contrairement à certains</a>.</p>\n<p>Utilisateur de la première heure d'<code>AMD</code> et de <code>Dojo loader</code>, puis de <code>bower</code>,\nje me suis rendu compte de leurs limites et surtout j'ai été régulièrement gêné\npar la complexité de la configuration... surtout lorsqu'il fallait passer au\nbuild. Cela freine la réutilisation de modules tiers et c'est dommage. Ce n'est\npas un problème intrinsèque au format de module et toutes les discussions sur\n&quot;moi j'aime / j'aime pas la syntaxe AMD&quot; sont secondaires (d'ailleurs\n<a href=\"https://www.npmjs.com/package/deamdify\">browserify peut fonctionner avec des bibliothèques en AMD</a>).\nMais dans la pratique, nous migrons vers la solution <code>npm + browserify</code> et c'est\nvraiment moins compliqué.</p>\n<p>J'espère que cet article vous permettra d'y voir plus clair, de dépasser les\nquerelles sur les préférences personnelles de chacun, et de vous aider à faire\nvotre choix. Je n'estime pas être un expert du sujet, il y a sûrement beaucoup\nde choses à compléter ou préciser, donc n'hésitez pas à réagir.</p>\n<p>Pour aller plus loin et regarder vers le futur que nous amène ES6, il y a cet\n<a href=\"https://medium.com/@brianleroux/es6-modules-amd-and-commonjs-c1acefbe6fc0\">excellent article</a>.</p>\n"}