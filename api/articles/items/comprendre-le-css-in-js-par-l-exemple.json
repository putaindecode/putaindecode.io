{"slug":"comprendre-le-css-in-js-par-l-exemple","filename":"2019-01-22-comprendre-le-css-in-js-par-l-exemple","title":"Comprendre le CSS in JS par l'exemple","date":"Tue, 22 Jan 2019 00:00:00 GMT","draft":false,"meta":{"date":"2019-01-22T00:00:00.000Z","title":"Comprendre le CSS in JS par l'exemple","author":"zoontek","oldSlug":"js/css-in-js","slug":"comprendre-le-css-in-js-par-l-exemple"},"body":"<p>Il se peut que vous entendiez beaucoup parler de CSS-in-JS dernièrement. C'est\nun sujet de polémique bien connu dans le milieu du front-end actuel : les\nargumentaires tournent en boucle, souvent biaisés par les habitudes et / ou les\nconditions de travail de chaque partie.</p>\n<p>Afin de mieux comprendre ce qu'est le CSS-in-JS, nous allons créer une librairie\nsimilaire à <a href=\"https://emotion.sh/\">Emotion</a> ou\n<a href=\"https://github.com/threepointone/glamor\">Glamor</a>. Au fur et à mesure de la\nréalisation, nous pourrons nous apercevoir qu'il est parfois possible d'améliorer\nl'expérience de développement en prévenant certaines erreurs humaines et en\nautomatisant certaines choses.</p>\n<p>Notre librairie nous permettra d'insérer des styles de façon sûre, de gérer les\npseudo-classes et les pseudo-éléments et de fournir un moyen de gérer le\nresponsive.</p>\n<h2>Initialisation du projet</h2>\n<p>Pour plus de sécurité et de confort, nous allons utiliser\n<a href=\"http://www.typescriptlang.org\">TypeScript</a>. Copiez / collez la commande\nsuivante pour créer et lancer un nouveau projet sobrement intitulé\n<code>putain-de-css</code>.</p>\n<pre><code class=\"hljs language-sh\">npx create-react-app putain-de-css \\\n  &amp;&amp; <span class=\"hljs-built_in\">cd</span> putain-de-css \\\n  &amp;&amp; npm i -D typescript \\\n  &amp;&amp; npm i -S @types/node @types/react-dom @types/react \\\n  &amp;&amp; rm -rf src &amp;&amp; mkdir src \\\n  &amp;&amp; <span class=\"hljs-built_in\">echo</span> \\\n<span class=\"hljs-string\">&#x27;import * as React from &quot;react&quot;;\nimport { render } from &quot;react-dom&quot;;\n\nconst App = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;\nrender(&lt;App /&gt;, document.getElementById(&quot;root&quot;));&#x27;</span> \\\n&gt; src/index.tsx \\\n  &amp;&amp; npm start\n</code></pre>\n<p>Ouvrez votre éditeur de code préféré, on attaque directement en créant un\nnouveau fichier <code>src/css.ts</code>.</p>\n<h2>Insertion de style sous la forme de string</h2>\n<p>La première chose à faire pour pouvoir insérer des styles au sein du CSSOM,\nc'est de créer un élément DOM <code>&lt;style&gt;</code> dans le <code>&lt;head&gt;</code> de notre document, puis\nde récupérer l'objet de type <code>CSSStyleSheet</code> qui lui est attaché.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">const</span> styleEl = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&quot;style&quot;</span>);\nstyleEl.appendChild(<span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-string\">&quot;&quot;</span>));\n<span class=\"hljs-built_in\">document</span>.head.appendChild(styleEl);\n\n<span class=\"hljs-keyword\">const</span> sheet = styleEl.sheet <span class=\"hljs-keyword\">as</span> CSSStyleSheet;\n</code></pre>\n<p>À la suite, nous allons créer une fonction simple qui insère une règle CSS et\nnous prévient des règles malformées en développement. Pour rappel, une règle est\nconstituée de la façon suivante :\n<code>selector { property: value; property: value; … }</code>).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertRule</span>(<span class=\"hljs-params\">rule: string</span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    sheet.insertRule(rule);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Malformated CSS: &quot;<span class=\"hljs-subst\">${rule}</span>&quot;`</span>);\n    }\n  }\n}\n</code></pre>\n<p>Nous pouvons dès à présent importer cette fonction au sein de notre fichier\n<code>index.tsx</code> et tenter plusieurs essais.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { insertRule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-comment\">// testons d&#x27;abord:</span>\ninsertRule(<span class=\"hljs-string\">&quot;h1 { color: hotpink }&quot;</span>);\n<span class=\"hljs-comment\">// puis:</span>\ninsertRule(<span class=\"hljs-string\">&quot;1nvalid! { color: red }&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/1.png\" alt=\"résultat avec un style objet\" />\n  <figcaption>Quand tout va bien</figcaption>\n</figure>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/2.png\" alt=\"résultat avec un style objet\" />\n  <figcaption>Quand tu tapes n'importe quoi</figcaption>\n</figure>\n<h2>Insertion de style sous la forme d'objets</h2>\n<p>Écrire nos règles sous la forme de string est plutôt risqué : la chaîne de\ncaractère sera complexe à parser et à analyser. Nous nous exposons donc à\ncertains risques si nous ne pensons pas à prévoir certains cas.</p>\n<p>De plus, si une équipe de développeurs peut insérer absolument tout ce qu'elle\nsouhaite dans la feuille de style, elle pourra donc utiliser l'intégralité des\nsélecteurs CSS. Il faudrait donc faire appel à beaucoup de rigueur ou se reposer\nsur plusieurs outils supplémentaires (extensions IDE, linter, etc.).</p>\n<p>Nous allons donc créer une fonction supplémentaire pour transformer un objet en\nrègle insérable et dont le sélecteur sera un nom de classe généré et unique.</p>\n<p>Nous allons également créer quelques types assez basiques en haut de notre\nfichier.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-comment\">// &quot;Value&quot; peut être de type string OU number</span>\ntype Value = string | number;\n\n<span class=\"hljs-comment\">// &quot;Style&quot; est un objet dont les valeurs sont de type Value</span>\n<span class=\"hljs-keyword\">export</span> type Style = {\n  [name: string]: Value,\n};\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-built_in\">Object</span>.keys(style)\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>: <span class=\"hljs-subst\">${style[name]}</span>`</span>)\n    .join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n\n  insertRule(<span class=\"hljs-string\">`h1 { <span class=\"hljs-subst\">${content}</span> }`</span>);\n}\n</code></pre>\n<p>À ce point, vous pouvez importer <code>insertStyle</code> et vous en servir, vous\nconstaterez que cela a l'effet escompté… sur notre <code>h1</code> pour le moment.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { insertStyle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\ninsertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-string\">&quot;text-decoration&quot;</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n});\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/3.png\" alt=\"résultat avec un style objet\" />\n</figure>\n<p>Afin de créer un nom de classe unique, il nous faut hacher notre règle CSS. Cela\nconsiste à transformer la donnée entrée en &quot;empreinte&quot; permettant d'identifier\ncelle-ci. Ainsi, deux objets au contenu identique et ordonnés de la même façon\nauront tous deux la même empreinte. L'objectif étant que si plusieurs objets de\nstyle possèdent un contenu identique, celui-ci ne sera inséré d'une seule fois.</p>\n<p>Une fonction de hashage qui nous conviendrait est le <code>murmurhash2</code> disponible\nsur <code>npm</code>.</p>\n<pre><code class=\"hljs language-sh\">npm i -S murmurhash @types/murmurhash\n</code></pre>\n<p>Nous pouvons dès à présent générer un nom de classe en fonction du contenu de\nnotre règle CSS.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> murmurhash <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;murmurhash&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hash</span>(<span class=\"hljs-params\">str: string</span>) </span>{\n  <span class=\"hljs-comment\">// on retourne un string encodé en base 36</span>\n  <span class=\"hljs-keyword\">return</span> murmurhash.v2(str, <span class=\"hljs-number\">1</span>).toString(<span class=\"hljs-number\">36</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-built_in\">Object</span>.keys(style)\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>: <span class=\"hljs-subst\">${style[name]}</span>`</span>)\n    .join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(content);\n  insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span> { <span class=\"hljs-subst\">${content}</span> }`</span>);\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>Et même l'appliquer sur notre composant React / élément HTML / ce que vous\nvoulez !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { insertStyle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-string\">&quot;text-decoration&quot;</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n});\n\n<span class=\"hljs-comment\">// on applique la classe créée</span>\n<span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{className}</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/4.png\" alt=\"résultat avec nom de classe généré\" />\n</figure>\n<h2>Propriétés en lowerCamelCase</h2>\n<p>Créons une nouvelle fonction juste avant <code>insertStyle</code>. Celle-ci va remplacer\ntoutes les majuscules de notre paramètre de type <code>string</code> par un hyphen + sa\nminuscule.</p>\n<p>Elle gère également le cas un peu spécial des préfixes Microsoft (qui ne\ncommencent pas par une majuscule, contrairement à ceux de Mozilla / WebKit).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// expected outputs:</span>\n<span class=\"hljs-comment\">// fontFamily -&gt; font-family</span>\n<span class=\"hljs-comment\">// MozTransform -&gt; -moz-transform</span>\n<span class=\"hljs-comment\">// msTransform -&gt; -ms-transform</span>\n<span class=\"hljs-comment\">// WebkitTransform -&gt; -webkit-transform</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hyphenateName</span>(<span class=\"hljs-params\">name: string</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> name\n    .replace(<span class=\"hljs-regexp\">/([A-Z])/g</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">_, letter</span>) =&gt;</span> <span class=\"hljs-string\">`-<span class=\"hljs-subst\">${letter.toLowerCase()}</span>`</span>)\n    .replace(<span class=\"hljs-regexp\">/^ms-/</span>, <span class=\"hljs-string\">&quot;-ms-&quot;</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-built_in\">Object</span>.keys(style)\n    <span class=\"hljs-comment\">// on ajoute l&#x27;hyphenation du nom ici</span>\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${hyphenateName(name.trim())}</span>: <span class=\"hljs-subst\">${style[name]}</span>`</span>)\n    .join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(content);\n  insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span> { <span class=\"hljs-subst\">${content}</span> }`</span>);\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>En modifiant notre appel à <code>insertStyle</code> dans <code>index.tsx</code>, on s'aperçoit que\ntout fonctionne comme espéré.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>, <span class=\"hljs-comment\">// plus d&#x27;hyphens!</span>\n});\n\n<span class=\"hljs-comment\">//…</span>\n</code></pre>\n<h2>Gestion des valeurs de fallback</h2>\n<p>Parce qu'en CSS il est possible de faire:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">display</span>: <span class=\"hljs-selector-tag\">-webkit-flex</span>;\n<span class=\"hljs-selector-tag\">display</span>: <span class=\"hljs-selector-tag\">-moz-flex</span>;\n<span class=\"hljs-selector-tag\">display</span>: <span class=\"hljs-selector-tag\">flex</span>;\n</code></pre>\n<p>Mais que la nature des objets JavaScript ne nous le permet pas (impossible\nd'avoir plusieurs clés identiques), il nous faut pouvoir prendre un tableau en\nvaleur.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">//…</span>\n\n<span class=\"hljs-comment\">// on commence par modifier le type Value</span>\ntype Value = string | number | <span class=\"hljs-built_in\">Array</span>&lt;string | number&gt;;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on externalise la &quot;cssification&quot; en 2 fonctions</span>\n\n<span class=\"hljs-comment\">// cssifyDeclaration retourne &quot;nom: valeur&quot; si la valeur est correcte</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cssifyDeclaration</span>(<span class=\"hljs-params\">name: string, value: any</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (\n    (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&quot;string&quot;</span> &amp;&amp; value !== <span class=\"hljs-string\">&quot;&quot;</span>) ||\n    (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&quot;number&quot;</span> &amp;&amp; <span class=\"hljs-built_in\">isFinite</span>(value))\n  ) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>: <span class=\"hljs-subst\">${(value + <span class=\"hljs-string\">&quot;&quot;</span>).trim()}</span>`</span>;\n  }\n}\n\n<span class=\"hljs-comment\">// compactDeclarations filtre les falsy values et compacte le reste avec &quot;; &quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">compactDeclarations</span>(<span class=\"hljs-params\">declarations: (string | <span class=\"hljs-literal\">undefined</span>)[]</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> declarations.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">declaration</span> =&gt;</span> !!declaration).join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> declarations = <span class=\"hljs-built_in\">Object</span>.keys(style).map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> hName = hyphenateName(name).trim();\n    <span class=\"hljs-keyword\">const</span> value = style[name];\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.isArray(value)\n      ? compactDeclarations(value.map(<span class=\"hljs-function\"><span class=\"hljs-params\">fbv</span> =&gt;</span> cssifyDeclaration(hName, fbv)))\n      : cssifyDeclaration(hName, value);\n  });\n\n  <span class=\"hljs-keyword\">const</span> content = compactDeclarations(declarations);\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(content);\n  insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span> { <span class=\"hljs-subst\">${content}</span> }`</span>);\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>Si on modifie le style appliqué sur notre <code>&lt;h1&gt;</code> de cette façon :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n  <span class=\"hljs-attr\">display</span>: [<span class=\"hljs-string\">&quot;-webkit-flex&quot;</span>, <span class=\"hljs-string\">&quot;-moz-flex&quot;</span>, <span class=\"hljs-string\">&quot;flex&quot;</span>],\n});\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<p>On constate que le navigateur ne nous indique pas que 3 valeurs ont été insérées\n(en barrant celles qui ne sont pas appliquées).</p>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/5.png\" alt=\"inspection des styles préfixés\" />\n</figure>\n<p>En effet, lorsque vous utilisez <code>insertRule</code>, seule la dernière valeur comprise\npar le navigateur est réellement insérée. Ainsi, si on change la valeur de\n<code>display</code> pour <code>[&quot;flex&quot;, &quot;-webkit-flex&quot;, &quot;-moz-flex&quot;]</code>, vous verrez que seul\n<code>-webkit-flex</code> sera appliqué (si bien sûr vous utilisez un navigateur qui\ncomprend les préfixes WebKit mais pas les préfixes Mozilla).</p>\n<h2>Gestion des pseudo-classes / éléments</h2>\n<p>L'idée c'est de les déclarer directement au sein de notre déclaration de style,\nsi possible de façon infiniment nestés.</p>\n<p>On modifie donc l'exemple pour visualiser le but à atteindre :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n\n  <span class=\"hljs-string\">&quot;:hover&quot;</span>: {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;rebeccapurple&quot;</span>,\n\n    <span class=\"hljs-string\">&quot;::first-letter&quot;</span>: {\n      <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;cyan&quot;</span>,\n    },\n  },\n});\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<p>Idéalement, il nous faudrait une fonction qui aplatisse ce style par suffixe\nappliqué à notre classe, de cette façon :</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">&quot;&quot;</span>: <span class=\"hljs-string\">&quot;color: pink; text-decoration: underline&quot;</span>,\n  <span class=\"hljs-string\">&quot;:hover&quot;</span>: <span class=\"hljs-string\">&quot;color: rebeccapurple&quot;</span>,\n  <span class=\"hljs-string\">&quot;:hover::first-letter&quot;</span>: <span class=\"hljs-string\">&quot;color: cyan&quot;</span>,\n};\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on modifie le type Style</span>\n<span class=\"hljs-keyword\">export</span> type Style = {\n  [name: string]: Value | Style,\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isPlainObject</span>(<span class=\"hljs-params\">value: any</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(value) === <span class=\"hljs-string\">&quot;[object Object]&quot;</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flattenStyle</span>(<span class=\"hljs-params\">style: Style, suffix: string = <span class=\"hljs-string\">&quot;&quot;</span></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> result: { [suffix: string]: string | <span class=\"hljs-literal\">undefined</span> } = {\n    <span class=\"hljs-comment\">// on s&#x27;assure que le sélecteur &quot;racine&quot; est le premier inséré</span>\n    [suffix]: <span class=\"hljs-literal\">undefined</span>,\n  };\n\n  <span class=\"hljs-comment\">// on extrait la logique qui était précedemment dans insertStyle</span>\n  <span class=\"hljs-keyword\">const</span> declarations = <span class=\"hljs-built_in\">Object</span>.keys(style).map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> value = style[name];\n\n    <span class=\"hljs-keyword\">if</span> (isPlainObject(value)) {\n      <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n        <span class=\"hljs-comment\">// on peaufine un peu la DX (et on évite quelques edge-cases)</span>\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-regexp\">/^::?(-webkit-|-moz-|-ms-)?[a-z][a-z-]+(\\(.+\\))?$/</span>.test(name)) {\n          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Invalid pseudo class / element: &quot;<span class=\"hljs-subst\">${name}</span>&quot;`</span>);\n        }\n      }\n\n      <span class=\"hljs-keyword\">const</span> nested = flattenStyle(value <span class=\"hljs-keyword\">as</span> Style, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${suffix}</span><span class=\"hljs-subst\">${name}</span>`</span>);\n\n      <span class=\"hljs-built_in\">Object</span>.keys(nested).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">nName</span> =&gt;</span> {\n        result[nName] = nested[nName];\n      });\n    } <span class=\"hljs-keyword\">else</span> {\n\n      <span class=\"hljs-keyword\">const</span> hName = hyphenateName(name).trim();\n\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.isArray(value)\n        ? compactDeclarations(value.map(<span class=\"hljs-function\"><span class=\"hljs-params\">fbv</span> =&gt;</span> cssifyDeclaration(hName, fbv)))\n        : cssifyDeclaration(hName, value);\n    }\n  });\n\n  result[suffix] = compactDeclarations(declarations);\n  <span class=\"hljs-keyword\">return</span> result;\n}\n</code></pre>\n<p>Si on passe notre style dans cette fonction <code>flattenStyle</code> afin d'en analyser la\nsortie, on constate qu'elle fait exactement ce que l'on souhaite.</p>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/6.png\" alt=\"valeur retournée par la fonction flattenStyle\" />\n</figure>\n<p>Il ne nous reste qu'à hasher la représentation de cet objet et insérer les\nrègles une par une.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flattened = flattenStyle(style);\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(<span class=\"hljs-built_in\">JSON</span>.stringify(flattened));\n\n  <span class=\"hljs-built_in\">Object</span>.keys(flattened).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">suffix</span> =&gt;</span> {\n    insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span><span class=\"hljs-subst\">${suffix}</span> { <span class=\"hljs-subst\">${flattened[suffix]}</span> }`</span>);\n  });\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/7.png\" alt=\"résultat avec gestion du hover\" />\n</figure>\n<h2>Concaténation de styles</h2>\n<p>Une pratique assez répandue est d'appliquer conditionnellement plusieurs objets\nstyles en fonction de l'état de nos composants.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ce genre de chose</span>\ncss(styles.base, <span class=\"hljs-built_in\">this</span>.props.disabled &amp;&amp; styles.disabled);\n</code></pre>\n<p>Supprimez tous les exports de fonction du fichier <code>css.ts</code>, nous n'allons en\ngarder qu'un seul, celui par défaut : cette fameuse fonction <code>css</code> !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> type MaybeStyle = Style | <span class=\"hljs-literal\">false</span> | <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// renommez la fonction ìnsertStyle</span>\n<span class=\"hljs-comment\">// elle accepte à présent des styles, mais aussi des &quot;falsy values&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">css</span>(<span class=\"hljs-params\">...styles: MaybeStyle[]</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flattened = styles\n    <span class=\"hljs-comment\">// on ne garde que les objets</span>\n    .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> isPlainObject(style))\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> flattenStyle(style))\n    .reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">flat, style</span>) =&gt;</span> {\n      <span class=\"hljs-built_in\">Object</span>.keys(style).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">suffix</span> =&gt;</span> {\n        flat[suffix] = flat[suffix]\n          ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${flat[suffix]}</span>; <span class=\"hljs-subst\">${style[suffix]}</span>`</span>\n          : style[suffix];\n      });\n      <span class=\"hljs-keyword\">return</span> flat;\n    }, {});\n\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(<span class=\"hljs-built_in\">JSON</span>.stringify(flattened));\n\n  <span class=\"hljs-built_in\">Object</span>.keys(flattened).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">suffix</span> =&gt;</span> {\n    insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span><span class=\"hljs-subst\">${suffix}</span> { <span class=\"hljs-subst\">${flattened[suffix]}</span> }`</span>);\n  });\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>Je vous laisse ça afin de faire un test rapide:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> css <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> className = css(\n  {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n    <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n\n    <span class=\"hljs-string\">&quot;:hover&quot;</span>: {\n      <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;rebeccapurple&quot;</span>,\n    },\n  },\n  {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;red&quot;</span>,\n\n    <span class=\"hljs-string\">&quot;:hover&quot;</span>: {\n      <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;blue&quot;</span>,\n    },\n  },\n);\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<h2>Autoprefixing</h2>\n<p>Il est temps de peaufiner un peu l'expérience de développement. Si je vous dit\nqu'on a implémenté toutes les features nécessaires pour utiliser l'équivalent\nd'un autoprefixer (qui préfixe automatiquatiquement les propriétés pour un\nmeilleur support navigateur)?</p>\n<p>Il s'agit d'<a href=\"https://inline-style-prefixer.js.org\">inline-style-prefixer</a>.</p>\n<pre><code class=\"hljs language-sh\">npm i -S inline-style-prefixer @types/inline-style-prefixer\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { prefix } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;inline-style-prefixer&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">css</span>(<span class=\"hljs-params\">...styles: Style[]</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flattened = styles\n    .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> isPlainObject(style))\n    <span class=\"hljs-comment\">// on ajoute l&#x27;appel ici</span>\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> flattenStyle(prefix(style) <span class=\"hljs-keyword\">as</span> Style))\n    <span class=\"hljs-comment\">// …</span>\n</code></pre>\n<p>Et c'est tout! 😀</p>\n<h2>Autocomplétion</h2>\n<p>Le CSS-in-JS, ça peut vous rebuter quand on voit le tooling actuellement\ndisponible pour le CSS. L'autocomplétion dans les éditeurs de texte est quali,\nça serait bien d'avoir quelque chose de similaire… Ça tombe bien, nous utilisons\nun langage typé.</p>\n<pre><code class=\"hljs language-sh\">npm i -S csstype\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { PropertiesFallback, SimplePseudos } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;csstype&quot;</span>;\n\n<span class=\"hljs-comment\">//…</span>\n\n<span class=\"hljs-comment\">// remplacez Style par ceci</span>\n<span class=\"hljs-keyword\">export</span> type Style = PropertiesFallback &amp;\n  { [pseudo <span class=\"hljs-keyword\">in</span> SimplePseudos]?: PropertiesFallback };\n\n<span class=\"hljs-comment\">// on en profite pour ajouter un type StyleSheet</span>\n<span class=\"hljs-keyword\">export</span> type StyleSheet = { [key: string]: Style };\n\n<span class=\"hljs-comment\">// …</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flattenStyle</span>(<span class=\"hljs-params\">style: Style, suffix: string = <span class=\"hljs-string\">&quot;&quot;</span></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> result: { [suffix: string]: string | <span class=\"hljs-literal\">undefined</span> } = {\n    [suffix]: <span class=\"hljs-literal\">undefined</span>,\n  };\n\n  <span class=\"hljs-keyword\">const</span> declarations = <span class=\"hljs-built_in\">Object</span>.keys(style).map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> value = (style <span class=\"hljs-keyword\">as</span> any)[name] <span class=\"hljs-keyword\">as</span> Value; <span class=\"hljs-comment\">// on force le type ici</span>\n    <span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/8.png\" alt=\"démo de l'autocomplétion\" />\n</figure>\n<h2>Performances</h2>\n<p>Comme vous vous en doutez, pour le moment notre lib n'est pas un foudre de\nguerre : aucun système de cache n'est présent. Comme on désire tout de même\nbriller dans les benchmarks, tâchons d'optimiser ça.</p>\n<p>Pour cela on va utiliser la mémoïsation (on utilise lodash par commodité, mais\non peut faire plus léger).</p>\n<p>Pour ceux qui ne sont pas familiers avec le concept, cela nous permet de wrapper\nune fonction. Lors du premier appel, la fonction est appelée normalement, son\nrésultat est stocké dans un objet. Lors des appels suivants, les calculs ne\nseront plus effectués, le résultat en cache sera directement retourné.</p>\n<pre><code class=\"hljs language-sh\">npm i -S lodash.memoize @types/lodash.memoize\n</code></pre>\n<p>Trève de bavardages, on importe ça dans notre fichier <code>css.ts</code> et on optimise 😄</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> memoize <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;lodash.memoize&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on peut mémoïser la fonction hyphenateName de façon à</span>\n<span class=\"hljs-comment\">// ce que chaque règle ne soit convertie qu&#x27;une seule fois</span>\n<span class=\"hljs-keyword\">const</span> hyphenateName = memoize(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> name\n    .replace(<span class=\"hljs-regexp\">/([A-Z])/g</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">_, letter</span>) =&gt;</span> <span class=\"hljs-string\">`-<span class=\"hljs-subst\">${letter.toLowerCase()}</span>`</span>)\n    .replace(<span class=\"hljs-regexp\">/^ms-/</span>, <span class=\"hljs-string\">&quot;-ms-&quot;</span>);\n});\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on retire le export default</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">css</span>(<span class=\"hljs-params\">...styles: Style[]</span>) </span>{\n  <span class=\"hljs-comment\">// …</span>\n}\n\n<span class=\"hljs-comment\">// on exporte par défaut la fonction mémoïsée</span>\n<span class=\"hljs-comment\">// le deuxième argument sert à générer une clé pour l&#x27;élément en cache</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> memoize(css, <span class=\"hljs-function\">(<span class=\"hljs-params\">...styles</span>) =&gt;</span> <span class=\"hljs-built_in\">JSON</span>.stringify(styles));\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/9.png\" alt=\"benchmark avant optimisation\" />\n  <figcaption>Avant mémoïsation</figcaption>\n</figure>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/10.png\" alt=\"benchmark après optimisation\" />\n  <figcaption>Après mémoïsation</figcaption>\n</figure>\n<p>À savoir qu'il existe d'autres techniques de caching, notamment à base de\n<code>WeakMap</code>.</p>\n<h1>Intégration avec React</h1>\n<p>Parce qu'on adore React chez P!, je ne peux m'empêcher de conclure sans vous\nmontrer comment utiliser au mieux cette lib avec React. Créez un fichier\n<code>react.tsx</code>, c'est parti !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/react.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> cssFn, { MaybeStyle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-comment\">// on augmente les types des éléments DOM</span>\ndeclare <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&quot;react&quot;</span> {\n  interface HTMLAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n  }\n\n  interface SVGAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n  }\n}\n\n<span class=\"hljs-comment\">// on override la fonction createElement de React</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>&lt;\n  <span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> </span>{\n    css?: MaybeStyle | MaybeStyle[];\n    className?: string;\n  }\n&gt;(\n  Component: React.ComponentType&lt;P&gt; | string,\n  <span class=\"hljs-attr\">props</span>: P,\n  ...children: React.ReactElement&lt;any&gt;[]\n) {\n  <span class=\"hljs-comment\">// si le composant n&#x27;est pas un tag HTML ou qu&#x27;il</span>\n  <span class=\"hljs-comment\">// ne possède pas de prop CSS, on ne fait rien</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Component !== <span class=\"hljs-string\">&quot;string&quot;</span> || !props.css) {\n    <span class=\"hljs-keyword\">return</span> React.createElement(Component, props, ...children);\n  }\n\n  <span class=\"hljs-keyword\">const</span> { css, className, ...rest } = props;\n\n  <span class=\"hljs-comment\">// on transforme notre style en className, on l&#x27;ajoute</span>\n  <span class=\"hljs-comment\">// à la suite du className existant (si il existe)</span>\n  <span class=\"hljs-keyword\">const</span> newClassName =\n    (className ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${className}</span> `</span> : <span class=\"hljs-string\">&quot;&quot;</span>) +\n    (<span class=\"hljs-built_in\">Array</span>.isArray(css) ? cssFn(...css) : cssFn(css));\n\n  <span class=\"hljs-keyword\">return</span> React.createElement(\n    Component,\n    { ...rest, <span class=\"hljs-attr\">className</span>: newClassName },\n    ...children,\n  );\n}\n</code></pre>\n<p>Comment on se sert de tout ça ? Facile : on retourne dans le fichier\n<code>index.tsx</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { StyleSheet } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createElement } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./react&quot;</span>;\n<span class=\"hljs-comment\">/* @jsx createElement */</span>\n\n<span class=\"hljs-comment\">// puisque TS supprime l&#x27;import s&#x27;il ne sert que pour le pragma JSX,</span>\n<span class=\"hljs-comment\">// on laisse trainer la valeur. Pas idéal, mais ça fait le taf.</span>\n<span class=\"hljs-comment\">// voir https://github.com/babel/babel/issues/8958</span>\ncreateElement;\n\n<span class=\"hljs-keyword\">const</span> styles: StyleSheet = {\n  <span class=\"hljs-attr\">base</span>: {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n    <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n  },\n  <span class=\"hljs-attr\">fancy</span>: {\n    <span class=\"hljs-string\">&quot;::first-letter&quot;</span>: {\n      <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">&quot;2em&quot;</span>,\n    },\n  },\n};\n\ntype State = {\n  <span class=\"hljs-attr\">isFancy</span>: boolean,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{}, State&gt; {\n  state = {\n    <span class=\"hljs-attr\">isFancy</span>: <span class=\"hljs-literal\">false</span>,\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">css</span>=<span class=\"hljs-string\">{[styles.base,</span> <span class=\"hljs-attr\">this.state.isFancy</span> &amp;&amp; <span class=\"hljs-attr\">styles.fancy</span>]}&gt;</span>\n          Hello world\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n            this.setState(prevState =&gt; ({ isFancy: !prevState.isFancy }));\n          }}\n        &gt;\n          Toggle fancy mode\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/11.gif\" alt=\"résultat de l'exemple\" />\n</figure>\n<p>Si vous êtes fan de <code>styled-components</code> (personnellement je déteste ça, mais\nchacun son truc), il est extrêmement simple de recréer une API similaire :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/react.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">styled</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">string</span>, <span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>&gt;(<span class=\"hljs-params\">\n  Component: T,\n  style: Style | ((props: P) =&gt; Style),\n</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: P &amp; React.HTMLProps&lt;T&gt;</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { children, ...rest } = props;\n    <span class=\"hljs-keyword\">const</span> css = <span class=\"hljs-keyword\">typeof</span> style === <span class=\"hljs-string\">&quot;function&quot;</span> ? style(props) : style;\n\n    <span class=\"hljs-keyword\">return</span> createElement(\n      Component,\n      { ...rest, css },\n      ...(children <span class=\"hljs-keyword\">as</span> React.ReactElement&lt;any&gt;[]),\n    );\n  };\n}\n</code></pre>\n<p>(Oui, c'est tout 🤭)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { styled } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./react&quot;</span>;\n\n<span class=\"hljs-comment\">// notre typage de props est mergé avec le typage de l&#x27;élément h1</span>\n<span class=\"hljs-keyword\">const</span> Title = styled(<span class=\"hljs-string\">&quot;h1&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">props: { fancy?: boolean }</span>) =&gt;</span> ({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n\n  ...(props.fancy &amp;&amp; {\n    <span class=\"hljs-string\">&quot;::first-letter&quot;</span>: {\n      <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">&quot;2em&quot;</span>,\n    },\n  }),\n}));\n\ntype State = {\n  <span class=\"hljs-attr\">isFancy</span>: boolean,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{}, State&gt; {\n  state = {\n    <span class=\"hljs-attr\">isFancy</span>: <span class=\"hljs-literal\">false</span>,\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Title</span> <span class=\"hljs-attr\">fancy</span>=<span class=\"hljs-string\">{this.state.isFancy}</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Title</span>&gt;</span>\n        {/* … */}\n</span></code></pre>\n<h2>Gérer le responsive</h2>\n<p>Les media-queries c'est pas mal, mais au sein d'une approche composant,\nappliquer des styles par rapport aux dimensions de la totalité du viewport,\nc'est fort dommage.</p>\n<p>Nous allons donc utiliser\n<a href=\"https://developers.google.com/web/updates/2016/10/resizeobserver\"><code>ResizeObserver</code></a>.\nLe support n'est pas fou (uniquement Chrome à l'heure où j'écris ces lignes),\nmais heureusement un polyfill existe.</p>\n<pre><code class=\"hljs language-sh\">npm i -S resize-observer-polyfill\n</code></pre>\n<p>On retourne dans le fichier <code>react.tsx</code>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/react.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> ResizeObserver <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;resize-observer-polyfill&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\ntype OnResizeCallBack = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  dimensions: {\n    height: number;\n    width: number;\n  },\n</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>;\n\ndeclare <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&quot;react&quot;</span> {\n  interface HTMLAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n    onResize?: OnResizeCallBack; <span class=\"hljs-comment\">// on ajoute le callback en prop</span>\n  }\n\n  interface SVGAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n    onResize?: OnResizeCallBack;\n  }\n}\n\n<span class=\"hljs-comment\">// on va stocker les callbacks par élément HTML</span>\n<span class=\"hljs-keyword\">const</span> callbacks: <span class=\"hljs-built_in\">Map</span>&lt;Element, OnResizeCallBack&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\n\n<span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> ResizeObserver(<span class=\"hljs-function\"><span class=\"hljs-params\">entries</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> entry <span class=\"hljs-keyword\">of</span> entries) {\n    <span class=\"hljs-keyword\">const</span> callback = callbacks.get(entry.target);\n\n    <span class=\"hljs-keyword\">if</span> (callback) {\n      <span class=\"hljs-keyword\">const</span> { height, width } = entry.contentRect;\n      callback({ height, width });\n    }\n  }\n});\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Resizable</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">ref: React.RefObject&lt;Element&gt;</span>) =&gt;</span> React.ReactElement&lt;any&gt;;\n  onResize: OnResizeCallBack;\n}&gt; {\n   <span class=\"hljs-comment\">// il est aussi possible d&#x27;utiliser forwardRef</span>\n  <span class=\"hljs-attr\">ref</span>: React.RefObject&lt;Element&gt; = React.createRef();\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.ref.current) {\n      callbacks.set(<span class=\"hljs-built_in\">this</span>.ref.current, <span class=\"hljs-built_in\">this</span>.props.onResize);\n      observer.observe(<span class=\"hljs-built_in\">this</span>.ref.current);\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.ref.current &amp;&amp; callbacks.has(<span class=\"hljs-built_in\">this</span>.ref.current)) {\n      callbacks.delete(<span class=\"hljs-built_in\">this</span>.ref.current);\n      observer.unobserve(<span class=\"hljs-built_in\">this</span>.ref.current);\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.render(<span class=\"hljs-built_in\">this</span>.ref);\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>&lt;\n  <span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> </span>{\n    css?: MaybeStyle | MaybeStyle[];\n    className?: string;\n    onResize?: OnResizeCallBack;\n  }\n&gt;(\n  Component: React.ComponentType&lt;P&gt; | string,\n  <span class=\"hljs-attr\">props</span>: P,\n  ...children: React.ReactElement&lt;any&gt;[]\n) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Component !== <span class=\"hljs-string\">&quot;string&quot;</span> || !props.css) {\n    <span class=\"hljs-keyword\">return</span> React.createElement(Component <span class=\"hljs-keyword\">as</span> any, props, ...children);\n  }\n\n  <span class=\"hljs-keyword\">const</span> { css, className, onResize, ...rest } = props;\n\n  <span class=\"hljs-keyword\">const</span> newClassName =\n    (className ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${className}</span> `</span> : <span class=\"hljs-string\">&quot;&quot;</span>) +\n    (<span class=\"hljs-built_in\">Array</span>.isArray(css) ? cssFn(...css) : cssFn(css));\n\n  <span class=\"hljs-keyword\">if</span> (onResize) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Resizable</span>\n        <span class=\"hljs-attr\">onResize</span>=<span class=\"hljs-string\">{onResize}</span>\n        <span class=\"hljs-attr\">render</span>=<span class=\"hljs-string\">{ref</span> =&gt;</span>\n          React.createElement(\n            Component,\n            { ...rest, ref, className: newClassName },\n            ...children,\n          )\n        }\n      /&gt;</span>\n    );\n  }\n\n  <span class=\"hljs-keyword\">return</span> React.createElement(\n    Component,\n    { ...rest, <span class=\"hljs-attr\">className</span>: newClassName },\n    ...children,\n  );\n}\n</code></pre>\n<p>Et pour ce qui est de l'usage:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { StyleSheet } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createElement } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./react&quot;</span>;\n<span class=\"hljs-comment\">/* @jsx createElement */</span>\ncreateElement; <span class=\"hljs-comment\">// fix pour TS</span>\n\n<span class=\"hljs-keyword\">const</span> styles: StyleSheet = {\n  <span class=\"hljs-attr\">base</span>: {\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-string\">&quot;300px&quot;</span>,\n    <span class=\"hljs-attr\">maxWidth</span>: <span class=\"hljs-string\">&quot;300px&quot;</span>,\n  },\n  <span class=\"hljs-attr\">small</span>: {\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">&quot;rebeccapurple&quot;</span>,\n  },\n};\n\ntype State = {\n  <span class=\"hljs-attr\">width</span>: number | <span class=\"hljs-literal\">null</span>,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{}, State&gt; {\n  state = { <span class=\"hljs-attr\">width</span>: <span class=\"hljs-literal\">null</span> };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> { width } = <span class=\"hljs-built_in\">this</span>.state;\n\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">css</span>=<span class=\"hljs-string\">{[</span>\n          <span class=\"hljs-attr\">styles.base</span>,\n          // <span class=\"hljs-attr\">on</span> <span class=\"hljs-attr\">cache</span> <span class=\"hljs-attr\">l</span>&#x27;é<span class=\"hljs-attr\">l</span>é<span class=\"hljs-attr\">ment</span> <span class=\"hljs-attr\">tant</span> <span class=\"hljs-attr\">que</span> <span class=\"hljs-attr\">ses</span> <span class=\"hljs-attr\">dimensions</span> <span class=\"hljs-attr\">ne</span> <span class=\"hljs-attr\">sont</span> <span class=\"hljs-attr\">pas</span> <span class=\"hljs-attr\">dispos</span>\n          <span class=\"hljs-attr\">width</span> ? <span class=\"hljs-attr\">width</span> &lt; <span class=\"hljs-attr\">200</span> &amp;&amp; <span class=\"hljs-attr\">styles.small</span> <span class=\"hljs-attr\">:</span> { <span class=\"hljs-attr\">visibility:</span> &quot;<span class=\"hljs-attr\">hidden</span>&quot; },\n        ]}\n        <span class=\"hljs-attr\">onResize</span>=<span class=\"hljs-string\">{({</span> <span class=\"hljs-attr\">width</span> }) =&gt;</span> {\n          this.setState({ width });\n        }}\n      /&gt;</span>\n    );\n  }\n}\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/12.gif\" alt=\"résultat responsive\" />\n</figure>\n<p>Il est temps de conclure ! Comme vous avez pu le constater, notre errance dans\nle CSSOM nous a permis de créer une abstraction qui :</p>\n<ul>\n<li>est déterministe (le nom de la classe est généré en fonction du style),</li>\n<li>nous évite de nous soucier de la spécificité des sélecteurs CSS,</li>\n<li>isole le style par composant et empêche un tas de comportements inattendus,</li>\n<li>nous permet de gérer le responsive sans se soucier du contexte.</li>\n</ul>\n<p>Si vous ne comprenez pas certains points ou si vous avez des questions supplémentaires,\nn'hésitez pas à poster un commentaire, je me ferai une joie d'y répondre.</p>\n<p>La bise 😘</p>\n"}