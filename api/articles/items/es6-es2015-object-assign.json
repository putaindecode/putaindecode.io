{"slug":"es6-es2015-object-assign","filename":"2015-12-04-es6-es2015-object-assign","title":"ES6, ES2015 : Object.assign","date":"Fri, 04 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-04T00:00:00.000Z","title":"ES6, ES2015 : Object.assign","author":"naholyr","oldSlug":"js/es2015/object-assign","slug":"es6-es2015-object-assign"},"body":"<p>Vous connaissez les méthodes <code>extend</code> d'underscore ou lodash (mais plutôt lodash\nquand même) ? Comme la plupart de ces fonctions utilitaires, elles sont rendues\nobsolètes par une fonctionnalité d'ES6 (aka ES2015).</p>\n<h1>Object.assign</h1>\n<p>La nouvelle méthode statique <code>Object.assign</code> prend en paramètres une série\nd'objets :</p>\n<ul>\n<li>le premier objet est la &quot;cible&quot; des copies ;</li>\n<li>les suivants sont les sources ;</li>\n<li>toutes les clés propres (<em>own properties</em>, soit les clés énumérables et non\nhéritées, même celles dont la valeur est <code>undefined</code>) des sources sont copiées\nvers la cible (les suivantes écrasant les précédentes) ;</li>\n<li><strong>l'objet cible est donc modifié</strong> (il doit être mutable) ;</li>\n<li>puis on retourne l'objet cible.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o = { <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span> };\n<span class=\"hljs-keyword\">const</span> o1 = { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-keyword\">const</span> o2 = { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attr\">z</span>: <span class=\"hljs-number\">3</span> };\n<span class=\"hljs-built_in\">Object</span>.assign(o, o1, o2); <span class=\"hljs-comment\">// { x: undefined, y: 2, z: 3 }</span>\no; <span class=\"hljs-comment\">// { x: undefined, y: 2, z: 3 }</span>\no1; <span class=\"hljs-comment\">// non modifié</span>\no2; <span class=\"hljs-comment\">// non modifié</span>\n</code></pre>\n<h2>Attention à la mutabilité</h2>\n<p>Prenez garde au fait que la source est systématiquement modifiée. Le <em>use-case</em>\ngénéral étant plutôt la création d'un nouvel objet résultant de la fusion des\nsources, on passera habituellement un nouvel objet en premier paramètre.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o1 = { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span> };\n<span class=\"hljs-keyword\">const</span> o2 = { <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-keyword\">const</span> o = <span class=\"hljs-built_in\">Object</span>.assign({}, o1, o2);\no; <span class=\"hljs-comment\">// { x: 1, y: 2 }</span>\n<span class=\"hljs-comment\">// o1 et o2 n&#x27;ont pas été modifiés</span>\n</code></pre>\n<h2>Cas particuliers</h2>\n<h3>Erreurs lors de la copie</h3>\n<p>Si une propriété de la cible est en lecture seule, <code>Object.assign</code> devrait se\ncomporter comme en mode <em>strict</em> (par opposition au mode <em>WTF</em>), et lever\nl'erreur correspondante avant d'interrompre la copie.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o = <span class=\"hljs-built_in\">Object</span>.create(\n  {},\n  {\n    <span class=\"hljs-attr\">val</span>: { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">42</span>, <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">false</span> },\n  },\n);\n\n<span class=\"hljs-comment\">// En mode &quot;standard&quot;:</span>\no.val = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\no.val; <span class=\"hljs-comment\">// 42 (valeur non modifiée)</span>\n<span class=\"hljs-built_in\">Object</span>.assign(o, { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> }); <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\no; <span class=\"hljs-comment\">// { val: 42, x: 1 }</span>\n\n<span class=\"hljs-comment\">// En mode &quot;strict&quot;:</span>\no.val = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\n<span class=\"hljs-built_in\">Object</span>.assign(o, { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> }); <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\no; <span class=\"hljs-comment\">// { val: 42, x: 1 }</span>\n</code></pre>\n<p>Les clés déjà copiées avant la levée d'erreur sont conservées dans la cible,\nainsi dans notre exemple <code>x</code> a été copiée mais pas <code>y</code>.</p>\n<p>Note : ça c'est la théorie, lors de mes tests ce comportement a été le plus\nvariable, en fonction de la plate-forme et du contexte, l'erreur n'est pas\ntoujours levée. Le mieux est de travailler en mode <em>strict</em> pour s'assurer d'un\ncomportement prédictible.</p>\n<h3>Sources scalaires</h3>\n<p>Lorsque les sources sont des valeurs scalaires (nombre, booléen, etc.)\n<code>Object.keys</code> ne listera généralement aucune clé et ces valeurs seront donc\nignorées. Les valeurs <code>null</code> et <code>undefined</code> également.</p>\n<p>Cas particulier : les chaînes de caractères sont traitées comme des tableaux.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o = {};\n<span class=\"hljs-built_in\">Object</span>.assign(o, <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">&quot;toto&quot;</span>, [<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;a&quot;</span>], <span class=\"hljs-literal\">undefined</span>);\n<span class=\"hljs-comment\">// 1, true, null, undefined sont ignorées</span>\n<span class=\"hljs-comment\">// &quot;toto&quot; est converti en {0: &quot;t&quot;, 1: &quot;o&quot;, 2: &quot;t&quot;, 3: &quot;o&quot;}</span>\n<span class=\"hljs-comment\">// [&quot;b&quot;, &quot;a&quot;] est converti en {0: &quot;b&quot;, 1: &quot;a&quot;}</span>\no; <span class=\"hljs-comment\">// {0: &quot;b&quot;, 1: &quot;a&quot;, 2: &quot;t&quot;, 3: &quot;o&quot;}</span>\n</code></pre>\n<h2>Conclusion</h2>\n<p>Plus besoin de <code>_.clone</code>, <code>_.extend</code>, etc. avec cette méthode :)</p>\n<p>Pour finir, le topo compatibilité : <code>Object.assign</code> est plutôt bien supportée\npar les navigateurs modernes (donc pas IE) :</p>\n<ul>\n<li>Edge (IE ≥ 12) ;</li>\n<li>Chrome stable (46) ;</li>\n<li>Firefox stable (42) ;</li>\n<li>Node ≥ 4 ;</li>\n<li>et si vous devez supporter IE, il y a bien sûr <a href=\"http://babeljs.io/\">Babel</a> ou\nles nombreuses implémentations utilisateur.</li>\n</ul>\n"}