<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">Écrire des high-order components réutilisables avec Recompose | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="Écrire des high-order components réutilisables avec Recompose | Putain de code" property="og:title"/><meta data-react-helmet="true" content="Écrire des high-order components réutilisables avec Recompose | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par scastiel" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/ecrire-des-high-order-components-reutilisables-avec-recompose" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(311, 100%, 35%), hsl(258, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">Écrire des high-order components réutilisables avec Recompose</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/scastiel"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="scastiel" src="https://avatars.githubusercontent.com/scastiel?size=64"/><div>scastiel<!-- --> <!-- -->•<!-- --> <!-- -->2018/03/26</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Écrire des composants réutilisables est (ou devrait être) l’un des objectifs de
tout développeur React. Que ce soit pour créer une boîte à outils de composants
stylés, pour mutualiser des comportements communs, etc.</p>
<p>Même en ayant fréquemment utilisé des <em>high-order components</em> (avec
<em>React-Redux</em> par exemple), ce n’est que récemment que j’ai entendu parler de
l’opportunité qu’ils offraient pour écrire des composants réutilisables, en
particulier grâce à une fantastique bibliothèque :
<a href="https://github.com/acdlite/recompose">Recompose</a>. Voyons comment avec un
exemple concret et complet.</p>
<p>Si vous n’avez jamais entendu parler de <em>high-order components</em> (HOC) avant,
sachez simplement qu’un HOC n’est finalement rien d’autre qu’une fonction qui
prend en paramètre une définition de composant (classe ou fonction), et renvoie
une nouvelle définition de composant, qui ajoute du comportement à la première.
Il s’agit en fait du pattern
<a href="https://en.wikipedia.org/wiki/Decorator_pattern"><em>Décorateur</em></a> appliqué aux
composants React.</p>
<p>Sur le site de React vous trouverez une
<a href="https://reactjs.org/docs/higher-order-components.html">page très fournie</a> si
vous souhaitez en savoir plus sur les HOC. Il y a également un
<a href="/fr/articles/js/react/higher-order-component/#le-pattern-higher-order-component">très bon article sur Putain de code</a>
présentant les HOC à travers un autre cas d’utilisation (le pattern <em>provider</em>).</p>
<p>Un exemple très simple :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> addBorder = <span class="hljs-function"><span class="hljs-params">borderWidth</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">borderColor:</span> &quot;<span class="hljs-attr">black</span>&quot;, <span class="hljs-attr">borderStyle:</span> &quot;<span class="hljs-attr">solid</span>&quot;, <span class="hljs-attr">borderWidth</span> }}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...props</span>} /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">const</span> MyText = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;

<span class="hljs-keyword">const</span> MyTextWithBorder = addBorder(<span class="hljs-number">5</span>)(MyText);
</code></pre>
<p>Vous obtenez un composant <code>MyTextWithBorder</code> qui affiche le texte « Hello » avec
une bordure de 5 pixels. Ici, <code>addBorder</code> est ce que l’on appelle un <em>high-order
component</em>.</p>
<p>Quel est l’intérêt d’un HOC ? Et bien un pattern très utile est d’extraire un
comportement partagé par plusieurs composants dans des fonctions réutilisables.
Si vous avez utilisé React avec Redux et React-Redux, vous avez sans doute
utilisé le HOC <code>connect</code> pour faire le mapping de l’état et des actions avec les
propriétés.</p>
<h2>Exemple : champ de saisie d’un numéro de téléphone</h2>
<p>Comme exemple complet pour cette article, nous allons utiliser le concept d’HOC
pour créer un champ de saisie de numéro de téléphone, qui :</p>
<ul>
<li>n’acceptera que les chiffres, parenthèses, tirets et espaces en entrée (à la
frappe) ;</li>
<li>mettra en forme le numéro de téléphone lorsque le focus sera perdu par le
champ (évènement <em>blur</em>). (Seuls les numéros de téléphone Nord-Americains
seront pris en compte : « (514) 555-0199 ».)</li>
</ul>
<figure>
  <img src="/public/images/articles/2018-03-26-ecrire-des-high-order-components-reutilisables-avec-recompose/phoneNumberInput.gif" alt="Champ de saisie de numéro de téléphone" />
  <figcaption>Notre champ de saisie de numéro de téléphone</figcaption>
</figure>
<p>Notez que l’on supposera que notre champs sera contrôlé, c’est-à-dire que nous
utiliserons les propriétés <code>value</code> et <code>onChange</code> pour savoir quel texte afficher
et comment le mettre à jour. Nous souhaitons également que la valeur ne
contienne que les chiffres du numéro de téléphone (« 5145550199 »), sans se
soucier de la mise en forme, et donc que le <code>onChange</code> soit appelé avec les
chiffres uniquement (dans <code>event.target.value</code>).</p>
<p>Pour rendre notre HOC plus facile à écrire et maintenir, nous utiserons la
bibliothèque <em>Recompose</em>, qui propose un grand nombre de fonctions utilitaires
pour écrire des HOC. Nous en verrons quelques-unes dans cet article.</p>
<p>Pour développer notre composant nous créerons deux HOC réutilisables, un pour
chacun des points ci-dessus. Cela signifie que nous souhaitons que notre
composant final soit défini ainsi :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> PhoneNumberInput = formatPhoneNumber(
  forbidNonPhoneNumberCharacters(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>),
);
</code></pre>
<p>C’est le bon moment pour introduire la première fonction de <em>Recompose</em> que nous
utiliserons : <code>compose</code>. Elle effectue la composition de plusieurs HOC pour les
fusionner en un seul, de sorte que nous pouvons écrire plus simplement :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> PhoneNumberInput = compose(
  formatPhoneNumber,
  forbidNonPhoneNumberCharacters,
)(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>);
</code></pre>
<p>Et parce que nous souhaitons rendre nos HOC aussi réutilisable que possible
(pour mettre en forme autre chose que des numéros de téléphone par exemple),
rendons-les plus génériques :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Ne garde que les chiffres, espaces, tirets et parenthèses</span>
<span class="hljs-keyword">const</span> forbiddenCharactersInPhoneNumber = <span class="hljs-regexp">/[^\d\s\-()]/g</span>;

<span class="hljs-comment">// &#x27;5145551234&#x27; =&gt; &#x27;(514) 555-1234&#x27;</span>
<span class="hljs-keyword">const</span> formatPhoneNumber = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>
  value.replace(<span class="hljs-regexp">/^(\d{3})(\d{3})(\d{4})$/</span>, <span class="hljs-string">&quot;($1) $2-$3&quot;</span>);

<span class="hljs-comment">// &#x27;(514) 555-1234&#x27; =&gt; &#x27;5145551234&#x27;</span>
<span class="hljs-keyword">const</span> parsePhoneNumber = <span class="hljs-function"><span class="hljs-params">formattedPhoneNumber</span> =&gt;</span>
  formattedPhoneNumber.replace(<span class="hljs-regexp">/[^\d]/g</span>, <span class="hljs-string">&quot;&quot;</span>).slice(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);

<span class="hljs-keyword">const</span> PhoneNumberInput = compose(
  formatInputValue({
    <span class="hljs-attr">formatValue</span>: formatPhoneNumber,
    <span class="hljs-attr">parseValue</span>: parsePhoneNumber,
  }),
  forbidCharacters(forbiddenCharactersInPhoneNumber),
)(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>);
</code></pre>
<p>Ne trouvez-vous pas cela déjà génial si l’on peut réutiliser uniquement nos deux
HOC pour mettre en forme des montants, des numéros de sécurité sociale, tout et
n’importe quoi, juste en utilisant les bons paramètres ? 😉</p>
<p>Le point réellement intéressant est qu’ici j’utilise le composant <code>&lt;input&gt;</code> de
base, mais nous pourrions utiliser n’importe quel composant, tant qu’il utilise
les propriétés <code>value</code>, <code>onChange</code> et <code>onBlur</code>. Donc on peut imaginer utiliser
notre champs de saisie de numéros de téléphone avec React Native, Material-UI,
etc.</p>
<p>Ok, maintenant passons au plus important, écrire nos deux HOC en utilisant les
fonctions que Recompose nous met à disposition.</p>
<h2>Premier HOC : n’accepter que certains caractères</h2>
<p>L’idée ici est que lorsque la valeur de l’input est changée (évènement
<code>onChange</code>), on intercepte cet évènement pour supprimer tout caractère interdit
de la valeur, puis on appelle la propriété <code>onChange</code> parente avec la valeur
propre.</p>
<p>Nous utiliserons ici la fonction <code>withHandlers</code> pour ajouter des nouveaux
<em>handlers</em> d’évènement comme propriétés du composant encapsulé. Le bon point est
que nous avons accès aux propriétés de notre composant (ici nous utiliserons
<code>onChange</code>) pour créer notre nouveau handler :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> forbidCharacters = <span class="hljs-function"><span class="hljs-params">forbiddenCharsRegexp</span> =&gt;</span>
  withHandlers({
    <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
      <span class="hljs-comment">// N’oublions pas que `onChange` n’est pas une propriété requise</span>
      <span class="hljs-comment">// (même si rien ne se produira si elle est absente).</span>
      <span class="hljs-keyword">if</span> (props.onChange) {
        <span class="hljs-keyword">const</span> value = event.target.value;
        <span class="hljs-keyword">const</span> cleanValue = value.replace(forbiddenCharsRegexp, <span class="hljs-string">&quot;&quot;</span>);
        <span class="hljs-comment">// On ne modifie pas l’évènement original, mais on le clone</span>
        <span class="hljs-comment">// en y redéfinissant event.target.value avec la valeur propre.</span>
        <span class="hljs-keyword">const</span> newEvent = {
          ...event,
          <span class="hljs-attr">target</span>: { ...event.target, <span class="hljs-attr">value</span>: cleanValue },
        };
        <span class="hljs-comment">// On réémet notre évènement au `onChange` parent.</span>
        props.onChange(newEvent);
      }
    },
  });
</code></pre>
<p>Souvenez-vous qu’autant que possible le composant que nous créons à partir d’un
autre doit respecter l’interface de ce dernier. Il doit donc accepter les mêmes
propriétés avec le même type.</p>
<p>À présent si nous souhaitons par exemple créer un champ n’acceptant que les
chiffres, nous pouvons écrire :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> NumericField = forbidCharacters(<span class="hljs-regexp">/[^\d]/g</span>)(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span>);
</code></pre>
<p>Nous avons maintenant notre premier HOC pour interdire certains caractères;
écrivons à présent le deuxième, légèrement plus complexe, pour mettre en forme
la valeur entrée par l’utilisateur.</p>
<h2>Deuxième HOC : mettre en forme la valeur entrée</h2>
<p>Pour notre deuxième HOC, nous devrons avoir dans notre composant un état local
pour stocker la valeur entrée dans le champs sans la passer au composant parent.
N’oubliez pas que nous souhaitons mettre en forme la valeur uniquement lorsque
le focus sort du champs (évènement <em>blur</em>).</p>
<p>Recompose définit une fonction très simple pour ajouter un état local à un
composant : <code>withState</code>. Elle prend en paramètre le nom de l’attribut dans
l’état (qui sera donné comme propriété au composant enfant), le nom de la
propriété contenant la fonction pour mettre à jour cet état (également donnée
comme propriété), et la valeur initiale (valeur statique, ou bien fonction
prenant en paramètre les propriétés et retournant la valeur initiale).</p>
<p>Pour ajouter notre état local nous écrirons :</p>
<pre><code class="hljs language-js">withState(
  <span class="hljs-string">&quot;inputValue&quot;</span>,
  <span class="hljs-string">&quot;setInputValue&quot;</span>,
  <span class="hljs-comment">// `formatValue` est l’un des paramètres de notre HOC</span>
  <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> formatValue(props.value),
);
</code></pre>
<p>Facile, non ? 😉</p>
<p>Maintenant que l’on a notre état, nous devons le mettre à jour lorsque la valeur
de l’input est modifiée, donc nous définirons un handler <code>onChange</code> personnalisé
:</p>
<pre><code class="hljs language-js">withHandlers({
  <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    props.setInputValue(event.target.value)
  }
  <span class="hljs-comment">// ...</span>
</code></pre>
<p>Et à l’évènement <em>blur</em>, nous mettrons en forme la valeur, appelerons les
<code>onChange</code> et <code>onBlur</code> parents, puis mettrons en forme également la valeur
affichée :</p>
<pre><code class="hljs language-js">  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">onBlur</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-comment">// parseValue est l’autre paramètre de notre HOC</span>
    <span class="hljs-keyword">const</span> parsedValue = parseValue(props.inputValue)
    <span class="hljs-keyword">const</span> formattedValue = formatValue(parsedValue)
    props.setInputValue(formattedValue)
    <span class="hljs-comment">// On ne modifie pas l’évènement original, mais on le clone</span>
    <span class="hljs-comment">// en y redéfinissant event.target.value avec la valeur propre.</span>
    <span class="hljs-keyword">const</span> newEvent = {
      ...event,
      <span class="hljs-attr">target</span>: { ...event.target, <span class="hljs-attr">value</span>: parsedValue }
    }
    <span class="hljs-keyword">if</span> (props.onChange) {
      props.onChange(newEvent)
    }
    <span class="hljs-keyword">if</span> (props.onBlur) {
      props.onBlur(newEvent)
    }
  }
)
</code></pre>
<p>La dernière étape pour notre HOC consiste à nous assurer que seules les
propriétés acceptées par <code>&lt;input&gt;</code> lui seront passées. Pour cela on utilisera la
fonction <code>mapProps</code> de Recompose pour créer un nouvel objet de propriétés à
partir des propriétés existantes, ainsi que la fonction <code>omit</code> de <em>lodash</em> pour
exclure certaines propriétés d’un objet pour en créer un nouveau :</p>
<pre><code class="hljs language-js">mapProps(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> ({
  ...omit(props, [<span class="hljs-string">&quot;inputValue&quot;</span>, <span class="hljs-string">&quot;setInputValue&quot;</span>]),
  <span class="hljs-attr">value</span>: props.inputValue,
}));
</code></pre>
<p>En assemblant le tout avec <code>compose</code>, on obtient :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> formatInputValue = <span class="hljs-function">(<span class="hljs-params">{ formatValue, parseValue }</span>) =&gt;</span>
  compose(
    withState(<span class="hljs-string">&quot;inputValue&quot;</span>, <span class="hljs-string">&quot;setInputValue&quot;</span>, <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> formatValue(props.value)),
    withHandlers({
      <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        props.setInputValue(event.target.value);
      },
      <span class="hljs-attr">onBlur</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> parsedValue = parseValue(props.inputValue);
        <span class="hljs-keyword">const</span> formattedValue = formatValue(parsedValue);
        props.setInputValue(formattedValue);
        <span class="hljs-keyword">const</span> newEvent = {
          ...event,
          <span class="hljs-attr">target</span>: { ...event.target, <span class="hljs-attr">value</span>: parsedValue },
        };
        <span class="hljs-keyword">if</span> (props.onChange) {
          props.onChange(newEvent);
        }
        <span class="hljs-keyword">if</span> (props.onBlur) {
          props.onBlur(newEvent);
        }
      },
    }),
    mapProps(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> ({
      ...omit(props, [<span class="hljs-string">&quot;inputValue&quot;</span>, <span class="hljs-string">&quot;setInputValue&quot;</span>]),
      <span class="hljs-attr">value</span>: props.inputValue,
    })),
  );
</code></pre>
<p>Et voilà ! Nous avons deux <em>high-order components</em>, on peut les utiliser pour
créer notre champs de saisie de numéro de téléphone ! Ci-dessous vous trouverez
le JSFiddle content le code source complet de cet exemple, et vous permet de
tester le résultat. N’hésitez pas à forker le
<a href="https://jsfiddle.net/scastiel/prme4k6L/">JSFiddle</a> pour jouer avec Recompose ou
créer vos propres HOC.</p>
<iframe width="100%" height="300" src="//jsfiddle.net/scastiel/prme4k6L/8/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
<h2>Les <em>render props</em> : une alternative aux <em>high-order components</em> ?</h2>
<p>Écrire des composants réutilisables est tout à fait possible sans utiliser de
HOC. Pour reprendre notre exemple de champ de saisie de numéro de téléphone nous
pourrions créer un composant <code>FormattedInput</code>, qui prendrait en paramètres
(propriété) les caractères autorisés d’une part, et les fonctions de formattage
d’autre part. Il resterait un inconvénient à cette méthode : cela vous contraint
à n’utiliser qu’un type de champ fixé à l’avance, par exemple <code>&lt;input&gt;</code>.</p>
<p>C’est là qu’intervient un concept particulièrement intéressant : celui des
<em>render props</em>. Tout simplement, cela consiste à passer en propriété de votre
composant une fonction permettant de générer un autre composant, qui sera une
composante du premier.</p>
<p>Par exemple notre <code>PhoneNumberInput</code> pourrait nous laisser la possibilité de lui
indiquer comment générer un champ de saisie (sur lequel il ajoutera le
comportement spécifique, ici la mise en forme) :</p>
<pre><code class="hljs language-js">&lt;PhoneNumberInput renderInput={<span class="hljs-function"><span class="hljs-params">inputProps</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...inputProps</span>} /&gt;</span></span>} /&gt;
</code></pre>
<p>Il y aurait de quoi écrire un article entier sur les <em>render props</em>, et selon
moi il serait dommage de les voir comme une sorte de « concurrent » des HOC ;
les deux peuvent répondre à des problématiques parfois similaires, parfois
différentes.</p>
<p>Pour en savoir plus sur les <em>render props</em> la
<a href="https://reactjs.org/docs/render-props.html">page consacrée de la documentation de React</a>
est très détaillée et donne également de bons exemples d’utilisation.</p>
<h2>En conclusion…</h2>
<p>J’espère que cet article vous a donné envie d’en savoir plus à propos de
Recompose et des <em>high-order components</em> en général. Je suis convaincu que les
HOC créent une nouvelle manière d’écrire des composants réutilisables ; on en
entendra sans aucun doute parler de plus en plus dans le futur 😀.</p>
<p>Quelques ressources pour aller plus loin :</p>
<ul>
<li>La
<a href="https://github.com/acdlite/recompose/blob/master/docs/API.md">documentation de l’API de Recompose</a>
est assez complète, bien que selon moi elle manque parfois d’exemples pour
comprendre certaines fonctions complexes ;</li>
<li>La
<a href="https://reactjs.org/docs/higher-order-components.html">page de React à propos des HOC</a>
contient un grand nombre d’informations, par exemple ce que vous ne devriez
pas faire avec les HOC 😉 ;</li>
<li><dl>
<dt><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">React Higher Order Components in depth</a></dt>
<dd>une très bonne introduction aux HOC ;
</dd>
</dl>
</li>
<li><dl>
<dt><a href="https://medium.com/javascript-inside/why-the-hipsters-recompose-everything-23ac08748198">Why The Hipsters Recompose Everything</a></dt>
<dd>une introduction sympa à Recompose (semble un peu datée…).
</dd>
</dl>
</li>
<li><a href="https://reactjs.org/docs/render-props.html">La documentation de React sur les <em>render props</em></a></li>
<li><a href="/fr/articles/js/react/higher-order-component/#le-pattern-higher-order-component">Les patterns Provider &amp; Higher-Order Component avec React</a>
sur Putain de code</li>
</ul>
<p><em>Cet article est (pour la plus grande partie) la traduction en français de mon
article initialement en anglais disponible sur mon blog :
<a href="https://blog.castiel.me/posts/006-reusable-hoc-with-recompose.html">Create reusable high-order React components with Recompose</a>.</em></p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=%C3%89crire%20des%20high-order%20components%20r%C3%A9utilisables%20avec%20Recompose%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fecrire-des-high-order-components-reutilisables-avec-recompose" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"ecrire-des-high-order-components-reutilisables-avec-recompose","v":{"_0":{"TAG":0,"_0":{"slug":"ecrire-des-high-order-components-reutilisables-avec-recompose","filename":"2018-03-26-ecrire-des-high-order-components-reutilisables-avec-recompose","title":"Écrire des high-order components réutilisables avec Recompose","date":"Mon, 26 Mar 2018 00:00:00 GMT","draft":false,"meta":{"date":"2018-03-26T00:00:00.000Z","title":"Écrire des high-order components réutilisables avec Recompose","author":"scastiel","oldSlug":"js/react/hoc-reutilisables-recompose","slug":"ecrire-des-high-order-components-reutilisables-avec-recompose"},"body":"<p>Écrire des composants réutilisables est (ou devrait être) l’un des objectifs de\ntout développeur React. Que ce soit pour créer une boîte à outils de composants\nstylés, pour mutualiser des comportements communs, etc.</p>\n<p>Même en ayant fréquemment utilisé des <em>high-order components</em> (avec\n<em>React-Redux</em> par exemple), ce n’est que récemment que j’ai entendu parler de\nl’opportunité qu’ils offraient pour écrire des composants réutilisables, en\nparticulier grâce à une fantastique bibliothèque :\n<a href=\"https://github.com/acdlite/recompose\">Recompose</a>. Voyons comment avec un\nexemple concret et complet.</p>\n<p>Si vous n’avez jamais entendu parler de <em>high-order components</em> (HOC) avant,\nsachez simplement qu’un HOC n’est finalement rien d’autre qu’une fonction qui\nprend en paramètre une définition de composant (classe ou fonction), et renvoie\nune nouvelle définition de composant, qui ajoute du comportement à la première.\nIl s’agit en fait du pattern\n<a href=\"https://en.wikipedia.org/wiki/Decorator_pattern\"><em>Décorateur</em></a> appliqué aux\ncomposants React.</p>\n<p>Sur le site de React vous trouverez une\n<a href=\"https://reactjs.org/docs/higher-order-components.html\">page très fournie</a> si\nvous souhaitez en savoir plus sur les HOC. Il y a également un\n<a href=\"/fr/articles/js/react/higher-order-component/#le-pattern-higher-order-component\">très bon article sur Putain de code</a>\nprésentant les HOC à travers un autre cas d’utilisation (le pattern <em>provider</em>).</p>\n<p>Un exemple très simple :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> addBorder = <span class=\"hljs-function\"><span class=\"hljs-params\">borderWidth</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">Component</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">borderColor:</span> &quot;<span class=\"hljs-attr\">black</span>&quot;, <span class=\"hljs-attr\">borderStyle:</span> &quot;<span class=\"hljs-attr\">solid</span>&quot;, <span class=\"hljs-attr\">borderWidth</span> }}&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n\n<span class=\"hljs-keyword\">const</span> MyText = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n\n<span class=\"hljs-keyword\">const</span> MyTextWithBorder = addBorder(<span class=\"hljs-number\">5</span>)(MyText);\n</code></pre>\n<p>Vous obtenez un composant <code>MyTextWithBorder</code> qui affiche le texte « Hello » avec\nune bordure de 5 pixels. Ici, <code>addBorder</code> est ce que l’on appelle un <em>high-order\ncomponent</em>.</p>\n<p>Quel est l’intérêt d’un HOC ? Et bien un pattern très utile est d’extraire un\ncomportement partagé par plusieurs composants dans des fonctions réutilisables.\nSi vous avez utilisé React avec Redux et React-Redux, vous avez sans doute\nutilisé le HOC <code>connect</code> pour faire le mapping de l’état et des actions avec les\npropriétés.</p>\n<h2>Exemple : champ de saisie d’un numéro de téléphone</h2>\n<p>Comme exemple complet pour cette article, nous allons utiliser le concept d’HOC\npour créer un champ de saisie de numéro de téléphone, qui :</p>\n<ul>\n<li>n’acceptera que les chiffres, parenthèses, tirets et espaces en entrée (à la\nfrappe) ;</li>\n<li>mettra en forme le numéro de téléphone lorsque le focus sera perdu par le\nchamp (évènement <em>blur</em>). (Seuls les numéros de téléphone Nord-Americains\nseront pris en compte : « (514) 555-0199 ».)</li>\n</ul>\n<figure>\n  <img src=\"/public/images/articles/2018-03-26-ecrire-des-high-order-components-reutilisables-avec-recompose/phoneNumberInput.gif\" alt=\"Champ de saisie de numéro de téléphone\" />\n  <figcaption>Notre champ de saisie de numéro de téléphone</figcaption>\n</figure>\n<p>Notez que l’on supposera que notre champs sera contrôlé, c’est-à-dire que nous\nutiliserons les propriétés <code>value</code> et <code>onChange</code> pour savoir quel texte afficher\net comment le mettre à jour. Nous souhaitons également que la valeur ne\ncontienne que les chiffres du numéro de téléphone (« 5145550199 »), sans se\nsoucier de la mise en forme, et donc que le <code>onChange</code> soit appelé avec les\nchiffres uniquement (dans <code>event.target.value</code>).</p>\n<p>Pour rendre notre HOC plus facile à écrire et maintenir, nous utiserons la\nbibliothèque <em>Recompose</em>, qui propose un grand nombre de fonctions utilitaires\npour écrire des HOC. Nous en verrons quelques-unes dans cet article.</p>\n<p>Pour développer notre composant nous créerons deux HOC réutilisables, un pour\nchacun des points ci-dessus. Cela signifie que nous souhaitons que notre\ncomposant final soit défini ainsi :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> PhoneNumberInput = formatPhoneNumber(\n  forbidNonPhoneNumberCharacters(<span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span></span>),\n);\n</code></pre>\n<p>C’est le bon moment pour introduire la première fonction de <em>Recompose</em> que nous\nutiliserons : <code>compose</code>. Elle effectue la composition de plusieurs HOC pour les\nfusionner en un seul, de sorte que nous pouvons écrire plus simplement :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> PhoneNumberInput = compose(\n  formatPhoneNumber,\n  forbidNonPhoneNumberCharacters,\n)(<span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span></span>);\n</code></pre>\n<p>Et parce que nous souhaitons rendre nos HOC aussi réutilisable que possible\n(pour mettre en forme autre chose que des numéros de téléphone par exemple),\nrendons-les plus génériques :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Ne garde que les chiffres, espaces, tirets et parenthèses</span>\n<span class=\"hljs-keyword\">const</span> forbiddenCharactersInPhoneNumber = <span class=\"hljs-regexp\">/[^\\d\\s\\-()]/g</span>;\n\n<span class=\"hljs-comment\">// &#x27;5145551234&#x27; =&gt; &#x27;(514) 555-1234&#x27;</span>\n<span class=\"hljs-keyword\">const</span> formatPhoneNumber = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span>\n  value.replace(<span class=\"hljs-regexp\">/^(\\d{3})(\\d{3})(\\d{4})$/</span>, <span class=\"hljs-string\">&quot;($1) $2-$3&quot;</span>);\n\n<span class=\"hljs-comment\">// &#x27;(514) 555-1234&#x27; =&gt; &#x27;5145551234&#x27;</span>\n<span class=\"hljs-keyword\">const</span> parsePhoneNumber = <span class=\"hljs-function\"><span class=\"hljs-params\">formattedPhoneNumber</span> =&gt;</span>\n  formattedPhoneNumber.replace(<span class=\"hljs-regexp\">/[^\\d]/g</span>, <span class=\"hljs-string\">&quot;&quot;</span>).slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>);\n\n<span class=\"hljs-keyword\">const</span> PhoneNumberInput = compose(\n  formatInputValue({\n    <span class=\"hljs-attr\">formatValue</span>: formatPhoneNumber,\n    <span class=\"hljs-attr\">parseValue</span>: parsePhoneNumber,\n  }),\n  forbidCharacters(forbiddenCharactersInPhoneNumber),\n)(<span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span></span>);\n</code></pre>\n<p>Ne trouvez-vous pas cela déjà génial si l’on peut réutiliser uniquement nos deux\nHOC pour mettre en forme des montants, des numéros de sécurité sociale, tout et\nn’importe quoi, juste en utilisant les bons paramètres ? 😉</p>\n<p>Le point réellement intéressant est qu’ici j’utilise le composant <code>&lt;input&gt;</code> de\nbase, mais nous pourrions utiliser n’importe quel composant, tant qu’il utilise\nles propriétés <code>value</code>, <code>onChange</code> et <code>onBlur</code>. Donc on peut imaginer utiliser\nnotre champs de saisie de numéros de téléphone avec React Native, Material-UI,\netc.</p>\n<p>Ok, maintenant passons au plus important, écrire nos deux HOC en utilisant les\nfonctions que Recompose nous met à disposition.</p>\n<h2>Premier HOC : n’accepter que certains caractères</h2>\n<p>L’idée ici est que lorsque la valeur de l’input est changée (évènement\n<code>onChange</code>), on intercepte cet évènement pour supprimer tout caractère interdit\nde la valeur, puis on appelle la propriété <code>onChange</code> parente avec la valeur\npropre.</p>\n<p>Nous utiliserons ici la fonction <code>withHandlers</code> pour ajouter des nouveaux\n<em>handlers</em> d’évènement comme propriétés du composant encapsulé. Le bon point est\nque nous avons accès aux propriétés de notre composant (ici nous utiliserons\n<code>onChange</code>) pour créer notre nouveau handler :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> forbidCharacters = <span class=\"hljs-function\"><span class=\"hljs-params\">forbiddenCharsRegexp</span> =&gt;</span>\n  withHandlers({\n    <span class=\"hljs-attr\">onChange</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// N’oublions pas que `onChange` n’est pas une propriété requise</span>\n      <span class=\"hljs-comment\">// (même si rien ne se produira si elle est absente).</span>\n      <span class=\"hljs-keyword\">if</span> (props.onChange) {\n        <span class=\"hljs-keyword\">const</span> value = event.target.value;\n        <span class=\"hljs-keyword\">const</span> cleanValue = value.replace(forbiddenCharsRegexp, <span class=\"hljs-string\">&quot;&quot;</span>);\n        <span class=\"hljs-comment\">// On ne modifie pas l’évènement original, mais on le clone</span>\n        <span class=\"hljs-comment\">// en y redéfinissant event.target.value avec la valeur propre.</span>\n        <span class=\"hljs-keyword\">const</span> newEvent = {\n          ...event,\n          <span class=\"hljs-attr\">target</span>: { ...event.target, <span class=\"hljs-attr\">value</span>: cleanValue },\n        };\n        <span class=\"hljs-comment\">// On réémet notre évènement au `onChange` parent.</span>\n        props.onChange(newEvent);\n      }\n    },\n  });\n</code></pre>\n<p>Souvenez-vous qu’autant que possible le composant que nous créons à partir d’un\nautre doit respecter l’interface de ce dernier. Il doit donc accepter les mêmes\npropriétés avec le même type.</p>\n<p>À présent si nous souhaitons par exemple créer un champ n’acceptant que les\nchiffres, nous pouvons écrire :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> NumericField = forbidCharacters(<span class=\"hljs-regexp\">/[^\\d]/g</span>)(<span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> {<span class=\"hljs-attr\">...props</span>} /&gt;</span></span>);\n</code></pre>\n<p>Nous avons maintenant notre premier HOC pour interdire certains caractères;\nécrivons à présent le deuxième, légèrement plus complexe, pour mettre en forme\nla valeur entrée par l’utilisateur.</p>\n<h2>Deuxième HOC : mettre en forme la valeur entrée</h2>\n<p>Pour notre deuxième HOC, nous devrons avoir dans notre composant un état local\npour stocker la valeur entrée dans le champs sans la passer au composant parent.\nN’oubliez pas que nous souhaitons mettre en forme la valeur uniquement lorsque\nle focus sort du champs (évènement <em>blur</em>).</p>\n<p>Recompose définit une fonction très simple pour ajouter un état local à un\ncomposant : <code>withState</code>. Elle prend en paramètre le nom de l’attribut dans\nl’état (qui sera donné comme propriété au composant enfant), le nom de la\npropriété contenant la fonction pour mettre à jour cet état (également donnée\ncomme propriété), et la valeur initiale (valeur statique, ou bien fonction\nprenant en paramètre les propriétés et retournant la valeur initiale).</p>\n<p>Pour ajouter notre état local nous écrirons :</p>\n<pre><code class=\"hljs language-js\">withState(\n  <span class=\"hljs-string\">&quot;inputValue&quot;</span>,\n  <span class=\"hljs-string\">&quot;setInputValue&quot;</span>,\n  <span class=\"hljs-comment\">// `formatValue` est l’un des paramètres de notre HOC</span>\n  <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> formatValue(props.value),\n);\n</code></pre>\n<p>Facile, non ? 😉</p>\n<p>Maintenant que l’on a notre état, nous devons le mettre à jour lorsque la valeur\nde l’input est modifiée, donc nous définirons un handler <code>onChange</code> personnalisé\n:</p>\n<pre><code class=\"hljs language-js\">withHandlers({\n  <span class=\"hljs-attr\">onChange</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n    props.setInputValue(event.target.value)\n  }\n  <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>Et à l’évènement <em>blur</em>, nous mettrons en forme la valeur, appelerons les\n<code>onChange</code> et <code>onBlur</code> parents, puis mettrons en forme également la valeur\naffichée :</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">onBlur</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// parseValue est l’autre paramètre de notre HOC</span>\n    <span class=\"hljs-keyword\">const</span> parsedValue = parseValue(props.inputValue)\n    <span class=\"hljs-keyword\">const</span> formattedValue = formatValue(parsedValue)\n    props.setInputValue(formattedValue)\n    <span class=\"hljs-comment\">// On ne modifie pas l’évènement original, mais on le clone</span>\n    <span class=\"hljs-comment\">// en y redéfinissant event.target.value avec la valeur propre.</span>\n    <span class=\"hljs-keyword\">const</span> newEvent = {\n      ...event,\n      <span class=\"hljs-attr\">target</span>: { ...event.target, <span class=\"hljs-attr\">value</span>: parsedValue }\n    }\n    <span class=\"hljs-keyword\">if</span> (props.onChange) {\n      props.onChange(newEvent)\n    }\n    <span class=\"hljs-keyword\">if</span> (props.onBlur) {\n      props.onBlur(newEvent)\n    }\n  }\n)\n</code></pre>\n<p>La dernière étape pour notre HOC consiste à nous assurer que seules les\npropriétés acceptées par <code>&lt;input&gt;</code> lui seront passées. Pour cela on utilisera la\nfonction <code>mapProps</code> de Recompose pour créer un nouvel objet de propriétés à\npartir des propriétés existantes, ainsi que la fonction <code>omit</code> de <em>lodash</em> pour\nexclure certaines propriétés d’un objet pour en créer un nouveau :</p>\n<pre><code class=\"hljs language-js\">mapProps(<span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> ({\n  ...omit(props, [<span class=\"hljs-string\">&quot;inputValue&quot;</span>, <span class=\"hljs-string\">&quot;setInputValue&quot;</span>]),\n  <span class=\"hljs-attr\">value</span>: props.inputValue,\n}));\n</code></pre>\n<p>En assemblant le tout avec <code>compose</code>, on obtient :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> formatInputValue = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ formatValue, parseValue }</span>) =&gt;</span>\n  compose(\n    withState(<span class=\"hljs-string\">&quot;inputValue&quot;</span>, <span class=\"hljs-string\">&quot;setInputValue&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> formatValue(props.value)),\n    withHandlers({\n      <span class=\"hljs-attr\">onChange</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n        props.setInputValue(event.target.value);\n      },\n      <span class=\"hljs-attr\">onBlur</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span> parsedValue = parseValue(props.inputValue);\n        <span class=\"hljs-keyword\">const</span> formattedValue = formatValue(parsedValue);\n        props.setInputValue(formattedValue);\n        <span class=\"hljs-keyword\">const</span> newEvent = {\n          ...event,\n          <span class=\"hljs-attr\">target</span>: { ...event.target, <span class=\"hljs-attr\">value</span>: parsedValue },\n        };\n        <span class=\"hljs-keyword\">if</span> (props.onChange) {\n          props.onChange(newEvent);\n        }\n        <span class=\"hljs-keyword\">if</span> (props.onBlur) {\n          props.onBlur(newEvent);\n        }\n      },\n    }),\n    mapProps(<span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> ({\n      ...omit(props, [<span class=\"hljs-string\">&quot;inputValue&quot;</span>, <span class=\"hljs-string\">&quot;setInputValue&quot;</span>]),\n      <span class=\"hljs-attr\">value</span>: props.inputValue,\n    })),\n  );\n</code></pre>\n<p>Et voilà ! Nous avons deux <em>high-order components</em>, on peut les utiliser pour\ncréer notre champs de saisie de numéro de téléphone ! Ci-dessous vous trouverez\nle JSFiddle content le code source complet de cet exemple, et vous permet de\ntester le résultat. N’hésitez pas à forker le\n<a href=\"https://jsfiddle.net/scastiel/prme4k6L/\">JSFiddle</a> pour jouer avec Recompose ou\ncréer vos propres HOC.</p>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/scastiel/prme4k6L/8/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<h2>Les <em>render props</em> : une alternative aux <em>high-order components</em> ?</h2>\n<p>Écrire des composants réutilisables est tout à fait possible sans utiliser de\nHOC. Pour reprendre notre exemple de champ de saisie de numéro de téléphone nous\npourrions créer un composant <code>FormattedInput</code>, qui prendrait en paramètres\n(propriété) les caractères autorisés d’une part, et les fonctions de formattage\nd’autre part. Il resterait un inconvénient à cette méthode : cela vous contraint\nà n’utiliser qu’un type de champ fixé à l’avance, par exemple <code>&lt;input&gt;</code>.</p>\n<p>C’est là qu’intervient un concept particulièrement intéressant : celui des\n<em>render props</em>. Tout simplement, cela consiste à passer en propriété de votre\ncomposant une fonction permettant de générer un autre composant, qui sera une\ncomposante du premier.</p>\n<p>Par exemple notre <code>PhoneNumberInput</code> pourrait nous laisser la possibilité de lui\nindiquer comment générer un champ de saisie (sur lequel il ajoutera le\ncomportement spécifique, ici la mise en forme) :</p>\n<pre><code class=\"hljs language-js\">&lt;PhoneNumberInput renderInput={<span class=\"hljs-function\"><span class=\"hljs-params\">inputProps</span> =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> {<span class=\"hljs-attr\">...inputProps</span>} /&gt;</span></span>} /&gt;\n</code></pre>\n<p>Il y aurait de quoi écrire un article entier sur les <em>render props</em>, et selon\nmoi il serait dommage de les voir comme une sorte de « concurrent » des HOC ;\nles deux peuvent répondre à des problématiques parfois similaires, parfois\ndifférentes.</p>\n<p>Pour en savoir plus sur les <em>render props</em> la\n<a href=\"https://reactjs.org/docs/render-props.html\">page consacrée de la documentation de React</a>\nest très détaillée et donne également de bons exemples d’utilisation.</p>\n<h2>En conclusion…</h2>\n<p>J’espère que cet article vous a donné envie d’en savoir plus à propos de\nRecompose et des <em>high-order components</em> en général. Je suis convaincu que les\nHOC créent une nouvelle manière d’écrire des composants réutilisables ; on en\nentendra sans aucun doute parler de plus en plus dans le futur 😀.</p>\n<p>Quelques ressources pour aller plus loin :</p>\n<ul>\n<li>La\n<a href=\"https://github.com/acdlite/recompose/blob/master/docs/API.md\">documentation de l’API de Recompose</a>\nest assez complète, bien que selon moi elle manque parfois d’exemples pour\ncomprendre certaines fonctions complexes ;</li>\n<li>La\n<a href=\"https://reactjs.org/docs/higher-order-components.html\">page de React à propos des HOC</a>\ncontient un grand nombre d’informations, par exemple ce que vous ne devriez\npas faire avec les HOC 😉 ;</li>\n<li><dl>\n<dt><a href=\"https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e\">React Higher Order Components in depth</a></dt>\n<dd>une très bonne introduction aux HOC ;\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><a href=\"https://medium.com/javascript-inside/why-the-hipsters-recompose-everything-23ac08748198\">Why The Hipsters Recompose Everything</a></dt>\n<dd>une introduction sympa à Recompose (semble un peu datée…).\n</dd>\n</dl>\n</li>\n<li><a href=\"https://reactjs.org/docs/render-props.html\">La documentation de React sur les <em>render props</em></a></li>\n<li><a href=\"/fr/articles/js/react/higher-order-component/#le-pattern-higher-order-component\">Les patterns Provider &amp; Higher-Order Component avec React</a>\nsur Putain de code</li>\n</ul>\n<p><em>Cet article est (pour la plus grande partie) la traduction en français de mon\narticle initialement en anglais disponible sur mon blog :\n<a href=\"https://blog.castiel.me/posts/006-reusable-hoc-with-recompose.html\">Create reusable high-order React components with Recompose</a>.</em></p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>