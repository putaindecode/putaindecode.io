<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">ES2016 (?): fonctions asynchrones (async/await) | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="ES2016 (?): fonctions asynchrones (async/await) | Putain de code" property="og:title"/><meta data-react-helmet="true" content="ES2016 (?): fonctions asynchrones (async/await) | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par naholyr" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/es2016-fonctions-asynchrones-async-await" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(83, 100%, 35%), hsl(69, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">ES2016 (?): fonctions asynchrones (async/await)</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/naholyr"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="naholyr" src="https://avatars.githubusercontent.com/naholyr?size=64"/><div>naholyr<!-- --> <!-- -->•<!-- --> <!-- -->2015/12/14</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu'elle
ne fait pas partie des propositions acceptées cette année : les fonctions
asynchrones (async/await). La
<a href="https://tc39.github.io/ecmascript-asyncawait/">spécification</a> est encore au
stade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute
qu'elle (ou une variante) fera partie de la spécification ES2016.</p>
<h2>Fonctions asynchrones</h2>
<p>Pour les traitements asynchrones, vous connaissez déjà
<a href="/fr/articles/js/es2015/promises/">les promesses</a> qui ont évidemment remplacé
les callbacks dans votre code. Si vous n'avez pas déjà fait la bascule vers les
promesses (ne serait-ce que pour la propagation d'erreur),
<a href="/fr/articles/js/es2015/generators/">les générateurs</a> ont dû finir de vous
convaincre grâce aux
<a href="/fr/articles/js/es2015/generators/#use-case-co-routines">coroutines</a>.</p>
<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions
asynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>
<h2>Exemple de traitement asynchrone : Promise</h2>
<p>Partons du programme suivant exécuté le 6 décembre dernier dont l'API est basée
sur les promesses :</p>
<ul>
<li>Il récupère tous les utilisateurs prénommés Nicolas</li>
<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span>(<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> usersP = getUsers(query);
  <span class="hljs-comment">// On récupère le champ &quot;email&quot; de tous les utilisateurs</span>
  <span class="hljs-keyword">const</span> emailsP = usersP.then(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.map(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.email));
  <span class="hljs-comment">// Pour chaque email…</span>
  <span class="hljs-keyword">const</span> sentP = emailsP.then(<span class="hljs-function"><span class="hljs-params">emails</span> =&gt;</span>
    emails.map(<span class="hljs-function"><span class="hljs-params">email</span> =&gt;</span> {
      <span class="hljs-comment">// … on envoie un mail</span>
      <span class="hljs-keyword">return</span> sendMail(email, <span class="hljs-string">&quot;Bonne fête&quot;</span>);
    }),
  );
  <span class="hljs-comment">// On attend que tous les envois soient résolus</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(sentP);
}

sendEmails({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Nicolas&quot;</span> })
  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OK&quot;</span>))
  .catch(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;FAIL&quot;</span>));
</code></pre>
<h2>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>
<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// …</span>
}
</code></pre>
<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le
mot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une
promesse, l'évaluation de l'expression est &quot;mise en pause&quot; jusqu'à la résolution
(ou le rejet) de la promesse :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> aPromise;
  <span class="hljs-comment">// on n&#x27;arrivera à cette ligne que lorsque &quot;aPromise&quot; sera résolue</span>
}
</code></pre>
<p>Évidemment, l'expression a alors pour valeur celle de résolution de la promesse,
et en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> aPromise;
    <span class="hljs-comment">// Ici &quot;aPromise&quot; est résolue avec la valeur &quot;result&quot;</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// Ici &quot;aPromise&quot; est rejetée avec l&#x27;erreur &quot;err&quot;</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// cette ligne n&#x27;est atteinte qu&#x27;après résolution/rejet</span>
}
</code></pre>
<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la
partie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et
<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>
<h2>Notre premier exemple, avec les fonctions asynchrones</h2>
<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span>(<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> getUsers(query);
  <span class="hljs-keyword">const</span> emails = users.map(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.email);
  <span class="hljs-keyword">const</span> sentP = emails.map(<span class="hljs-function"><span class="hljs-params">email</span> =&gt;</span> sendMail(email, <span class="hljs-string">&quot;Bonne fête&quot;</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(sentP);
}

<span class="hljs-comment">// Attention, on ne peut pas utiliser &quot;await&quot; hors d&#x27;une fonction &quot;async&quot;</span>
<span class="hljs-comment">// il faut donc &quot;wrapper&quot; notre code autour d&#x27;une fonction asynchrone</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> sendEmails({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Nicolas&quot;</span> });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OK&quot;</span>);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;FAIL&quot;</span>);
  }
}

main();
</code></pre>
<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus
habituel.</p>
<h2>Attention au piège de l'exécution en série !</h2>
<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser
leurs résultats :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX(); <span class="hljs-comment">// Requête Ajax</span>
<span class="hljs-keyword">const</span> yP = getY(); <span class="hljs-comment">// Requête BDD</span>
<span class="hljs-keyword">const</span> resultP = <span class="hljs-built_in">Promise</span>.all([xP, yP]).then(sum);
</code></pre>
<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs
retours attendus avant de passer à la suite.</p>
<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> getX() <span class="hljs-comment">// Requête Ajax…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> getY() <span class="hljs-comment">// Requête BDD…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])
</code></pre>
<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le
moment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières
de résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax démarrée…</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD démarrée…</span>

<span class="hljs-comment">// Version 1 :</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> xP <span class="hljs-comment">// …requête Ajax terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> yP <span class="hljs-comment">// …requête BDD terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])

<span class="hljs-comment">// Version 2 avec un tableau :</span>
<span class="hljs-keyword">const</span> vars = [<span class="hljs-keyword">await</span> xP, <span class="hljs-keyword">await</span> yP]
<span class="hljs-keyword">const</span> result = sum(vars)

<span class="hljs-comment">// Version 3 avec Promise.all :</span>
<span class="hljs-keyword">const</span> vars = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([xP, yP])
<span class="hljs-keyword">const</span> result = sum(vars)
</code></pre>
<h2>Et aujourd'hui ?</h2>
<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un code
basé sur les générateurs : il vous suffira d'ajouter les plugins Babel
<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à inclure
<code>babel-polyfill</code> en fichier d'entrée).</p>
<h2>Conclusion</h2>
<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un
code non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le
processus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,
c'est exactement la même chose !</p>
<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,
qui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il
s'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes
<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée pour
ce langage : la courbe d'apprentissage des traitements asynchrones va être
drastiquement aplanie ;)</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=ES2016%20(%3F)%3A%20fonctions%20asynchrones%20(async%2Fawait)%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fes2016-fonctions-asynchrones-async-await" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"es2016-fonctions-asynchrones-async-await","v":{"_0":{"TAG":0,"_0":{"slug":"es2016-fonctions-asynchrones-async-await","filename":"2015-12-14-es2016-fonctions-asynchrones-async-await","title":"ES2016 (?): fonctions asynchrones (async/await)","date":"Mon, 14 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-14T00:00:00.000Z","title":"ES2016 (?): fonctions asynchrones (async/await)","author":"naholyr","oldSlug":"js/es2016/async-await","slug":"es2016-fonctions-asynchrones-async-await"},"body":"<p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu'elle\nne fait pas partie des propositions acceptées cette année : les fonctions\nasynchrones (async/await). La\n<a href=\"https://tc39.github.io/ecmascript-asyncawait/\">spécification</a> est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.</p>\n<h2>Fonctions asynchrones</h2>\n<p>Pour les traitements asynchrones, vous connaissez déjà\n<a href=\"/fr/articles/js/es2015/promises/\">les promesses</a> qui ont évidemment remplacé\nles callbacks dans votre code. Si vous n'avez pas déjà fait la bascule vers les\npromesses (ne serait-ce que pour la propagation d'erreur),\n<a href=\"/fr/articles/js/es2015/generators/\">les générateurs</a> ont dû finir de vous\nconvaincre grâce aux\n<a href=\"/fr/articles/js/es2015/generators/#use-case-co-routines\">coroutines</a>.</p>\n<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>\n<h2>Exemple de traitement asynchrone : Promise</h2>\n<p>Partons du programme suivant exécuté le 6 décembre dernier dont l'API est basée\nsur les promesses :</p>\n<ul>\n<li>Il récupère tous les utilisateurs prénommés Nicolas</li>\n<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> usersP = getUsers(query);\n  <span class=\"hljs-comment\">// On récupère le champ &quot;email&quot; de tous les utilisateurs</span>\n  <span class=\"hljs-keyword\">const</span> emailsP = usersP.then(<span class=\"hljs-function\"><span class=\"hljs-params\">users</span> =&gt;</span> users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> u.email));\n  <span class=\"hljs-comment\">// Pour chaque email…</span>\n  <span class=\"hljs-keyword\">const</span> sentP = emailsP.then(<span class=\"hljs-function\"><span class=\"hljs-params\">emails</span> =&gt;</span>\n    emails.map(<span class=\"hljs-function\"><span class=\"hljs-params\">email</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// … on envoie un mail</span>\n      <span class=\"hljs-keyword\">return</span> sendMail(email, <span class=\"hljs-string\">&quot;Bonne fête&quot;</span>);\n    }),\n  );\n  <span class=\"hljs-comment\">// On attend que tous les envois soient résolus</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP);\n}\n\nsendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&quot;Nicolas&quot;</span> })\n  .then(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK&quot;</span>))\n  .catch(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;FAIL&quot;</span>));\n</code></pre>\n<h2>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>\n<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// …</span>\n}\n</code></pre>\n<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le\nmot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est &quot;mise en pause&quot; jusqu'à la résolution\n(ou le rejet) de la promesse :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">await</span> aPromise;\n  <span class=\"hljs-comment\">// on n&#x27;arrivera à cette ligne que lorsque &quot;aPromise&quot; sera résolue</span>\n}\n</code></pre>\n<p>Évidemment, l'expression a alors pour valeur celle de résolution de la promesse,\net en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> aPromise;\n    <span class=\"hljs-comment\">// Ici &quot;aPromise&quot; est résolue avec la valeur &quot;result&quot;</span>\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-comment\">// Ici &quot;aPromise&quot; est rejetée avec l&#x27;erreur &quot;err&quot;</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// cette ligne n&#x27;est atteinte qu&#x27;après résolution/rejet</span>\n}\n</code></pre>\n<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et\n<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>\n<h2>Notre premier exemple, avec les fonctions asynchrones</h2>\n<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-keyword\">await</span> getUsers(query);\n  <span class=\"hljs-keyword\">const</span> emails = users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> u.email);\n  <span class=\"hljs-keyword\">const</span> sentP = emails.map(<span class=\"hljs-function\"><span class=\"hljs-params\">email</span> =&gt;</span> sendMail(email, <span class=\"hljs-string\">&quot;Bonne fête&quot;</span>));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP);\n}\n\n<span class=\"hljs-comment\">// Attention, on ne peut pas utiliser &quot;await&quot; hors d&#x27;une fonction &quot;async&quot;</span>\n<span class=\"hljs-comment\">// il faut donc &quot;wrapper&quot; notre code autour d&#x27;une fonction asynchrone</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">await</span> sendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&quot;Nicolas&quot;</span> });\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK&quot;</span>);\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;FAIL&quot;</span>);\n  }\n}\n\nmain();\n</code></pre>\n<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.</p>\n<h2>Attention au piège de l'exécution en série !</h2>\n<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xP = getX(); <span class=\"hljs-comment\">// Requête Ajax</span>\n<span class=\"hljs-keyword\">const</span> yP = getY(); <span class=\"hljs-comment\">// Requête BDD</span>\n<span class=\"hljs-keyword\">const</span> resultP = <span class=\"hljs-built_in\">Promise</span>.all([xP, yP]).then(sum);\n</code></pre>\n<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.</p>\n<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> getX() <span class=\"hljs-comment\">// Requête Ajax…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> getY() <span class=\"hljs-comment\">// Requête BDD…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n</code></pre>\n<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le\nmoment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xP = getX() <span class=\"hljs-comment\">// Requête Ajax démarrée…</span>\n<span class=\"hljs-keyword\">const</span> yP = getY() <span class=\"hljs-comment\">// Requête BDD démarrée…</span>\n\n<span class=\"hljs-comment\">// Version 1 :</span>\n<span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> xP <span class=\"hljs-comment\">// …requête Ajax terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> yP <span class=\"hljs-comment\">// …requête BDD terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n\n<span class=\"hljs-comment\">// Version 2 avec un tableau :</span>\n<span class=\"hljs-keyword\">const</span> vars = [<span class=\"hljs-keyword\">await</span> xP, <span class=\"hljs-keyword\">await</span> yP]\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n\n<span class=\"hljs-comment\">// Version 3 avec Promise.all :</span>\n<span class=\"hljs-keyword\">const</span> vars = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all([xP, yP])\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n</code></pre>\n<h2>Et aujourd'hui ?</h2>\n<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un code\nbasé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à inclure\n<code>babel-polyfill</code> en fichier d'entrée).</p>\n<h2>Conclusion</h2>\n<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !</p>\n<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée pour\nce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>