<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">Pourquoi j&#x27;ai arrêté d&#x27;utiliser CSS | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="Pourquoi j&#x27;ai arrêté d&#x27;utiliser CSS | Putain de code" property="og:title"/><meta data-react-helmet="true" content="Pourquoi j&#x27;ai arrêté d&#x27;utiliser CSS | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par bloodyowl" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/pourquoi-j-ai-arrete-d-utiliser-css" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(11, 100%, 35%), hsl(9, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">Pourquoi j&#x27;ai arrêté d&#x27;utiliser CSS</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/bloodyowl"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="bloodyowl" src="https://avatars.githubusercontent.com/bloodyowl?size=64"/><div>bloodyowl<!-- --> <!-- -->•<!-- --> <!-- -->2016/06/16</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>CSS est un langage horriblement dangereux, parce qu'il mêle des concepts
complètement pétés et une folle capacité à faire confondre facilité et
simplicité aux gens qui l'utilisent.</p>
<h2>Qu'est-ce qui ne va pas ?</h2>
<p>À l'origine, CSS a été conçu pour styler des documents, pas des applications. Du
coup lorsqu'on doit <em>scale</em>, c'est rapidement douloureux.</p>
<h3>Les sélecteurs</h3>
<p>Les sélecteurs sont des <strong>variables globales mutables</strong>. Lorsque vous faites :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.selector</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>;
}
</code></pre>
<p>C'est comme si en JavaScript vous faisiez :</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">window</span>.selector = (<span class="hljs-built_in">window</span>.selector || []).concat({
  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;1rem&quot;</span>,
});
</code></pre>
<p>Ça veut dire que :</p>
<ul>
<li>La définition d'un style associé à un sélecteur peut être redéfinie ailleurs</li>
<li>Si on associe plusieurs styles à un sélecteur, les derniers définis dans le
CSS auront toujours la priorité</li>
<li>Quelqu'un peut péter les styles d'un composant pour peu qu'il ne sache pas
qu'un sélecteur est utilisé ailleurs</li>
</ul>
<h3>La spécificité</h3>
<p>Alors ça, c'est particulièrement drôle : la spécificité d'un sélecteur va
définir la priorité d'application d'un style.</p>
<table>
<thead>
<tr><th>Sélecteur</th><th>Spécificité</th></tr>
</thead>
<tbody>
<tr><td><code>*</code></td><td>0,0,0,0</td></tr>
<tr><td><code>li</code></td><td>0,0,0,1</td></tr>
<tr><td><code>li:first-line</code></td><td>0,0,0,2</td></tr>
<tr><td><code>ul li</code></td><td>0,0,0,2</td></tr>
<tr><td><code>ul ol+li</code></td><td>0,0,0,3</td></tr>
<tr><td><code>h1 + *[rel=up]</code></td><td>0,0,1,1</td></tr>
<tr><td><code>ul ol li.red</code></td><td>0,0,1,3</td></tr>
<tr><td><code>li.red.level</code></td><td>0,0,2,1</td></tr>
<tr><td><code>#x34y</code></td><td>0,1,0,0</td></tr>
</tbody>
</table>
<p>Si le style est défini dans l'attribut <code>style</code>, la spécificité est de 1,0,0,0.
Si une valeur associée à une propriété est suffixée d'un <code>!important</code>, elle
prend quoi qu'il arrive l'ascendance.</p>
<p>Si on résume, on nage en plein délire, la priorité se définit dans l'ordre par :
la présence de <code>!important</code>, la façon de définir le style, la spécificité du
sélecteur utilisé puis par l'ordre de définition dans l'ensemble des CSS de la
page. Évidemment, à l'époque où on n'avait qu'une pauvre petite feuille de style
pour l'ensemble de son site, ça marchait ; plus maintenant.</p>
<h3>Les régressions</h3>
<p>Prenons un exemple tout bête :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.item</span> {
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>;
  <span class="hljs-attribute">color</span>: blue;
}

<span class="hljs-selector-class">.some-context</span> <span class="hljs-selector-class">.item</span> {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">color</span>: red;
}
</code></pre>
<p>Quelqu'un de la team modifie <code>.item</code> :</p>
<pre><code class="hljs language-diff"> .item {
   display: block;
   font-size: 1rem;
   color: blue;
<span class="hljs-addition">+  border: 1px solid red;</span>
 }

 .some-context .item {
   display: inline-block;
   color: red;
}
</code></pre>
<p>Super, une regression dans <code>some-context</code>. Face à ça, deux possibilités :</p>
<ul>
<li>Vous vous foutez d'avoir des régressions qui pètent votre site</li>
<li>À chaque changement minime du CSS vous vérifiez l'intégralité du site et
testez tous les comportements dans tous les contextes.</li>
</ul>
<h3>Le choix de priorisation des styles</h3>
<p>Ce serait pas mal de décider quel <code>className</code> est appliqué en priorité :</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blue red&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red blue&quot;</span>&gt;</span>text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>mais bien évidemment non, comme vu plus haut, c'est le foutu ordre de définition
des sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les
feuilles de style à la demande, selon les actions utilisateur.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.blue</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-selector-class">.red</span> {
  <span class="hljs-attribute">color</span>: red;
}
</code></pre>
<p>C'est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous
faites un :</p>
<pre><code class="hljs language-css">.blue {
  color: blue;
}

.red {
  color: red;
}

.my-selector {
  @extend .red;
  @extend .blue;
}
</code></pre>
<p>Vous imaginez que <code>.blue</code> étant appliqué après dans <code>.my-selector</code>, il va
prendre la priorité. EH BAH NON, c'est <code>.red</code>, parce que sa déclaration est
située après <code>.blue</code>.</p>
<p>Si ce constat peut aussi permettre à ceux et celles qui utilisent des CSS
atomiques d'arrêter immédiatement :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.relative</span> {
  <span class="hljs-attribute">position</span>: relative;
}
<span class="hljs-selector-class">.absolute</span> {
  <span class="hljs-attribute">position</span>: absolute;
}
<span class="hljs-selector-class">.static</span> {
  <span class="hljs-attribute">position</span>: static;
}
</code></pre>
<p>Dans le cas précédent, si vous ajoutez une classe <code>relative</code> à un élement ayant
déjà la classe <code>static</code>, ça ne changera rien du tout, parce que <code>.static</code> est
défini après <code>.relative</code>. Génial, non ?</p>
<h3>Le futur de CSS</h3>
<p>Les variables sont une feature qui a été très demandée à CSS. Mais cette feature
va débarquer avec son lot de souci :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attribute">--mainColor</span>: blue;
}

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--mainColor);
}
</code></pre>
<p>C'est super, mais si quelqu'un vient ajouter :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-pseudo">:root</span> {
  <span class="hljs-attribute">--mainColor</span>: red;
}
</code></pre>
<p>quelque part, il y a deux cas :</p>
<ul>
<li>soit c'est chargé avant, et ça ne fait rien</li>
<li>soit c'est chargé après, et ça override toutes les propriétés utilisant
<code>--mainColor</code>. On est bien contents.</li>
</ul>
<h2>Vous ne pouvez pas vous permettre de laisser tomber CSS ?</h2>
<p>Dans ce cas, forcez vous à utiliser la
<a href="/fr/articles/css/bem/">méthodologie BEM</a>. Ça ne réglera pas tout, mais au moins
cela vous permettra d'éviter un maximum de conneries en vous forçant à découper
en composants isolés, et à mieux maîtriser la priorisation, puisque le scope
auquel vous devrez y veiller sera considérablement réduit :</p>
<pre><code class="hljs language-css"><span class="hljs-comment">/* Header.css */</span>
<span class="hljs-selector-class">.Header</span> {
}

<span class="hljs-selector-class">.Header-nav</span> {
}

<span class="hljs-comment">/* Nav.css */</span>
<span class="hljs-selector-class">.Nav</span> {
}

<span class="hljs-selector-class">.Nav-item</span> {
}

<span class="hljs-selector-class">.Nav-item--active</span> {
}
</code></pre>
<p>C'est quand même plus pratique à comprendre, non ?</p>
<p>Encore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les
<a href="/fr/articles/css/modules/">CSS modules</a>, qui limiteront de même le scope
d'application de vos feuilles de style.</p>
<h2>Vous pouvez vous permettre de laisser tomber CSS ?</h2>
<p>JavaScript vous permet déjà de bénéficier d'un système de modules, de variables,
de conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça,
vous maitrisez la priorisation, parce c'est que c'est vous qui décidez ce qui
s'applique :</p>
<pre><code class="hljs language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> { active, disabled } = <span class="hljs-built_in">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
          <span class="hljs-attr">...styles.myComponent</span>,
          <span class="hljs-attr">...</span>(<span class="hljs-attr">active</span> ? <span class="hljs-attr">styles.active</span> <span class="hljs-attr">:</span> <span class="hljs-attr">null</span>),
          <span class="hljs-attr">...</span>(<span class="hljs-attr">disabled</span> &amp;&amp; !<span class="hljs-attr">active</span> ? <span class="hljs-attr">styles.disabled</span> <span class="hljs-attr">:</span> <span class="hljs-attr">null</span>),
        }}
      &gt;</span>
        tadaa
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

<span class="hljs-keyword">const</span> styles = {
  <span class="hljs-attr">myComponent</span>: {
    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">18</span>,
  },
  <span class="hljs-attr">active</span>: {
    <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>,
  },
  <span class="hljs-attr">disabled</span>: {
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,
  },
};
</code></pre>
<p>Par ailleurs, avec certaines bibliothèques permettant naturellement l'usage
d'inline-styles (comme React), cela vous donne la possibilité d'avoir le style
et le markup dans le même fichier, sans avoir besoin de naviguer entre les
onglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si
ça vous fait plaisir).</p>
<p>En résumé, utiliser JS pour définir et appliquer les styles vous permet de
prendre le contrôle sur le styling de vos composants, tout en apportant le
confort d'un langage offrant naturellement de nombreux avantages. Si vous êtes
bloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos
possibilités. Le but, c'est d'éliminer les
<a href="https://github.com/necolas/react-native-web/blob/master/website/guides/style.md">7 maux de CSS</a>.</p>
<p>Bisous bisous.</p>
<h2>Edit</h2>
<p>Afin de répondre aux diverses incompréhensions et commentaires en réponse à
l’article, voilà un follow-up qui va tenter d’aller plus en profondeur dans la
critique de CSS.</p>
<p>Je vais donc répondre à
<a href="http://www.glazman.org/weblog/dotclear/index.php?post/2016/06/18/Pourquoi-il-n-aurait-pas-du-arrêter-d-utiliser-CSS">l’article de Daniel Glazman</a>,
ancien co-chairman du CSS Working Group.</p>
<p>Le premier point n’a rien à voir avec le sujet, mais l’auteur fait un parallèle
entre la réassignation dans JS et la mutabilité et absence de scope des
sélecteurs CSS. La comparaison n’a pas lieu d’être, parce que JS est un langage
de programmation. De plus, en JS, les variables ont une portée, et l’opérateur
<code>const</code> existe pour prévenir la réassignation. <code>&lt;/digression&gt;</code></p>
<p>Le grand problème de l’état actuel des sélecteurs CSS, c’est qu’ils n’offrent
naturellement aucune API (hors <em>Shadow DOM</em>) permettant de limiter le scope d’un
sélecteur sans augmenter sa spécificité. Si je veux ajouter des propriétés de
style à un élément comportant un certain sélecteur dans un certain contexte, je
suis obligé d’avoir connaissance de tous les sélecteurs correspondant
potentiellement à cet éléments, de vérifier leur spécificité, et possiblement
d’adapter le sélecteur simple que j’envisageais à l’origine pour pallier le
manque de spécificité. Super, ma codebase contient maintenant des sélecteurs
différents de leur sens original dans le simple but de les appliquer.</p>
<p>Lorsque je lis la réaction épidermique de l’auteur face à BEM, une méthodologie
ajoutant un namespace pour simuler ce scope côté utilisateur qui apporte un
minimum de sécurité lorsque l’on travaille sur un projet à grande échelle,
j’avoue un peu flipper quant à la conception des spécifications CSS.</p>
<p>BEM est une réponse de la communauté d’utilisateurs à plusieurs soucis qu’ils
ont rencontrés dans leurs utilisations variées de CSS. On dirait même dans sa
réponse qu’il n’a pas pris le temps de se renseigner sur la nature de la
méthodologie, qui ne consiste selon lui qu’à ajouter des indentations dont on se
fout parce que CSSOM les ignore. WTF.</p>
<p>Ignorer le feedback que constitue l’apparition de cette méthodologie et dénigrer
les utilisateurs pour qui elle règle des problèmes posés par le laxisme du
langage, ça ne fait pas avancer le langage, et ça ne donnera certainement pas
envie de retourner à CSS.</p>
<p>Concernant la spécificité des sélecteurs, évidemment qu’une quantité
astronomique de sites utilise les sélecteurs CSS, simplement parce qu’ils n’ont
pas eu d’alternative viable. Ça n’en fait pas une fonctionnalité bien conçue
pour autant.</p>
<p>Sur les régressions, l’idée à comprendre, c’est que l’absence de scope et de
namespace dans le langage peut créer des régressions potentiellement partout
dans un large site, parce qu’un sélecteur est global. Il n’y a pas moyen de
sécuriser un rayon d’action pour travailler, à moins de gérer le namespace
soi-même, dans le sélecteur.</p>
<p>Concernant le choix de priorisation des styles, c'est un fait que l'ordre de la
<code>DOMTokenList</code> n’a pas d'importance actuellement, et je ne fais que déplorer
qu’en utilisant des sélecteurs, le choix de l’application des styles ne puisse
pas se faire à l’endroit où l’élément est utilisé, avec la connaissance précise
de son contexte.</p>
<p>Sur le futur de CSS, le reproche que je dresse n'est pas comme ce qui est
interprété dans le post de l'auteur, disant que je râle parce que si l'on fait
un parallèle avec JS, on aurait :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
alert(a);
<span class="hljs-comment">// alerts 2</span>
</code></pre>
<p>C’est un comportement parfaitement attendu. Et ce n’est pas ce que j’ai dit, je
reproche à CSS de faire en sorte que, si l’on fait encore le parallèle :</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// coucou c&#x27;est CSS</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
alert(a);
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-comment">// alerts 2</span>
</code></pre>
<p>Sur ma proposition alternative, outre être <em>“une horreur non-maintenable,
verbeuse et error-prone”</em>, on va regarder ce que ça donne sur un cas plus simple
:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-comment">// un système de modules analysable statiquement</span>
<span class="hljs-keyword">import</span> { mainBlue, mainRed } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../utils/Colors&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> props =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-comment">// on peut appliquer un style dont le rayon d&#x27;action est par définition</span>
    <span class="hljs-comment">// limité à l’élément sur lequel on le place</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
      {list.map((item, index) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.item}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
              <span class="hljs-attr">...styles.text</span>,
              // <span class="hljs-attr">appliquer</span> <span class="hljs-attr">un</span> <span class="hljs-attr">style</span> <span class="hljs-attr">conditionn</span>é <span class="hljs-attr">par</span> <span class="hljs-attr">le</span> <span class="hljs-attr">contexte</span> <span class="hljs-attr">est</span> <span class="hljs-attr">tr</span>è<span class="hljs-attr">s</span> <span class="hljs-attr">simple</span>
              // <span class="hljs-attr">et</span> <span class="hljs-attr">permet</span> <span class="hljs-attr">de</span> <span class="hljs-attr">prioriser</span> à <span class="hljs-attr">la</span> <span class="hljs-attr">d</span>é<span class="hljs-attr">finition</span> <span class="hljs-attr">du</span> <span class="hljs-attr">markup</span>
              <span class="hljs-attr">...</span>(<span class="hljs-attr">index</span> % <span class="hljs-attr">2</span> === <span class="hljs-string">0</span> &amp;&amp; <span class="hljs-attr">styles.oddText</span>),
            }}
          &gt;</span>
            {item.text}
          <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// la feuille de style est limitée au module</span>
<span class="hljs-keyword">const</span> styles = {
  <span class="hljs-attr">container</span>: {
    <span class="hljs-attr">display</span>: <span class="hljs-string">&quot;flex&quot;</span>,
    <span class="hljs-attr">flexDirection</span>: <span class="hljs-string">&quot;row&quot;</span>,
  },
  <span class="hljs-attr">item</span>: {
    <span class="hljs-attr">flexBasis</span>: <span class="hljs-number">200</span>,
  },
  <span class="hljs-attr">text</span>: {
    <span class="hljs-comment">// peut utiliser des variables qui ne seront pas écrasées si j&#x27;en définis</span>
    <span class="hljs-comment">// une avec le même nom ailleurs dans l&#x27;app</span>
    <span class="hljs-attr">color</span>: mainBlue,
  },
  <span class="hljs-attr">oddText</span>: {
    <span class="hljs-attr">color</span>: mainRed,
  },
};
</code></pre>
<p>C’est juste une application d’une approche centrée sur les composants.
L’important, c’est d’isoler ces composants pour les rendre facilement
réutilisables, prévenir les effets de bord, et passer moins de temps à essayer
de travailler avec des propriétés du langage qui nous gênent dans notre travail
de tous les jours. Réduire la liberté d’utilisation permet ici d’apporter des
propriétés (immutabilité des styles, application déterministe des styles, scope)
qui nous permettent de raisonner notre code de manière beaucoup plus simple.</p>
<p>Si l’on regarde du côté des CSS modules, qu’est-ce que ça fait exactement ? La
même chose. Le tooling va limiter le scope d’une feuille de style en rendant
opaques et globalement uniques les sélecteurs. Le CSS peut être utilisé en
target de compilation sans problème, et la plupart des solutions rendant son
utilisation confortable font une chose simple : contraindre à une utilisation
plus stricte en masquant des parties trop laxistes du langage. C’est ce que le
tooling JS a connu depuis quelques années, et on ne s’en porte que mieux.</p>
<p>Le dernier argument utilisé est que « si le monde entier a adopté CSS (y compris
le monde de l'édition qui vient pourtant de solutions assez radicalement
différentes du Web), c'est bien parce que c'est bien et que ça marche ».
Qu’est-ce qu’on peut répondre sinon que CSS a été adopté avant que les besoins
du web n'aient suffisamment évolué pour que CSS dans son état actuel ait un
énorme potentiel de fragilisation d’une codebase. Ne pas remettre en question le
langage parce que ses utilisateurs n’ont pas d’alternative, c’est condamner le
langage. C’est comme si la SNCF disait « BOARF ça sert à rien de faire arriver
les trains à l’heure, vu que tout le monde le prend déjà c’est que c’est nickel
». Du coup, faut pas venir s’étonner que certains de ces utilisateurs aillent
chercher des alternatives ailleurs.</p>
<p>En conclusion, je déplore vraiment l'absence d'intérêt apparent de l'auteur pour
écouter le feedback des utilisateurs sur les problèmes d'un langage. Il faut
regarder ailleurs, et ne pas ignorer ou mépriser ce que les utilisateurs font de
leur côté pour travailler plus sainement, ça pourrait même donner des idées pour
améliorer ce qui fait perdre du temps aux utilisateurs.</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Pourquoi%20j&#x27;ai%20arr%C3%AAt%C3%A9%20d&#x27;utiliser%20CSS%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fpourquoi-j-ai-arrete-d-utiliser-css" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"pourquoi-j-ai-arrete-d-utiliser-css","v":{"_0":{"TAG":0,"_0":{"slug":"pourquoi-j-ai-arrete-d-utiliser-css","filename":"2016-06-16-pourquoi-j-ai-arrete-d-utiliser-css","title":"Pourquoi j'ai arrêté d'utiliser CSS","date":"Thu, 16 Jun 2016 00:00:00 GMT","draft":false,"meta":{"date":"2016-06-16T00:00:00.000Z","title":"Pourquoi j'ai arrêté d'utiliser CSS","author":"bloodyowl","oldSlug":"css/stop-css","slug":"pourquoi-j-ai-arrete-d-utiliser-css"},"body":"<p>CSS est un langage horriblement dangereux, parce qu'il mêle des concepts\ncomplètement pétés et une folle capacité à faire confondre facilité et\nsimplicité aux gens qui l'utilisent.</p>\n<h2>Qu'est-ce qui ne va pas ?</h2>\n<p>À l'origine, CSS a été conçu pour styler des documents, pas des applications. Du\ncoup lorsqu'on doit <em>scale</em>, c'est rapidement douloureux.</p>\n<h3>Les sélecteurs</h3>\n<p>Les sélecteurs sont des <strong>variables globales mutables</strong>. Lorsque vous faites :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.selector</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n}\n</code></pre>\n<p>C'est comme si en JavaScript vous faisiez :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.selector = (<span class=\"hljs-built_in\">window</span>.selector || []).concat({\n  <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">&quot;1rem&quot;</span>,\n});\n</code></pre>\n<p>Ça veut dire que :</p>\n<ul>\n<li>La définition d'un style associé à un sélecteur peut être redéfinie ailleurs</li>\n<li>Si on associe plusieurs styles à un sélecteur, les derniers définis dans le\nCSS auront toujours la priorité</li>\n<li>Quelqu'un peut péter les styles d'un composant pour peu qu'il ne sache pas\nqu'un sélecteur est utilisé ailleurs</li>\n</ul>\n<h3>La spécificité</h3>\n<p>Alors ça, c'est particulièrement drôle : la spécificité d'un sélecteur va\ndéfinir la priorité d'application d'un style.</p>\n<table>\n<thead>\n<tr><th>Sélecteur</th><th>Spécificité</th></tr>\n</thead>\n<tbody>\n<tr><td><code>*</code></td><td>0,0,0,0</td></tr>\n<tr><td><code>li</code></td><td>0,0,0,1</td></tr>\n<tr><td><code>li:first-line</code></td><td>0,0,0,2</td></tr>\n<tr><td><code>ul li</code></td><td>0,0,0,2</td></tr>\n<tr><td><code>ul ol+li</code></td><td>0,0,0,3</td></tr>\n<tr><td><code>h1 + *[rel=up]</code></td><td>0,0,1,1</td></tr>\n<tr><td><code>ul ol li.red</code></td><td>0,0,1,3</td></tr>\n<tr><td><code>li.red.level</code></td><td>0,0,2,1</td></tr>\n<tr><td><code>#x34y</code></td><td>0,1,0,0</td></tr>\n</tbody>\n</table>\n<p>Si le style est défini dans l'attribut <code>style</code>, la spécificité est de 1,0,0,0.\nSi une valeur associée à une propriété est suffixée d'un <code>!important</code>, elle\nprend quoi qu'il arrive l'ascendance.</p>\n<p>Si on résume, on nage en plein délire, la priorité se définit dans l'ordre par :\nla présence de <code>!important</code>, la façon de définir le style, la spécificité du\nsélecteur utilisé puis par l'ordre de définition dans l'ensemble des CSS de la\npage. Évidemment, à l'époque où on n'avait qu'une pauvre petite feuille de style\npour l'ensemble de son site, ça marchait ; plus maintenant.</p>\n<h3>Les régressions</h3>\n<p>Prenons un exemple tout bête :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.item</span> {\n  <span class=\"hljs-attribute\">display</span>: block;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1rem</span>;\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n\n<span class=\"hljs-selector-class\">.some-context</span> <span class=\"hljs-selector-class\">.item</span> {\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n</code></pre>\n<p>Quelqu'un de la team modifie <code>.item</code> :</p>\n<pre><code class=\"hljs language-diff\"> .item {\n   display: block;\n   font-size: 1rem;\n   color: blue;\n<span class=\"hljs-addition\">+  border: 1px solid red;</span>\n }\n\n .some-context .item {\n   display: inline-block;\n   color: red;\n}\n</code></pre>\n<p>Super, une regression dans <code>some-context</code>. Face à ça, deux possibilités :</p>\n<ul>\n<li>Vous vous foutez d'avoir des régressions qui pètent votre site</li>\n<li>À chaque changement minime du CSS vous vérifiez l'intégralité du site et\ntestez tous les comportements dans tous les contextes.</li>\n</ul>\n<h3>Le choix de priorisation des styles</h3>\n<p>Ce serait pas mal de décider quel <code>className</code> est appliqué en priorité :</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;blue red&quot;</span>&gt;</span>text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;red blue&quot;</span>&gt;</span>text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>mais bien évidemment non, comme vu plus haut, c'est le foutu ordre de définition\ndes sélecteurs qui décide. Je vous laisse imaginer le bordel si on charge les\nfeuilles de style à la demande, selon les actions utilisateur.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.blue</span> {\n  <span class=\"hljs-attribute\">color</span>: blue;\n}\n<span class=\"hljs-selector-class\">.red</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n</code></pre>\n<p>C'est pire si vous utilisez un préprocesseur tel que Sass et LESS. Lorsque vous\nfaites un :</p>\n<pre><code class=\"hljs language-css\">.blue {\n  color: blue;\n}\n\n.red {\n  color: red;\n}\n\n.my-selector {\n  @extend .red;\n  @extend .blue;\n}\n</code></pre>\n<p>Vous imaginez que <code>.blue</code> étant appliqué après dans <code>.my-selector</code>, il va\nprendre la priorité. EH BAH NON, c'est <code>.red</code>, parce que sa déclaration est\nsituée après <code>.blue</code>.</p>\n<p>Si ce constat peut aussi permettre à ceux et celles qui utilisent des CSS\natomiques d'arrêter immédiatement :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.relative</span> {\n  <span class=\"hljs-attribute\">position</span>: relative;\n}\n<span class=\"hljs-selector-class\">.absolute</span> {\n  <span class=\"hljs-attribute\">position</span>: absolute;\n}\n<span class=\"hljs-selector-class\">.static</span> {\n  <span class=\"hljs-attribute\">position</span>: static;\n}\n</code></pre>\n<p>Dans le cas précédent, si vous ajoutez une classe <code>relative</code> à un élement ayant\ndéjà la classe <code>static</code>, ça ne changera rien du tout, parce que <code>.static</code> est\ndéfini après <code>.relative</code>. Génial, non ?</p>\n<h3>Le futur de CSS</h3>\n<p>Les variables sont une feature qui a été très demandée à CSS. Mais cette feature\nva débarquer avec son lot de souci :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:root</span> {\n  <span class=\"hljs-attribute\">--mainColor</span>: blue;\n}\n\n<span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--mainColor);\n}\n</code></pre>\n<p>C'est super, mais si quelqu'un vient ajouter :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:root</span> {\n  <span class=\"hljs-attribute\">--mainColor</span>: red;\n}\n</code></pre>\n<p>quelque part, il y a deux cas :</p>\n<ul>\n<li>soit c'est chargé avant, et ça ne fait rien</li>\n<li>soit c'est chargé après, et ça override toutes les propriétés utilisant\n<code>--mainColor</code>. On est bien contents.</li>\n</ul>\n<h2>Vous ne pouvez pas vous permettre de laisser tomber CSS ?</h2>\n<p>Dans ce cas, forcez vous à utiliser la\n<a href=\"/fr/articles/css/bem/\">méthodologie BEM</a>. Ça ne réglera pas tout, mais au moins\ncela vous permettra d'éviter un maximum de conneries en vous forçant à découper\nen composants isolés, et à mieux maîtriser la priorisation, puisque le scope\nauquel vous devrez y veiller sera considérablement réduit :</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* Header.css */</span>\n<span class=\"hljs-selector-class\">.Header</span> {\n}\n\n<span class=\"hljs-selector-class\">.Header-nav</span> {\n}\n\n<span class=\"hljs-comment\">/* Nav.css */</span>\n<span class=\"hljs-selector-class\">.Nav</span> {\n}\n\n<span class=\"hljs-selector-class\">.Nav-item</span> {\n}\n\n<span class=\"hljs-selector-class\">.Nav-item--active</span> {\n}\n</code></pre>\n<p>C'est quand même plus pratique à comprendre, non ?</p>\n<p>Encore mieux, si vous avez du tooling à la webpack, vous pouvez utiliser les\n<a href=\"/fr/articles/css/modules/\">CSS modules</a>, qui limiteront de même le scope\nd'application de vos feuilles de style.</p>\n<h2>Vous pouvez vous permettre de laisser tomber CSS ?</h2>\n<p>JavaScript vous permet déjà de bénéficier d'un système de modules, de variables,\nde conditions, de fonctions réutilisables, et tout ça sans hack. En plus de ça,\nvous maitrisez la priorisation, parce c'est que c'est vous qui décidez ce qui\ns'applique :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> { active, disabled } = <span class=\"hljs-built_in\">this</span>.props;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n          <span class=\"hljs-attr\">...styles.myComponent</span>,\n          <span class=\"hljs-attr\">...</span>(<span class=\"hljs-attr\">active</span> ? <span class=\"hljs-attr\">styles.active</span> <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>),\n          <span class=\"hljs-attr\">...</span>(<span class=\"hljs-attr\">disabled</span> &amp;&amp; !<span class=\"hljs-attr\">active</span> ? <span class=\"hljs-attr\">styles.disabled</span> <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>),\n        }}\n      &gt;</span>\n        tadaa\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> styles = {\n  <span class=\"hljs-attr\">myComponent</span>: {\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">18</span>,\n  },\n  <span class=\"hljs-attr\">active</span>: {\n    <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n  },\n  <span class=\"hljs-attr\">disabled</span>: {\n    <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.5</span>,\n  },\n};\n</code></pre>\n<p>Par ailleurs, avec certaines bibliothèques permettant naturellement l'usage\nd'inline-styles (comme React), cela vous donne la possibilité d'avoir le style\net le markup dans le même fichier, sans avoir besoin de naviguer entre les\nonglets de votre éditeur (vous pouvez cependant séparer en plusieurs fichiers si\nça vous fait plaisir).</p>\n<p>En résumé, utiliser JS pour définir et appliquer les styles vous permet de\nprendre le contrôle sur le styling de vos composants, tout en apportant le\nconfort d'un langage offrant naturellement de nombreux avantages. Si vous êtes\nbloqués avec CSS, partez sur les CSS modules ou la méthologie BEM selon vos\npossibilités. Le but, c'est d'éliminer les\n<a href=\"https://github.com/necolas/react-native-web/blob/master/website/guides/style.md\">7 maux de CSS</a>.</p>\n<p>Bisous bisous.</p>\n<h2>Edit</h2>\n<p>Afin de répondre aux diverses incompréhensions et commentaires en réponse à\nl’article, voilà un follow-up qui va tenter d’aller plus en profondeur dans la\ncritique de CSS.</p>\n<p>Je vais donc répondre à\n<a href=\"http://www.glazman.org/weblog/dotclear/index.php?post/2016/06/18/Pourquoi-il-n-aurait-pas-du-arrêter-d-utiliser-CSS\">l’article de Daniel Glazman</a>,\nancien co-chairman du CSS Working Group.</p>\n<p>Le premier point n’a rien à voir avec le sujet, mais l’auteur fait un parallèle\nentre la réassignation dans JS et la mutabilité et absence de scope des\nsélecteurs CSS. La comparaison n’a pas lieu d’être, parce que JS est un langage\nde programmation. De plus, en JS, les variables ont une portée, et l’opérateur\n<code>const</code> existe pour prévenir la réassignation. <code>&lt;/digression&gt;</code></p>\n<p>Le grand problème de l’état actuel des sélecteurs CSS, c’est qu’ils n’offrent\nnaturellement aucune API (hors <em>Shadow DOM</em>) permettant de limiter le scope d’un\nsélecteur sans augmenter sa spécificité. Si je veux ajouter des propriétés de\nstyle à un élément comportant un certain sélecteur dans un certain contexte, je\nsuis obligé d’avoir connaissance de tous les sélecteurs correspondant\npotentiellement à cet éléments, de vérifier leur spécificité, et possiblement\nd’adapter le sélecteur simple que j’envisageais à l’origine pour pallier le\nmanque de spécificité. Super, ma codebase contient maintenant des sélecteurs\ndifférents de leur sens original dans le simple but de les appliquer.</p>\n<p>Lorsque je lis la réaction épidermique de l’auteur face à BEM, une méthodologie\najoutant un namespace pour simuler ce scope côté utilisateur qui apporte un\nminimum de sécurité lorsque l’on travaille sur un projet à grande échelle,\nj’avoue un peu flipper quant à la conception des spécifications CSS.</p>\n<p>BEM est une réponse de la communauté d’utilisateurs à plusieurs soucis qu’ils\nont rencontrés dans leurs utilisations variées de CSS. On dirait même dans sa\nréponse qu’il n’a pas pris le temps de se renseigner sur la nature de la\nméthodologie, qui ne consiste selon lui qu’à ajouter des indentations dont on se\nfout parce que CSSOM les ignore. WTF.</p>\n<p>Ignorer le feedback que constitue l’apparition de cette méthodologie et dénigrer\nles utilisateurs pour qui elle règle des problèmes posés par le laxisme du\nlangage, ça ne fait pas avancer le langage, et ça ne donnera certainement pas\nenvie de retourner à CSS.</p>\n<p>Concernant la spécificité des sélecteurs, évidemment qu’une quantité\nastronomique de sites utilise les sélecteurs CSS, simplement parce qu’ils n’ont\npas eu d’alternative viable. Ça n’en fait pas une fonctionnalité bien conçue\npour autant.</p>\n<p>Sur les régressions, l’idée à comprendre, c’est que l’absence de scope et de\nnamespace dans le langage peut créer des régressions potentiellement partout\ndans un large site, parce qu’un sélecteur est global. Il n’y a pas moyen de\nsécuriser un rayon d’action pour travailler, à moins de gérer le namespace\nsoi-même, dans le sélecteur.</p>\n<p>Concernant le choix de priorisation des styles, c'est un fait que l'ordre de la\n<code>DOMTokenList</code> n’a pas d'importance actuellement, et je ne fais que déplorer\nqu’en utilisant des sélecteurs, le choix de l’application des styles ne puisse\npas se faire à l’endroit où l’élément est utilisé, avec la connaissance précise\nde son contexte.</p>\n<p>Sur le futur de CSS, le reproche que je dresse n'est pas comme ce qui est\ninterprété dans le post de l'auteur, disant que je râle parce que si l'on fait\nun parallèle avec JS, on aurait :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\nalert(a);\n<span class=\"hljs-comment\">// alerts 2</span>\n</code></pre>\n<p>C’est un comportement parfaitement attendu. Et ce n’est pas ce que j’ai dit, je\nreproche à CSS de faire en sorte que, si l’on fait encore le parallèle :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// coucou c&#x27;est CSS</span>\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>;\nalert(a);\n<span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-comment\">// alerts 2</span>\n</code></pre>\n<p>Sur ma proposition alternative, outre être <em>“une horreur non-maintenable,\nverbeuse et error-prone”</em>, on va regarder ce que ça donne sur un cas plus simple\n:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-comment\">// un système de modules analysable statiquement</span>\n<span class=\"hljs-keyword\">import</span> { mainBlue, mainRed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../utils/Colors&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> props =&gt; {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-comment\">// on peut appliquer un style dont le rayon d&#x27;action est par définition</span>\n    <span class=\"hljs-comment\">// limité à l’élément sur lequel on le place</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.container}</span>&gt;</span>\n      {list.map((item, index) =&gt; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{styles.item}</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>\n            <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n              <span class=\"hljs-attr\">...styles.text</span>,\n              // <span class=\"hljs-attr\">appliquer</span> <span class=\"hljs-attr\">un</span> <span class=\"hljs-attr\">style</span> <span class=\"hljs-attr\">conditionn</span>é <span class=\"hljs-attr\">par</span> <span class=\"hljs-attr\">le</span> <span class=\"hljs-attr\">contexte</span> <span class=\"hljs-attr\">est</span> <span class=\"hljs-attr\">tr</span>è<span class=\"hljs-attr\">s</span> <span class=\"hljs-attr\">simple</span>\n              // <span class=\"hljs-attr\">et</span> <span class=\"hljs-attr\">permet</span> <span class=\"hljs-attr\">de</span> <span class=\"hljs-attr\">prioriser</span> à <span class=\"hljs-attr\">la</span> <span class=\"hljs-attr\">d</span>é<span class=\"hljs-attr\">finition</span> <span class=\"hljs-attr\">du</span> <span class=\"hljs-attr\">markup</span>\n              <span class=\"hljs-attr\">...</span>(<span class=\"hljs-attr\">index</span> % <span class=\"hljs-attr\">2</span> === <span class=\"hljs-string\">0</span> &amp;&amp; <span class=\"hljs-attr\">styles.oddText</span>),\n            }}\n          &gt;</span>\n            {item.text}\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      ))}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-comment\">// la feuille de style est limitée au module</span>\n<span class=\"hljs-keyword\">const</span> styles = {\n  <span class=\"hljs-attr\">container</span>: {\n    <span class=\"hljs-attr\">display</span>: <span class=\"hljs-string\">&quot;flex&quot;</span>,\n    <span class=\"hljs-attr\">flexDirection</span>: <span class=\"hljs-string\">&quot;row&quot;</span>,\n  },\n  <span class=\"hljs-attr\">item</span>: {\n    <span class=\"hljs-attr\">flexBasis</span>: <span class=\"hljs-number\">200</span>,\n  },\n  <span class=\"hljs-attr\">text</span>: {\n    <span class=\"hljs-comment\">// peut utiliser des variables qui ne seront pas écrasées si j&#x27;en définis</span>\n    <span class=\"hljs-comment\">// une avec le même nom ailleurs dans l&#x27;app</span>\n    <span class=\"hljs-attr\">color</span>: mainBlue,\n  },\n  <span class=\"hljs-attr\">oddText</span>: {\n    <span class=\"hljs-attr\">color</span>: mainRed,\n  },\n};\n</code></pre>\n<p>C’est juste une application d’une approche centrée sur les composants.\nL’important, c’est d’isoler ces composants pour les rendre facilement\nréutilisables, prévenir les effets de bord, et passer moins de temps à essayer\nde travailler avec des propriétés du langage qui nous gênent dans notre travail\nde tous les jours. Réduire la liberté d’utilisation permet ici d’apporter des\npropriétés (immutabilité des styles, application déterministe des styles, scope)\nqui nous permettent de raisonner notre code de manière beaucoup plus simple.</p>\n<p>Si l’on regarde du côté des CSS modules, qu’est-ce que ça fait exactement ? La\nmême chose. Le tooling va limiter le scope d’une feuille de style en rendant\nopaques et globalement uniques les sélecteurs. Le CSS peut être utilisé en\ntarget de compilation sans problème, et la plupart des solutions rendant son\nutilisation confortable font une chose simple : contraindre à une utilisation\nplus stricte en masquant des parties trop laxistes du langage. C’est ce que le\ntooling JS a connu depuis quelques années, et on ne s’en porte que mieux.</p>\n<p>Le dernier argument utilisé est que « si le monde entier a adopté CSS (y compris\nle monde de l'édition qui vient pourtant de solutions assez radicalement\ndifférentes du Web), c'est bien parce que c'est bien et que ça marche ».\nQu’est-ce qu’on peut répondre sinon que CSS a été adopté avant que les besoins\ndu web n'aient suffisamment évolué pour que CSS dans son état actuel ait un\nénorme potentiel de fragilisation d’une codebase. Ne pas remettre en question le\nlangage parce que ses utilisateurs n’ont pas d’alternative, c’est condamner le\nlangage. C’est comme si la SNCF disait « BOARF ça sert à rien de faire arriver\nles trains à l’heure, vu que tout le monde le prend déjà c’est que c’est nickel\n». Du coup, faut pas venir s’étonner que certains de ces utilisateurs aillent\nchercher des alternatives ailleurs.</p>\n<p>En conclusion, je déplore vraiment l'absence d'intérêt apparent de l'auteur pour\nécouter le feedback des utilisateurs sur les problèmes d'un langage. Il faut\nregarder ailleurs, et ne pas ignorer ou mépriser ce que les utilisateurs font de\nleur côté pour travailler plus sainement, ça pourrait même donner des idées pour\naméliorer ce qui fait perdre du temps aux utilisateurs.</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>