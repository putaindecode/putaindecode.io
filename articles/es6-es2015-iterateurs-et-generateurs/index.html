<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">ES6, ES2015 : itérateurs et générateurs | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="ES6, ES2015 : itérateurs et générateurs | Putain de code" property="og:title"/><meta data-react-helmet="true" content="ES6, ES2015 : itérateurs et générateurs | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par naholyr" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/es6-es2015-iterateurs-et-generateurs" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(183, 100%, 35%), hsl(152, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">ES6, ES2015 : itérateurs et générateurs</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/naholyr"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="naholyr" src="https://avatars.githubusercontent.com/naholyr?size=64"/><div>naholyr<!-- --> <!-- -->•<!-- --> <!-- -->2015/12/10</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Un gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent,
appelées &quot;générateurs&quot;. ES6/2015 apporte énormément de &quot;sucres syntaxiques&quot;,
même s'ils sont terriblement pratiques. Les valeurs par défaut, l'affectation
par déstructuration, les fonctions flêchées… Tout ça n'apporte pas de réelle
nouvelle fonctionnalité. C'est un peu différent pour les générateurs qui vont
permettre de prendre le contrôle sur l'éxécution d'une fonction depuis
l'extérieur.</p>
<h2>Fonction &quot;en pause&quot;</h2>
<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par
l'astérisque n'est jamais exécutée directement, à la place, elle retourne un
<em>itérateur</em>. Un générateur est donc capable de s'interrompre (d'ailleurs, il
l'est par défaut). Il est également capable de reprendre là où il s'était arrêté
: l'itérateur retourné est un objet exposant une méthode <code>next</code> qui lorsqu'elle
est appelée demande au générateur de reprendre là où il en était.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">idleFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;World&quot;</span>);
}

<span class="hljs-keyword">const</span> iterator = idleFunction();
<span class="hljs-comment">// L&#x27;exécution de la fonction est interrompue en attente d&#x27;être &quot;débloquée&quot;</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>);
iterator.next(); <span class="hljs-comment">// L&#x27;éxécution reprend et on affiche &quot;World&quot;</span>
</code></pre>
<p>Notez qu'il ne s'agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,
son traitement sera repris plus tard, pendant ce temps l'<em>event-loop</em> continue
sa petite vie.</p>
<h2>Reprise du traitement et émission de valeur avec <code>yield</code></h2>
<p>La méthode <code>next()</code> de l'itérateur retourne un objet possédant les propriétés
suivantes :</p>
<ul>
<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>
<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>
</ul>
<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir une
valeur et de remettre en pause l'exécution de la fonction. Le principe étant
qu'on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement
<code>return</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">const</span> iterator = numbers();
iterator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next(); <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la
propriété <code>value</code> de la dernière itération.</p>
<h3><em>Use case</em> : listes infinies</h3>
<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de
longueur non définie à l'avance. On peut parcourir une suite dont on ne sait pas
à l'avance <em>combien</em> d'éléments on veut, par exemple récupérer tous les éléments
de la suite de Fibonacci inférieurs à 100 :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fibo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b];
    <span class="hljs-keyword">yield</span> a;
  }
}

<span class="hljs-keyword">const</span> iterator = fibo();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n);
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span>
</code></pre>
<p>Note : l'opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>
<h2>Passage de valeur au générateur</h2>
<p>On a vu que <code>yield</code> permettait d'émettre une valeur depuis le générateur vers le
code contrôleur. Mais le sens inverse est également possible : la méthode <code>next</code>
de l'itérateur accepte une valeur en paramètre, qui sera alors retournée par
l'appel correspondant à <code>yield</code>. Exemple :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">math</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Le premier appel à next() permet de &quot;démarrer&quot; le générateur</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span>; <span class="hljs-comment">// la valeur de la première itération sera undefined</span>
  <span class="hljs-comment">// x = le paramètre du second appel à next()</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span>; <span class="hljs-comment">// valeur de la seconde itération : x + 1</span>
  <span class="hljs-comment">// y = paramètre du troisième appel à next()</span>
  <span class="hljs-keyword">yield</span> y; <span class="hljs-comment">// valeur de la troisième itération : y</span>
  <span class="hljs-comment">// le 4e appel (et +) à next() retournent { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math();
iterator.next(<span class="hljs-number">42</span>); <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un paramètre au premier appel à next() n&#x27;est pas utile : cette valeur</span>
<span class="hljs-comment">// n&#x27;est pas accessible dans le générateur car aucun &quot;yield&quot; correspondant</span>

iterator.next(<span class="hljs-number">33</span>); <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le générateur</span>
iterator.next(<span class="hljs-number">27</span>); <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le générateur</span>
iterator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>
n'importe quel type de donnée : une fonction, un objet, un autre itérateur… Les
possibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>
<h3><em>Use case</em> : co-routines</h3>
<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à
<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est
libre d'appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>
<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et
quand elles peuvent reprendre leur traitement. Et si… notre générateur émettait
des promesses ? Histoire d'expliquer à son code contrôleur <em>quand</em> il est sûr de
reprendre le traitement. Et si ce code contrôleur, voyant qu'il récupère une
promesse, attendait que cette dernière soit résolue pour transmettre au
générateur en retour la valeur résolue ? Dans ce cas le générateur pourrait
disposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de
traitements asynchrones :</p>
<pre><code class="hljs language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Ajax request…&quot;</span>);
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">&quot;http://my.api/get&quot;</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Work…&quot;</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Save…&quot;</span>);
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">&quot;http://my.api/post&quot;</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OK.&quot;</span>);
}); <span class="hljs-comment">// Ajax request… Work… Save… OK.</span>
</code></pre>
<p>Ne serait-ce pas merveilleux ? C'est le <em><em>use case</em></em> le plus intéressant pour
nous au quotidien, et c'est assez simple en fait :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator(); <span class="hljs-comment">// en pause…</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) {
      <span class="hljs-comment">// Le générateur a return&#x27;é, fin du game</span>
      <span class="hljs-keyword">return</span> iteration.value;
    }

    <span class="hljs-comment">// c&#x27;est un générateur de promesse, dont on attend la résolution ici</span>
    <span class="hljs-keyword">return</span> iteration.value.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
      <span class="hljs-comment">// La promesse est résolue, on peut repasser sa valeur au générateur</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result); <span class="hljs-comment">// cette valeur est return&#x27;ée par</span>
      <span class="hljs-comment">// le même &quot;yield&quot; qui a émis la promesse, ça tombe bien :)</span>

      <span class="hljs-comment">// Puis on relance notre boucle, et on continue récursivement</span>
      <span class="hljs-keyword">return</span> next(nextIteration);
    });
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next(); <span class="hljs-comment">// exécution reprise jusqu&#x27;au prochain &quot;yield&quot;</span>
  <span class="hljs-comment">// le générateur est remis en pause jusqu&#x27;au prochain appel à &quot;iter.next&quot;</span>

  <span class="hljs-comment">// Première itération de la boucle</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration);
}
</code></pre>
<h2>More! more! more!</h2>
<h3>Gestion d'erreur</h3>
<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux
directions. Le générateur peut <code>throw</code> vers le code contrôleur (le code est
synchrone) :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fail</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oops&quot;</span>);
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">const</span> iterator = fail();
iterator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next(); <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e; <span class="hljs-comment">// Error(&#x27;oops&#x27;)</span>
}
</code></pre>
<p>Mais le code contrôleur peut également émettre une erreur vers le générateur
avec la méthode <code>throw</code> de l'itérateur :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fail</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e);
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">const</span> iterator = fail();
iterator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;nope&quot;</span>)); <span class="hljs-comment">// affiche &quot;[Error: nope]&quot;</span>
iterator.next(); <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>
l'exécution du générateur, qui va alors jusqu'au premier <code>yield</code>, évalue
l'expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en
pause. C'est au second <code>yield</code> seulement que l'exécution reprend <strong>à partir de
<code>yield 1</code></strong>. C'est une partie que je trouve contre-intuitive et que j'ai eu du
mal à assimiler.</p>
<h3>Délégation</h3>
<p>L'opérateur <code>yield*</code> permet d'émettre les valeurs d'un autre itérateur, par
exemple :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">oneToThree</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">zeroToFour</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">yield</span>* oneToThree();
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
}
</code></pre>
<p>Cela fonction bien sûr avec tous
<a href="/fr/articles/js/es2015/iterators/">les <em>itérables</em></a> : <code>yield * [1, 2, 3]</code> est
valide par exemple.</p>
<h3>Retour anticipé</h3>
<p>Il est possible de terminer le traitement d'un générateur depuis le code
contrôleur avec la méthode <code>return</code> de l'itérateur. Tout se passera comme si le
générateur se terminait immédiatement avec la valeur de retour fournie.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
}

<span class="hljs-keyword">const</span> iterator = numbers();
iterator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>); <span class="hljs-comment">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>
iterator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<h2>Conclusion</h2>
<p>Un habituel petit coup d'œil sur
<a href="https://kangax.github.io/compat-table/es6/#test-generators">la compatibilité</a> :</p>
<ul>
<li>Les navigateurs modernes (donc pas IE)</li>
<li>IE Edge ≥ 13</li>
<li>Niveau polyfill, c'est vers Babel ou Traceur qu'il faudra se tourner</li>
</ul>
<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent
d'inverser la responsabilité : c'est le code appelant qui prend le pouvoir sur
la façon dont va s'exécuter la fonction appelée. Ils représentent le premier pas
vers d'autres concepts qui bouleverseront probablement votre façon de coder dans
quelques mois/années : fonctions asynchrones, observables… prennent leurs
racines dans les générateurs. Les comprendre permettra de mieux appréhender de
futures fonctionnalités.</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=ES6%2C%20ES2015%20%3A%20it%C3%A9rateurs%20et%20g%C3%A9n%C3%A9rateurs%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fes6-es2015-iterateurs-et-generateurs" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"es6-es2015-iterateurs-et-generateurs","v":{"_0":{"TAG":0,"_0":{"slug":"es6-es2015-iterateurs-et-generateurs","filename":"2015-12-10-es6-es2015-iterateurs-et-generateurs","title":"ES6, ES2015 : itérateurs et générateurs","date":"Thu, 10 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-10T00:00:00.000Z","title":"ES6, ES2015 : itérateurs et générateurs","author":"naholyr","oldSlug":"js/es2015/generators","slug":"es6-es2015-iterateurs-et-generateurs"},"body":"<p>Un gros morceau aujourd'hui : les itérateurs et les fonctions qui les génèrent,\nappelées &quot;générateurs&quot;. ES6/2015 apporte énormément de &quot;sucres syntaxiques&quot;,\nmême s'ils sont terriblement pratiques. Les valeurs par défaut, l'affectation\npar déstructuration, les fonctions flêchées… Tout ça n'apporte pas de réelle\nnouvelle fonctionnalité. C'est un peu différent pour les générateurs qui vont\npermettre de prendre le contrôle sur l'éxécution d'une fonction depuis\nl'extérieur.</p>\n<h2>Fonction &quot;en pause&quot;</h2>\n<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par\nl'astérisque n'est jamais exécutée directement, à la place, elle retourne un\n<em>itérateur</em>. Un générateur est donc capable de s'interrompre (d'ailleurs, il\nl'est par défaut). Il est également capable de reprendre là où il s'était arrêté\n: l'itérateur retourné est un objet exposant une méthode <code>next</code> qui lorsqu'elle\nest appelée demande au générateur de reprendre là où il en était.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">idleFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;World&quot;</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = idleFunction();\n<span class=\"hljs-comment\">// L&#x27;exécution de la fonction est interrompue en attente d&#x27;être &quot;débloquée&quot;</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Hello&quot;</span>);\niterator.next(); <span class=\"hljs-comment\">// L&#x27;éxécution reprend et on affiche &quot;World&quot;</span>\n</code></pre>\n<p>Notez qu'il ne s'agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,\nson traitement sera repris plus tard, pendant ce temps l'<em>event-loop</em> continue\nsa petite vie.</p>\n<h2>Reprise du traitement et émission de valeur avec <code>yield</code></h2>\n<p>La méthode <code>next()</code> de l'itérateur retourne un objet possédant les propriétés\nsuivantes :</p>\n<ul>\n<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>\n<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>\n</ul>\n<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir une\nvaleur et de remettre en pause l'exécution de la fonction. Le principe étant\nqu'on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement\n<code>return</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">numbers</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = numbers();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.next(); <span class=\"hljs-comment\">// { value: 2, done: false }</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la\npropriété <code>value</code> de la dernière itération.</p>\n<h3><em>Use case</em> : listes infinies</h3>\n<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de\nlongueur non définie à l'avance. On peut parcourir une suite dont on ne sait pas\nà l'avance <em>combien</em> d'éléments on veut, par exemple récupérer tous les éléments\nde la suite de Fibonacci inférieurs à 100 :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fibo</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> [a, b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-comment\">// Who can stop me?</span>\n    [a, b] = [b, a + b];\n    <span class=\"hljs-keyword\">yield</span> a;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fibo();\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> iterator) {\n  <span class=\"hljs-keyword\">if</span> (n &gt;= <span class=\"hljs-number\">100</span>) {\n    <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// *I* can stop you</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(n);\n}\n<span class=\"hljs-comment\">// 1 2 3 5 8 13 21 34 55 89</span>\n</code></pre>\n<p>Note : l'opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>\n<h2>Passage de valeur au générateur</h2>\n<p>On a vu que <code>yield</code> permettait d'émettre une valeur depuis le générateur vers le\ncode contrôleur. Mais le sens inverse est également possible : la méthode <code>next</code>\nde l'itérateur accepte une valeur en paramètre, qui sera alors retournée par\nl'appel correspondant à <code>yield</code>. Exemple :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">math</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// Le premier appel à next() permet de &quot;démarrer&quot; le générateur</span>\n  <span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">yield</span>; <span class=\"hljs-comment\">// la valeur de la première itération sera undefined</span>\n  <span class=\"hljs-comment\">// x = le paramètre du second appel à next()</span>\n  <span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">yield</span> x + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// valeur de la seconde itération : x + 1</span>\n  <span class=\"hljs-comment\">// y = paramètre du troisième appel à next()</span>\n  <span class=\"hljs-keyword\">yield</span> y; <span class=\"hljs-comment\">// valeur de la troisième itération : y</span>\n  <span class=\"hljs-comment\">// le 4e appel (et +) à next() retournent { value: undefined, done: true }</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = math();\niterator.next(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// { value: undefined, done: false }</span>\n<span class=\"hljs-comment\">// Passer un paramètre au premier appel à next() n&#x27;est pas utile : cette valeur</span>\n<span class=\"hljs-comment\">// n&#x27;est pas accessible dans le générateur car aucun &quot;yield&quot; correspondant</span>\n\niterator.next(<span class=\"hljs-number\">33</span>); <span class=\"hljs-comment\">// { value: 34, done: false }, x = 33 dans le générateur</span>\niterator.next(<span class=\"hljs-number\">27</span>); <span class=\"hljs-comment\">// { value: 27, done: false }, y = 27 dans le générateur</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>\nn'importe quel type de donnée : une fonction, un objet, un autre itérateur… Les\npossibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>\n<h3><em>Use case</em> : co-routines</h3>\n<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à\n<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est\nlibre d'appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>\n<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et\nquand elles peuvent reprendre leur traitement. Et si… notre générateur émettait\ndes promesses ? Histoire d'expliquer à son code contrôleur <em>quand</em> il est sûr de\nreprendre le traitement. Et si ce code contrôleur, voyant qu'il récupère une\npromesse, attendait que cette dernière soit résolue pour transmettre au\ngénérateur en retour la valeur résolue ? Dans ce cas le générateur pourrait\ndisposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de\ntraitements asynchrones :</p>\n<pre><code class=\"hljs language-js\">execAsync(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Ajax request…&quot;</span>);\n  <span class=\"hljs-keyword\">var</span> rows = <span class=\"hljs-keyword\">yield</span> fetch(<span class=\"hljs-string\">&quot;http://my.api/get&quot;</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Work…&quot;</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Save…&quot;</span>);\n  <span class=\"hljs-keyword\">yield</span> fetch(<span class=\"hljs-string\">&quot;http://my.api/post&quot;</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK.&quot;</span>);\n}); <span class=\"hljs-comment\">// Ajax request… Work… Save… OK.</span>\n</code></pre>\n<p>Ne serait-ce pas merveilleux ? C'est le <em><em>use case</em></em> le plus intéressant pour\nnous au quotidien, et c'est assez simple en fait :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">execAsync</span>(<span class=\"hljs-params\">promiseGenerator</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> iter = promiseGenerator(); <span class=\"hljs-comment\">// en pause…</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loop</span>(<span class=\"hljs-params\">iteration</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (iteration.done) {\n      <span class=\"hljs-comment\">// Le générateur a return&#x27;é, fin du game</span>\n      <span class=\"hljs-keyword\">return</span> iteration.value;\n    }\n\n    <span class=\"hljs-comment\">// c&#x27;est un générateur de promesse, dont on attend la résolution ici</span>\n    <span class=\"hljs-keyword\">return</span> iteration.value.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// La promesse est résolue, on peut repasser sa valeur au générateur</span>\n      <span class=\"hljs-keyword\">const</span> nextIteration = iter.next(result); <span class=\"hljs-comment\">// cette valeur est return&#x27;ée par</span>\n      <span class=\"hljs-comment\">// le même &quot;yield&quot; qui a émis la promesse, ça tombe bien :)</span>\n\n      <span class=\"hljs-comment\">// Puis on relance notre boucle, et on continue récursivement</span>\n      <span class=\"hljs-keyword\">return</span> next(nextIteration);\n    });\n  }\n\n  <span class=\"hljs-keyword\">const</span> promiseIteration = iter.next(); <span class=\"hljs-comment\">// exécution reprise jusqu&#x27;au prochain &quot;yield&quot;</span>\n  <span class=\"hljs-comment\">// le générateur est remis en pause jusqu&#x27;au prochain appel à &quot;iter.next&quot;</span>\n\n  <span class=\"hljs-comment\">// Première itération de la boucle</span>\n  <span class=\"hljs-keyword\">return</span> loop(promiseIteration);\n}\n</code></pre>\n<h2>More! more! more!</h2>\n<h3>Gestion d'erreur</h3>\n<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux\ndirections. Le générateur peut <code>throw</code> vers le code contrôleur (le code est\nsynchrone) :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fail</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fail();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\n<span class=\"hljs-keyword\">try</span> {\n  iterator.next(); <span class=\"hljs-comment\">// throws</span>\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  e; <span class=\"hljs-comment\">// Error(&#x27;oops&#x27;)</span>\n}\n</code></pre>\n<p>Mais le code contrôleur peut également émettre une erreur vers le générateur\navec la méthode <code>throw</code> de l'itérateur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">fail</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(e);\n  }\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fail();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.throw(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;nope&quot;</span>)); <span class=\"hljs-comment\">// affiche &quot;[Error: nope]&quot;</span>\niterator.next(); <span class=\"hljs-comment\">// { value: 2, done: false }</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>\nl'exécution du générateur, qui va alors jusqu'au premier <code>yield</code>, évalue\nl'expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en\npause. C'est au second <code>yield</code> seulement que l'exécution reprend <strong>à partir de\n<code>yield 1</code></strong>. C'est une partie que je trouve contre-intuitive et que j'ai eu du\nmal à assimiler.</p>\n<h3>Délégation</h3>\n<p>L'opérateur <code>yield*</code> permet d'émettre les valeurs d'un autre itérateur, par\nexemple :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">oneToThree</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">zeroToFour</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">yield</span>* oneToThree();\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>;\n}\n</code></pre>\n<p>Cela fonction bien sûr avec tous\n<a href=\"/fr/articles/js/es2015/iterators/\">les <em>itérables</em></a> : <code>yield * [1, 2, 3]</code> est\nvalide par exemple.</p>\n<h3>Retour anticipé</h3>\n<p>Il est possible de terminer le traitement d'un générateur depuis le code\ncontrôleur avec la méthode <code>return</code> de l'itérateur. Tout se passera comme si le\ngénérateur se terminait immédiatement avec la valeur de retour fournie.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">numbers</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = numbers();\niterator.next(); <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.return(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>\niterator.next(); <span class=\"hljs-comment\">// { value: undefined, done: true }</span>\n</code></pre>\n<h2>Conclusion</h2>\n<p>Un habituel petit coup d'œil sur\n<a href=\"https://kangax.github.io/compat-table/es6/#test-generators\">la compatibilité</a> :</p>\n<ul>\n<li>Les navigateurs modernes (donc pas IE)</li>\n<li>IE Edge ≥ 13</li>\n<li>Niveau polyfill, c'est vers Babel ou Traceur qu'il faudra se tourner</li>\n</ul>\n<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent\nd'inverser la responsabilité : c'est le code appelant qui prend le pouvoir sur\nla façon dont va s'exécuter la fonction appelée. Ils représentent le premier pas\nvers d'autres concepts qui bouleverseront probablement votre façon de coder dans\nquelques mois/années : fonctions asynchrones, observables… prennent leurs\nracines dans les générateurs. Les comprendre permettra de mieux appréhender de\nfutures fonctionnalités.</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>