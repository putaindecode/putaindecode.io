<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">Flow avancé - Première partie | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="Flow avancé - Première partie | Putain de code" property="og:title"/><meta data-react-helmet="true" content="Flow avancé - Première partie | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par zoontek" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/flow-avance-part-1" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(212, 100%, 35%), hsl(177, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">Flow avancé - Première partie</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/zoontek"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="zoontek" src="https://avatars.githubusercontent.com/zoontek?size=64"/><div>zoontek<!-- --> <!-- -->•<!-- --> <!-- -->2017/11/23</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser
<a href="https://flow.org/en/">flow</a>, l'outil de Facebook vous permettant d'ajouter du
typage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez
utilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript,
Ruby, Python…), et pour le moment vous vous contentez d'ajouter des annotations
de types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous
empêcher de crier sur tous les toits que le typage, c'est quand même chiant et
limite une perte de temps puisque flow continue de manquer un tas d'erreurs
potentielles au sein de votre code. Cet article est là pour vous aider à
comprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez
pas flow, il peut servir de chouette introduction un peu poussée à son
utilisation.</p>
<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes,
c'est à dire la 0.59. Pour l'ajouter au sein de votre projet, petit rappel:</p>
<pre><code class="hljs language-sh">npm install --save-dev flow-bin
npm install --save-dev flow-remove-types <span class="hljs-comment"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>
npx flow init <span class="hljs-comment"># pour créer le fichier .flowconfig</span>
</code></pre>
<p><em>Pour plus d'infos sur npx, c'est <a href="https://www.npmjs.com/package/npx">par ici</a>.
À noter que c'est livré de base avec npm maintenant.</em></p>
<h2>Rappels sur l'inférence de type</h2>
<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé
si celui-ci est évident à l'usage.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow &lt;- le pragma nécessaire pour indiquer à flow d&#x27;analyser votre fichier. À noter que si vous l&#x27;ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>

<span class="hljs-keyword">const</span> quote = <span class="hljs-string">&quot;Thirouin rouin rouin rouin&quot;</span>;
<span class="hljs-built_in">Math</span>.round(quote); <span class="hljs-comment">// erreur! le type attendu est un number</span>

<span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// inféré en (name: any) =&gt; string</span>
sayHello(<span class="hljs-string">&quot;Mathieu&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
sayHello(<span class="hljs-number">42</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
sayHello([<span class="hljs-string">&quot;Mathieu&quot;</span>, <span class="hljs-string">&quot;zoontek&quot;</span>]); <span class="hljs-comment">// erreur: ne peut être un array</span>
</code></pre>
<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez
carrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une
variable peut se montrer plus efficace que d'utiliser des types &quot;génériques&quot;
tels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le
faire).</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> sayHello: <span class="hljs-built_in">Function</span> = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// inféré en (name: any) =&gt; any</span>
</code></pre>
<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la
suivante :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">(<span class="hljs-params">name: string</span>) =&gt;</span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// (name: string) =&gt; string</span>
sayHello(<span class="hljs-string">&quot;Mathieu&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
sayHello(<span class="hljs-number">42</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<h2>Les types primitifs et litéraux</h2>
<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous
avez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens
(<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes
(<code>void</code>). À noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier
n'est pas encore supporté par flow.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> a: number = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> b: string = <span class="hljs-string">&quot;Je ne suis pas Coluche, certes&quot;</span>;
<span class="hljs-keyword">const</span> c: boolean = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> d: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> e: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;
</code></pre>
<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des
valeurs litérales comme type. Après tout <code>string</code>, ça peut être tout et
n'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci
sont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment
perfectionné, commme vous le verrez par la suite.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: <span class="hljs-string">&quot;x&quot;</span> = <span class="hljs-string">&quot;x&quot;</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
<span class="hljs-keyword">const</span> bar: <span class="hljs-number">2</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// erreur! n&#x27;est pas égal à 2</span>
</code></pre>
<h2>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>
<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable
peut être de n'importe quel type et cela est bien sûr extrêmement dangereux.
Heureusement, il existe 2 alternatives plus sûres à connaître :</p>
<ul>
<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction,
l'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc
pas y appeler des méthodes spécifiques à un type de variable en particulier.</li>
<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: mixed</span>) </span>{
  <span class="hljs-built_in">console</span>.log(arg);
} <span class="hljs-comment">// pas d&#x27;erreur: peu importe le type réel du paramètre arg, l&#x27;appel se fera correctement</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">arg: mixed</span>) </span>{
  <span class="hljs-built_in">console</span>.log(arg.toUpperCase());
} <span class="hljs-comment">// erreur! arg pourrait ne pas être une string</span>

<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Array</span>&lt;*&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// inféré en Array&lt;number&gt;</span>
baz.push(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// &quot;foo&quot; est maintenant inféré en Array&lt;number | string&gt; (tableau de string ou de numbers)</span>
</code></pre>
<h2>Les types optionnels (ou maybe types)</h2>
<p>Si vous avez déjà utilisé un langage qui essaye d'éviter
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">l'erreur à un milliard de dollars</a>,
vous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la
possible absence d'une valeur et sont ici symbolisés à l'aide d'un point
d'interrogation.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">let</span> foo: ?string; <span class="hljs-comment">// peut-être une string, null ou undefined</span>
foo = <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
foo = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
foo = <span class="hljs-literal">null</span>; <span class="hljs-comment">// pas d&#x27;erreur</span>
foo = <span class="hljs-number">3</span>; <span class="hljs-comment">// erreur - number n&#x27;est ni une string, ni null, ni undefined</span>

type Bar = {
  baz?: string, <span class="hljs-comment">// baz sera forcément une string si elle est présente</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrongToUpperCase</span>(<span class="hljs-params">str: ?string</span>) </span>{
  <span class="hljs-keyword">return</span> str.toUpperCase(); <span class="hljs-comment">// erreur, str est possiblement nul, vous devez traiter ce cas</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">correctToUpperCase</span>(<span class="hljs-params">str: ?string</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&quot;string&quot;</span>) {
    <span class="hljs-keyword">return</span> str.toUpperCase(); <span class="hljs-comment">// pas d&#x27;erreur</span>
  }
}
</code></pre>
<h2>Les types génériques (generics)</h2>
<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&lt;any&gt;</code>) croisée plus tôt?
Il s'agit de ce qu'on appelle un type générique : un type construit depuis un
autre type. Ainsi, si <code>Array&lt;any&gt;</code> symbolise un tableau de tout et n'importe
quoi, <code>Array&lt;number&gt;</code> symbolisera un tableau de numbers, etc.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-comment">// on crée un type Classement qui prend en &quot;paramètre&quot; un type générique qu&#x27;on nomme &quot;T&quot;</span>
type Classement&lt;T&gt; = {
  <span class="hljs-attr">first</span>: T,
  <span class="hljs-attr">second</span>: T,
  <span class="hljs-attr">third</span>: T,
};

<span class="hljs-keyword">const</span> numberClassement: Classement&lt;number&gt; = {
  <span class="hljs-attr">first</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">second</span>: <span class="hljs-number">7</span>,
  <span class="hljs-attr">third</span>: <span class="hljs-number">1</span>,
};
</code></pre>
<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">Array</span>&lt;number&gt; = [];

<span class="hljs-keyword">const</span> bar: <span class="hljs-built_in">Map</span>&lt;number, string&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
bar.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);

<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Set</span>&lt;number&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
baz.add(<span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> p: <span class="hljs-built_in">Promise</span>&lt;number&gt; = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);
</code></pre>
<h2>La manipulation d'objets</h2>
<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au
sein de mes exemples (oui, c'était chiant)? C'est tout simplement car les
possibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous
propose un exemple fleuve histoire d'y voir plus clair.</p>
<p>Un type objet se définit de la sorte :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type User = {
  <span class="hljs-attr">name</span>: string,
  <span class="hljs-attr">pseudo</span>: string,
};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mathieu&quot;</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">&quot;zoontek&quot;</span>,
};

<span class="hljs-comment">// Ce qui n&#x27;exclut pas de faire</span>
<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,
}; <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type User = {|
  name: string,
  <span class="hljs-attr">pseudo</span>: string,
|};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mathieu&quot;</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">&quot;zoontek&quot;</span>,
};

<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,
}; <span class="hljs-comment">// erreur! la propriété age n&#x27;existe pas</span>
</code></pre>
<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la
notation <code>+</code>. Un must-have pour vos reducers Redux.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type User = {
  +name: string,
  <span class="hljs-attr">pseudo</span>: string,
};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mathieu&quot;</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">&quot;zoontek&quot;</span>,
};

user.name = <span class="hljs-string">&quot;Jean-Michel&quot;</span>; <span class="hljs-comment">// erreur! la valeur de name ne peut-être modifiée</span>

<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jean-Michel&quot;</span>,
}; <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<blockquote>
<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>
</blockquote>
<p>Yep.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type Foo = {| a: number, <span class="hljs-attr">b</span>: string |};
type Bar = {| a: string |};
type Baz = {| ...Foo, ...Bar |}; <span class="hljs-comment">// {| a: string, b: string |}</span>
</code></pre>
<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser
comme maps :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: { [key: string]: number } = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">&quot;whatever&quot;</span>, <span class="hljs-comment">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>
};
</code></pre>
<h2>Les unions et intersections de types</h2>
<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la
question de ce que ça représente. Il s'agit d'une union de types : la variable
aura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours
une union de types litéraux à la place du simple <code>string</code> lorsque vous
connaissez à l'avance les possibles valeurs de celui-ci.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHelloOrRound</span>(<span class="hljs-params">arg: string | number</span>) </span>{
  <span class="hljs-comment">// arg peut être une string ou un number</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> arg === <span class="hljs-string">&quot;string&quot;</span> ? <span class="hljs-string">`Hello <span class="hljs-subst">${arg}</span>`</span> : <span class="hljs-built_in">Math</span>.round(arg);
} <span class="hljs-comment">// pas d&#x27;erreur</span>

type Color = <span class="hljs-string">&quot;red&quot;</span> | <span class="hljs-string">&quot;green&quot;</span> | <span class="hljs-string">&quot;blue&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toHexadecimal</span>(<span class="hljs-params">color: Color</span>) </span>{
  <span class="hljs-keyword">switch</span> (color) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;red&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#FF0000&quot;</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;green&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#00FF00&quot;</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;blue&quot;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#0000FF&quot;</span>;
  }
}

toHexadecimal(<span class="hljs-string">&quot;red&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
toHexadecimal(<span class="hljs-string">&quot;green&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
toHexadecimal(<span class="hljs-string">&quot;blue&quot;</span>); <span class="hljs-comment">// pas d&#x27;erreur</span>
toHexadecimal(<span class="hljs-string">&quot;pink&quot;</span>); <span class="hljs-comment">// erreur! &quot;pink&quot; n&#x27;est pas une valeur possible</span>
toHexadecimal(<span class="hljs-string">&quot;dog&quot;</span>); <span class="hljs-comment">// erreur! &quot;dog&quot; n&#x27;est pas une valeur possible</span>
</code></pre>
<p>Parfois, une union de types se montre également bien plus efficace pour
modéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type ApiResponseBadlyTyped = {|
  success: boolean,
  value?: string, <span class="hljs-comment">// value peut être présent</span>
  error?: <span class="hljs-built_in">Error</span>, <span class="hljs-comment">// error peut être présent</span>
|};

<span class="hljs-keyword">const</span> foo: ApiResponseBadlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// pas d&#x27;erreur alors que j&#x27;attends une value</span>
<span class="hljs-keyword">const</span> bar: ApiResponseBadlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oups!&quot;</span>) }; <span class="hljs-comment">// pas d&#x27;erreur non plus</span>

type ApiResponseCorrectlyTyped =
  | {| success: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: string |}
  | {| success: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-built_in">Error</span> |};

<span class="hljs-keyword">const</span> foo: ApiResponseCorrectlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// erreur! il manque value</span>
<span class="hljs-keyword">const</span> bar: ApiResponseCorrectlyTyped = {
  <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oups!&quot;</span>),
}; <span class="hljs-comment">// erreur! si success est à true, on ne doit pas trouver d&#x27;error dans notre objet</span>
<span class="hljs-keyword">const</span> baz: ApiResponseCorrectlyTyped = {
  <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;oups!&quot;</span>),
}; <span class="hljs-comment">// pas d&#x27;erreur</span>
</code></pre>
<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les
intersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&amp;</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type Foo = { <span class="hljs-attr">a</span>: number };
type Bar = { <span class="hljs-attr">b</span>: string };
type Baz = { <span class="hljs-attr">c</span>: boolean };

<span class="hljs-keyword">const</span> test: Foo &amp; Bar &amp; Baz = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;whatever&quot;</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span>,
}; <span class="hljs-comment">// pas d&#x27;erreur</span>

<span class="hljs-keyword">let</span> impossible: number &amp; string; <span class="hljs-comment">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span>
</code></pre>
<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la
surface de ce qui nous est offert par flow et les systèmes de typage fort en
général. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie
vers la <a href="https://flow.org/en/docs/">documentation de flow</a>, très bien foutue.
Pour les autres, on devrait sortir très prochainement un article sur le même
sujet (on y parlera classes, interfaces et peut être même types opaques si vous
êtes sages).</p>
<p>Stay tuned! La bise.</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Flow%20avanc%C3%A9%20-%20Premi%C3%A8re%20partie%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fflow-avance-part-1" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"flow-avance-part-1","v":{"_0":{"TAG":0,"_0":{"slug":"flow-avance-part-1","filename":"2017-11-23-flow-avance-part-1","title":"Flow avancé - Première partie","date":"Thu, 23 Nov 2017 00:00:00 GMT","draft":false,"meta":{"date":"2017-11-23T00:00:00.000Z","title":"Flow avancé - Première partie","author":"zoontek","oldSlug":"js/flow/advanced-part-1","slug":"flow-avance-part-1"},"body":"<p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser\n<a href=\"https://flow.org/en/\">flow</a>, l'outil de Facebook vous permettant d'ajouter du\ntypage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez\nutilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript,\nRuby, Python…), et pour le moment vous vous contentez d'ajouter des annotations\nde types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous\nempêcher de crier sur tous les toits que le typage, c'est quand même chiant et\nlimite une perte de temps puisque flow continue de manquer un tas d'erreurs\npotentielles au sein de votre code. Cet article est là pour vous aider à\ncomprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez\npas flow, il peut servir de chouette introduction un peu poussée à son\nutilisation.</p>\n<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes,\nc'est à dire la 0.59. Pour l'ajouter au sein de votre projet, petit rappel:</p>\n<pre><code class=\"hljs language-sh\">npm install --save-dev flow-bin\nnpm install --save-dev flow-remove-types <span class=\"hljs-comment\"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>\nnpx flow init <span class=\"hljs-comment\"># pour créer le fichier .flowconfig</span>\n</code></pre>\n<p><em>Pour plus d'infos sur npx, c'est <a href=\"https://www.npmjs.com/package/npx\">par ici</a>.\nÀ noter que c'est livré de base avec npm maintenant.</em></p>\n<h2>Rappels sur l'inférence de type</h2>\n<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé\nsi celui-ci est évident à l'usage.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow &lt;- le pragma nécessaire pour indiquer à flow d&#x27;analyser votre fichier. À noter que si vous l&#x27;ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>\n\n<span class=\"hljs-keyword\">const</span> quote = <span class=\"hljs-string\">&quot;Thirouin rouin rouin rouin&quot;</span>;\n<span class=\"hljs-built_in\">Math</span>.round(quote); <span class=\"hljs-comment\">// erreur! le type attendu est un number</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) =&gt; string</span>\nsayHello(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello([<span class=\"hljs-string\">&quot;Mathieu&quot;</span>, <span class=\"hljs-string\">&quot;zoontek&quot;</span>]); <span class=\"hljs-comment\">// erreur: ne peut être un array</span>\n</code></pre>\n<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez\ncarrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une\nvariable peut se montrer plus efficace que d'utiliser des types &quot;génériques&quot;\ntels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le\nfaire).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello: <span class=\"hljs-built_in\">Function</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) =&gt; any</span>\n</code></pre>\n<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la\nsuivante :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\">(<span class=\"hljs-params\">name: string</span>) =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// (name: string) =&gt; string</span>\nsayHello(<span class=\"hljs-string\">&quot;Mathieu&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<h2>Les types primitifs et litéraux</h2>\n<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous\navez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens\n(<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes\n(<code>void</code>). À noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier\nn'est pas encore supporté par flow.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> a: number = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">const</span> b: string = <span class=\"hljs-string\">&quot;Je ne suis pas Coluche, certes&quot;</span>;\n<span class=\"hljs-keyword\">const</span> c: boolean = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">const</span> d: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">const</span> e: <span class=\"hljs-keyword\">void</span> = <span class=\"hljs-literal\">undefined</span>;\n</code></pre>\n<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des\nvaleurs litérales comme type. Après tout <code>string</code>, ça peut être tout et\nn'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci\nsont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment\nperfectionné, commme vous le verrez par la suite.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-string\">&quot;x&quot;</span> = <span class=\"hljs-string\">&quot;x&quot;</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur! n&#x27;est pas égal à 2</span>\n</code></pre>\n<h2>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>\n<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable\npeut être de n'importe quel type et cela est bien sûr extrêmement dangereux.\nHeureusement, il existe 2 alternatives plus sûres à connaître :</p>\n<ul>\n<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction,\nl'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc\npas y appeler des méthodes spécifiques à un type de variable en particulier.</li>\n<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg);\n} <span class=\"hljs-comment\">// pas d&#x27;erreur: peu importe le type réel du paramètre arg, l&#x27;appel se fera correctement</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg.toUpperCase());\n} <span class=\"hljs-comment\">// erreur! arg pourrait ne pas être une string</span>\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Array</span>&lt;*&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// inféré en Array&lt;number&gt;</span>\nbaz.push(<span class=\"hljs-string\">&quot;Hello&quot;</span>); <span class=\"hljs-comment\">// &quot;foo&quot; est maintenant inféré en Array&lt;number | string&gt; (tableau de string ou de numbers)</span>\n</code></pre>\n<h2>Les types optionnels (ou maybe types)</h2>\n<p>Si vous avez déjà utilisé un langage qui essaye d'éviter\n<a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\">l'erreur à un milliard de dollars</a>,\nvous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la\npossible absence d'une valeur et sont ici symbolisés à l'aide d'un point\nd'interrogation.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">let</span> foo: ?string; <span class=\"hljs-comment\">// peut-être une string, null ou undefined</span>\nfoo = <span class=\"hljs-string\">&quot;foo&quot;</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\nfoo = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur - number n&#x27;est ni une string, ni null, ni undefined</span>\n\ntype Bar = {\n  baz?: string, <span class=\"hljs-comment\">// baz sera forcément une string si elle est présente</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">wrongToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// erreur, str est possiblement nul, vous devez traiter ce cas</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">correctToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str === <span class=\"hljs-string\">&quot;string&quot;</span>) {\n    <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n  }\n}\n</code></pre>\n<h2>Les types génériques (generics)</h2>\n<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&lt;any&gt;</code>) croisée plus tôt?\nIl s'agit de ce qu'on appelle un type générique : un type construit depuis un\nautre type. Ainsi, si <code>Array&lt;any&gt;</code> symbolise un tableau de tout et n'importe\nquoi, <code>Array&lt;number&gt;</code> symbolisera un tableau de numbers, etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-comment\">// on crée un type Classement qui prend en &quot;paramètre&quot; un type générique qu&#x27;on nomme &quot;T&quot;</span>\ntype Classement&lt;T&gt; = {\n  <span class=\"hljs-attr\">first</span>: T,\n  <span class=\"hljs-attr\">second</span>: T,\n  <span class=\"hljs-attr\">third</span>: T,\n};\n\n<span class=\"hljs-keyword\">const</span> numberClassement: Classement&lt;number&gt; = {\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-number\">7</span>,\n  <span class=\"hljs-attr\">third</span>: <span class=\"hljs-number\">1</span>,\n};\n</code></pre>\n<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [];\n\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-built_in\">Map</span>&lt;number, string&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\nbar.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;one&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Set</span>&lt;number&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();\nbaz.add(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">const</span> p: <span class=\"hljs-built_in\">Promise</span>&lt;number&gt; = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">42</span>);\n</code></pre>\n<h2>La manipulation d'objets</h2>\n<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au\nsein de mes exemples (oui, c'était chiant)? C'est tout simplement car les\npossibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous\npropose un exemple fleuve histoire d'y voir plus clair.</p>\n<p>Un type objet se définit de la sorte :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  <span class=\"hljs-attr\">name</span>: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\n<span class=\"hljs-comment\">// Ce qui n&#x27;exclut pas de faire</span>\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {|\n  name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n|};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>,\n}; <span class=\"hljs-comment\">// erreur! la propriété age n&#x27;existe pas</span>\n</code></pre>\n<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la\nnotation <code>+</code>. Un must-have pour vos reducers Redux.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  +name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string,\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Mathieu&quot;</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">&quot;zoontek&quot;</span>,\n};\n\nuser.name = <span class=\"hljs-string\">&quot;Jean-Michel&quot;</span>; <span class=\"hljs-comment\">// erreur! la valeur de name ne peut-être modifiée</span>\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Jean-Michel&quot;</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<blockquote>\n<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>\n</blockquote>\n<p>Yep.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = {| a: number, <span class=\"hljs-attr\">b</span>: string |};\ntype Bar = {| a: string |};\ntype Baz = {| ...Foo, ...Bar |}; <span class=\"hljs-comment\">// {| a: string, b: string |}</span>\n</code></pre>\n<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser\ncomme maps :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: { [key: string]: number } = {\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">&quot;whatever&quot;</span>, <span class=\"hljs-comment\">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>\n};\n</code></pre>\n<h2>Les unions et intersections de types</h2>\n<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la\nquestion de ce que ça représente. Il s'agit d'une union de types : la variable\naura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours\nune union de types litéraux à la place du simple <code>string</code> lorsque vous\nconnaissez à l'avance les possibles valeurs de celui-ci.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHelloOrRound</span>(<span class=\"hljs-params\">arg: string | number</span>) </span>{\n  <span class=\"hljs-comment\">// arg peut être une string ou un number</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> arg === <span class=\"hljs-string\">&quot;string&quot;</span> ? <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${arg}</span>`</span> : <span class=\"hljs-built_in\">Math</span>.round(arg);\n} <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n\ntype Color = <span class=\"hljs-string\">&quot;red&quot;</span> | <span class=\"hljs-string\">&quot;green&quot;</span> | <span class=\"hljs-string\">&quot;blue&quot;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toHexadecimal</span>(<span class=\"hljs-params\">color: Color</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span> (color) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;red&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#FF0000&quot;</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;green&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#00FF00&quot;</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;blue&quot;</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;#0000FF&quot;</span>;\n  }\n}\n\ntoHexadecimal(<span class=\"hljs-string\">&quot;red&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;green&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;blue&quot;</span>); <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;pink&quot;</span>); <span class=\"hljs-comment\">// erreur! &quot;pink&quot; n&#x27;est pas une valeur possible</span>\ntoHexadecimal(<span class=\"hljs-string\">&quot;dog&quot;</span>); <span class=\"hljs-comment\">// erreur! &quot;dog&quot; n&#x27;est pas une valeur possible</span>\n</code></pre>\n<p>Parfois, une union de types se montre également bien plus efficace pour\nmodéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype ApiResponseBadlyTyped = {|\n  success: boolean,\n  value?: string, <span class=\"hljs-comment\">// value peut être présent</span>\n  error?: <span class=\"hljs-built_in\">Error</span>, <span class=\"hljs-comment\">// error peut être présent</span>\n|};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// pas d&#x27;erreur alors que j&#x27;attends une value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>) }; <span class=\"hljs-comment\">// pas d&#x27;erreur non plus</span>\n\ntype ApiResponseCorrectlyTyped =\n  | {| success: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: string |}\n  | {| success: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-built_in\">Error</span> |};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseCorrectlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// erreur! il manque value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseCorrectlyTyped = {\n  <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>),\n}; <span class=\"hljs-comment\">// erreur! si success est à true, on ne doit pas trouver d&#x27;error dans notre objet</span>\n<span class=\"hljs-keyword\">const</span> baz: ApiResponseCorrectlyTyped = {\n  <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;oups!&quot;</span>),\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n</code></pre>\n<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les\nintersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&amp;</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = { <span class=\"hljs-attr\">a</span>: number };\ntype Bar = { <span class=\"hljs-attr\">b</span>: string };\ntype Baz = { <span class=\"hljs-attr\">c</span>: boolean };\n\n<span class=\"hljs-keyword\">const</span> test: Foo &amp; Bar &amp; Baz = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;whatever&quot;</span>,\n  <span class=\"hljs-attr\">c</span>: <span class=\"hljs-literal\">true</span>,\n}; <span class=\"hljs-comment\">// pas d&#x27;erreur</span>\n\n<span class=\"hljs-keyword\">let</span> impossible: number &amp; string; <span class=\"hljs-comment\">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span>\n</code></pre>\n<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la\nsurface de ce qui nous est offert par flow et les systèmes de typage fort en\ngénéral. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie\nvers la <a href=\"https://flow.org/en/docs/\">documentation de flow</a>, très bien foutue.\nPour les autres, on devrait sortir très prochainement un article sur le même\nsujet (on y parlera classes, interfaces et peut être même types opaques si vous\nêtes sages).</p>\n<p>Stay tuned! La bise.</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>