<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">Retour sur plusieurs années de CSS-in-JS | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="Retour sur plusieurs années de CSS-in-JS | Putain de code" property="og:title"/><meta data-react-helmet="true" content="Retour sur plusieurs années de CSS-in-JS | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par bloodyowl" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/retour-sur-plusieurs-annees-de-css-in-js" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(148, 100%, 35%), hsl(123, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">Retour sur plusieurs années de CSS-in-JS</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/bloodyowl"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="bloodyowl" src="https://avatars.githubusercontent.com/bloodyowl?size=64"/><div>bloodyowl<!-- --> <!-- -->•<!-- --> <!-- -->2021/02/08</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Voilà maintenant plus de 4 ans, je vous partageais <a href="/articles/pourquoi-j-ai-arrete-d-utiliser-css/">les raisons me poussant à me détourner de mon amour initial pour CSS</a>, alors que je m'en allais vers des alternatives qui proposaient des solutions aux problèmes que je rencontrais quotidiennement.</p>
<p>L'article original, écrit dans la fougue de la jeunesse, utilisait un ton dit de &quot;petit merdeux&quot;. J'ai bien conscience que ça n'avait à l'époque pas aidé à faire passer le message souhaité, comme peuvent <a href="http://www.glazman.org/weblog/dotclear/index.php?post/2016/06/18/Pourquoi-il-n-aurait-pas-du-arrêter-d-utiliser-CSS">en témoigner</a> <a href="/articles/pourquoi-j-ai-arrete-d-utiliser-css/#disqus_thread">les différents retours</a>. Je vais donc profiter de cette rétrospective pour résumer son propos un peu plus finement.</p>
<h2>Arrêter de sacraliser CSS</h2>
<p>Au départ, CSS était de loin mon langage préféré de la stack web. J'ai adoré bidouiller avec ce langage pendant des années, faire le malin avec des hacks qui me permettaient de faire les rendus que je voulais. <strong>J'ai adoré CSS</strong>. Je trouvais ça chouette d'utiliser des pseudo-éléments pour faire des bords arrondis, de fabriquer mes sprites et de factoriser mes styles en commun derrière des sélecteurs.</p>
<p>Puis vint le travail en équipe et les projets plus gros. Chacun notre tour on casse quelque chose, quelque part dans le projet. On change le style appliqué à un sélecteur et ça applique ces styles à un endroit auquel on ne pensait pas. On corrige, ça pète quelque chose ailleurs. Le problème, c'est que <strong>les sélecteurs s'appliquent globalement sur l'intégralité du projet</strong>. Qui plus est, l'application d'un style est un calcul savant: il dépend non seulement d'un sélecteur, de l'<strong>endroit où il est défini</strong> dans la feuille de style (les derniers écrasent les premiers), mais aussi de ce qu'on appelle <strong>sa spécificité</strong> (une sorte de score de précision, qui fait que plus un sélecteur est considéré comme &quot;fin&quot; par le système, plus il prendra la précédence). Si cette complexité n'était pas suffisante, ce ne sont pas des déclarations de style indivisibles qui s'écrasent les unes les autres, mais les <strong>propriétés individuelles</strong> qu'elles contiennent, comme un gros <code>merge</code> complexe dont l'ordre varie selon tous les paramètres cités au dessus pour chaque élément. Il faut donc inspecter minutieusement ce qui s'applique déjà à un élément pour savoir quoi écraser ou non.</p>
<p>Naturellement, la feuille de style devient rapidement une course à la spécificité et on se retrouve avec des styles de plus en plus compliqués à annuler lorsqu'on veut appliquer une exception. Ça devient rapidement un <strong>cauchemar de maintenabilité</strong> : à chaque étape du projet on peut casser des éléments sans avoir voulu les changer, on doit <strong>tout</strong> revérifier à chaque changement.</p>
<p>On peut ceci dit y remédier, en se mettant d'accord sur des <strong>méthodologies</strong> qui feront en sorte d'éviter ce genre d'effets de bord, mieux vaut prévenir que guérir. C'est <strong>BEM</strong> (Block Element Modifier) qui retiendra mon attention, avec une logique plus simple à aborder que la majorité des autres méthodologies : on utilise des sélecteurs avec <strong>la même spécificité</strong>, des attributs <code>class</code>, qu'on nomme tous d'une certaine façon. Ce nommage indiquant clairement la nature et le rôle de chaque élément, on isole chaque bloc réutilisable derrière son <strong>namespace</strong>.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;UserProfile&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;UserProfile-avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;UserProfile-username&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Dès lors, on change de modèle mental : en pratique les sélecteurs ne sont plus des instructions complexes pour trouver des élements de notre page selon leur contexte, mais un <strong>simple clé-valeur</strong>. HTML et CSS <strong>partagent désormais cette clé</strong>, et ça simplifie le travail de tout le monde : une approche unifiée pour toute l'équipe, <strong>moins de conflits</strong> dans l'application des styles, <strong>moins de regressions</strong>, et une <strong>meilleure &quot;recherchabilité&quot;</strong> (la clé étant partagée entre le markup et le style). Le seul détail qui fait tiquer c'est que les noms de <code>class</code> sont quand même un poil long et répétitifs.</p>
<p>La communauté réclame depuis des années un standard donnant la possibilité de créer des <strong>styles &quot;scopés&quot;</strong>, c'est à dire <strong>limités dans leur porté</strong>, ce qui résoudrait notre problème de noms trop longs. Et c'est une solution technique, hors standards, qui va apporter une solution : les <strong>CSS modules</strong>. C'est une technique d'injection des styles qui transforme les sélecteurs en les <strong>préfixant de clés uniques, correspondant au scope</strong>. Là où BEM nous forçait à maintenir notre namespace à la main, on a désormais un système capable de s'en charger, et ce système est moins faillible que nous.</p>
<p>À mon sens, <strong>les CSS modules sont la première occurence de CSS-in-JS</strong>. Probablement une question de syntaxe, mais cette technique est relativement bien acceptée. Suite à la popularisation de ce système, les idées fusent et les solutions CSS-in-JS se multiplient, chacune avec son approche sur le sujet.</p>
<p>Qu'est-ce qu'on peut tirer de ça ? Que oui, comme le disent ses défenseurs, CSS est puissant, son système d'application des styles l'est très certainement. Ce n'est pas pour autant qu'il est <strong>pratique</strong> et <strong>adapté</strong> à de gros projets qu'on doit maintenir dans le temps. La complexité qui en découle <strong>impose aux devs une forme de rigueur</strong>, faute de quoi les regressions sont inévitables. <strong>Ça a un coût, en temps passé et en énergie mentale déployée</strong>.  Si cette rigueur peut être déléguée à une machine, quelle raison aurait-on de s'en priver ?</p>
<p>CSS a beau n'être qu'un <strong>langage informatique</strong>, on a parfois l'impression qu'il est considéré comme une <strong>doctrine religieuse</strong>, et on m'a souvent reproché de promouvoir des approches qui délèguent la charge mentale induite à une machine, avec l'argument que je ne savais pas faire de CSS. Parce que CSS, par sa volonté propre, voulait qu'il en soit autrement.</p>
<p>Non, CSS n'a pas été originalement prévu pour être utilisé comme ça. Et c'est pas grave, c'était il y a 25 ans (environ un millénaire en années tech). Les usages, les besoins, tout ça a évolué. <strong>Il y a 25 ans il était inimaginable que le web puisse devenir ce qu'il est aujourd'hui</strong>, avec des interfaces incroyablement riches, permettant de faire à peu près ce qu'on veut depuis un navigateur. Pourquoi cette vision originale devrait nous freiner dans nos idées ? Pourquoi devrait-elle nous imposer une difficulté ? On ne parle pas d'un problème éthique complexe : qu'on délègue ou pas, qu'on automatise ou pas, ça ne change rien à personne. Il s'agit juste d'un attachement profond à une doctrine.</p>
<p>Je pense qu'il est temps d'<strong>arrêter de sacraliser tous les aspects de CSS</strong>. Je suis admiratif de son modèle de boite, de styling, et je pense honnêtement que c'est un des outils permettant l'expression du style de la manière la plus simple possible. En revanche, je trouve sa façon de résoudre les styles complètement obsolète et risquée dans les contextes où je l'utilise.</p>
<p>J'utilise les parties de CSS qui me permettent de faire ce que je veux (pour simplifier, tout ce qu'on trouve entre des accolades), et je délègue la gestion des autres parties à une machine.</p>
<h2>CSS-in-JS, qu'est-ce que ça apporte ?</h2>
<p>Alors maintenant, au bout de 4/5 ans, qu'est-ce que ça donne, CSS-in-JS ? Est-ce que c'était une immense connerie ? Est-ce que c'est finalement une bonne idée ?</p>
<p>Pour expliquer un peu mon usage: je travaille sur une <strong>web app dont je maîtrise le markup</strong> (si ce n'est pas votre cas, il y a fort à parier que CSS-in-JS vous pose plus de problèmes que de solutions ⚠️).</p>
<p>J'utilise deux &quot;genres&quot; de CSS-in-JS. Mon application se divise en deux parties: un widget dans une iframe-sourceless et un dashboard. Le widget utilise pour des raisons pratiques des styles inline (l'attribut style, oui oui 😱) et le dashboard la bibliothèque <a href="https://emotion.sh/docs/introduction">emotion</a>.</p>
<p>Eh bien je suis très content des deux. <strong>Je n'ai pas eu la moindre régression liée à de l'application de style depuis que j'utilise CSS-in-JS</strong>.</p>
<p>Ma manière de définir et d'appliquer un style à un élément ressemble à ça (attention, c'est du <a href="https://rescript-lang.org">ReScript</a>):</p>
<pre><code class="hljs language-reason"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> on stocke la spécification dans une variable
<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Styles</span> = {
  <span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Css</span>;
  <span class="hljs-keyword">let</span> callToAction =
    style(<span class="hljs-literal">[</span>
      backgroundColor(<span class="hljs-module-identifier">BeOpTheme</span>.mainGreen<span class="hljs-operator">-&gt;</span>hex),
      fontSize(<span class="hljs-number">16</span><span class="hljs-operator">-&gt;</span>px),
      padding4(~left=<span class="hljs-number">40</span><span class="hljs-operator">-&gt;</span>px, ~right=<span class="hljs-number">40</span><span class="hljs-operator">-&gt;</span>px, ~top=<span class="hljs-number">13</span><span class="hljs-operator">-&gt;</span>px, ~bottom=<span class="hljs-number">16</span><span class="hljs-operator">-&gt;</span>px),
      borderRadius(<span class="hljs-number">26</span><span class="hljs-operator">-&gt;</span>px),
      color(<span class="hljs-string">&quot;fff&quot;</span><span class="hljs-operator">-&gt;</span>hex),
      textAlign(center),
    <span class="hljs-literal">]</span>)
}
<span class="hljs-operator">/</span><span class="hljs-operator">/</span> on passe cette variable à l&#x27;élément souhaité
&lt;<span class="hljs-module-identifier">TouchableOpacity</span> onPress&gt;
  &lt;div className=<span class="hljs-module-identifier">Styles</span>.callToAction&gt;
    title
  &lt;/div&gt;
&lt;/<span class="hljs-module-identifier">TouchableOpacity</span>&gt;
</code></pre>
<p>Que vous trouviez ça <strong>joli ou moche, là n'est pas le sujet</strong>. La machine fait ce qu'on lui dit. Elle génère un nom de <code>class</code> en faisant un hash des styles, cette <code>class</code> <strong>ne pourra déclencher aucun effet de bord</strong> ailleurs dans l'application.</p>
<p>Ça m'a rendu la gestion des styles tellement <strong>bête et simple</strong> qu'il n'y a pas grand chose à dire dessus. <strong>J'assigne à une variable une spécification de style</strong>, et <strong>je donne cette variable à l'élément</strong> sur lequel je la veux appliquée, et ce sera le seul style appliqué à mon élément. <em>That's it</em>. Ça élimine une catégorie entière de problèmes, me laissant l'occasion de me concentrer sur d'autres choses. Vu que j'utilise une bibliothèque typée qui s'assure qu'une propriété reçoit une valeur d'un type attendu : <strong>j'écris du CSS avec des petites roues</strong>, ça m'évite même de laisser passer des fautes de frappe.</p>
<p>Et ce qui étaient autrefois des casse-têtes immenses sont gérés automatiquement : <strong>ça élimine les styles morts</strong> facilement, ce qui est virtuellement infaisable à grande échelle (ici, c'est simplement une variable, et on sait très facilement détecter les variables inutilisées). C'est même capable d'<strong>extraire les styles critiques au rendu de la page</strong>, automatiquement !</p>
<p>Quand je reviens à l'occasion sur des trucs nécessitant des sélecteurs CSS (pour des choses où je ne maîtrise pas le markup, et c'est un cas d'usage très légitime), je réalise à quel point j'avais accepté une complexité incroyable parce que c'était la seule façon. Quand j'y réfléchis bien, pour styliser des éléments, j'étais obligé de me <strong>créer une cartographie mouvante dépendant d'un algorithme de résolution dont je n'avais pas forcément les paramètres à tout instant donné</strong>.</p>
<p>Les sélecteurs représentent une charge mentale énorme qui est <strong>évitable</strong>. C'est ça, la killer feature de CSS-in-JS.</p>
<p>La puissance des sélecteurs complexes CSS ne <strong>valent pas le coup pour moi</strong> tant que leur <a href="/articles/tradeoffs">balance bénéfice/risque</a> est plus faible que l'alternative. <strong>Si exprimer la même chose que le sélecteur CSS avec du JS est plus lisible et maintenable, je ne vais pas hésiter</strong>.</p>
<p>C'est bien d'avoir un système ultra-puissant qui impose de déployer une énergie folle. Je préfère être capable de retourner dans mon code au quotidien <a href="/articles/introduction-a-rud">sans avoir à me faire des nœuds au cerveau</a>.</p>
<h2>Mais ça casse le web !</h2>
<p>C'est un des nombreux arguments d'autorité qu'on a entendu au fil des années. Les technologies telles que CSS-in-JS, <strong>ça casserait le web</strong>.</p>
<p>Le blog que vous êtes en train de lire est <a href="/articles/comment-on-a-fait-ce-site"><strong>une application web qui utilise CSS-in-JS</strong></a>. Est-ce qu'il casse le web ? Est-ce ça vous empêche de lire son contenu avec les styles désactivés ? Est-ce que ça vous empêche de parcourir le site sans JavaScript ? Essayez !</p>
<p><strong>Ce que le navigateur reçoit, il est parfaitement capable de l'interpréter</strong>.</p>
<p><strong>Ça ne change rien au résultat final</strong>, et ça facilite la vie des gens qui travaillent dessus au quotidien. <a href="/articles/2021-01-29-ecrivez-du-code-stupide">Pourquoi on s'en priverait ?</a> À l'heure où l'immense majorité du code qu'on écrit à destination d'un navigateur passe par une étape de compilation (que ce soit un préprocesseur, un minifier…), pourquoi ne pas aller au bout et considérer la plateforme web comme une &quot;compilation target&quot; ? Pourquoi ne pas s'autoriser une abstraction qui nous permet de travailler plus confortablement pour <strong>un résultat équivalent, sinon meilleur</strong> ?</p>
<h2>Pourquoi des réactions si épidermiques face à CSS-in-JS ?</h2>
<p>Je pense qu'il est difficile d'envisager que <strong>nos connaissances puissent devenir obsolètes</strong>, particulièrement quand la connaissance a été difficile à acquérir. Tous les hacks CSS de mes débuts n'ont plus cours aujourd'hui, mes vieilles techniques ECMAScript3 sont inutiles depuis les mises à jour du langage, mes façons de gérer les interfaces en manipulant scrupuleusement le DOM me paraissent complètement archaïques maintenant que j'ai à disposition <strong>des outils gérant toute cette complexité</strong> pour moi.</p>
<p>Ça n'a pourtant pas servi à rien : ça a forgé la vision du développement que j'ai aujourd'hui par la somme de mes expériences. <strong>Chacun·e d'entre nous a une vision singulière grâce à son parcours et c'est une excellente chose</strong>, parce que ça multiplie les points de vue et rend notre communauté plus riche.</p>
<p>Mais il faut être capable d'<strong>archiver son savoir</strong>, particulièrement dans les domaines technologiques où l'évolution est rapide, il faut toujours partir du principe que <strong>l'utilité de nos connaissances n'est pas intemporelle</strong>.</p>
<p>Demain, avec l'expérience collective accumulée et les progrès qu'elle induira, <strong>ce qui a toujours été vrai ne le sera plus</strong>. Certaines limites se poussent, d'autres se rapprochent. Dans l'immense majorité des cas, c'est pour le mieux : les applications qu'on est capable de produire aujourd'hui étaient encore impensables il y a quelques années. La vitesse à laquelle on est capable de les produire l'était encore plus.</p>
<h2>Qu'est-ce qu'on peut souhaiter maintenant ?</h2>
<p>Ce que je souhaite pour les années à venir, c'est que les groupes de travail spécifiant les standards web parviennent à <strong>mettre le doigt sur les problèmes décrits ici</strong>, que je suis loin d'être le seul à exprimer.</p>
<p>Qu'on arrête de se concentrer sur des nouveaux sélecteurs, des nouveaux systèmes de layout ne faisant rien de plus que ce qu'on pouvait déjà faire avant ou des raccourcis pour des propriétés de transformation qui de toute façon dépendent de l'ordre dans lequel on les applique. Je ne dis pas que ce sont des propositions inutiles dans l'absolu, mais ça me semble être très superficiel au regard des <strong>transformations structurelles</strong> que des outils maintenus par la communauté proposent.</p>
<p>J'aimerais qu'on déploie notre énergie à <strong>rendre la plateforme meilleure</strong>, <strong>plus accessible</strong> et <strong>plus maintenable</strong>. Aujourd'hui on est encore forcés de gérer nous-mêmes des &quot;pièges à focus&quot; pour nos modales, on n'a toujours pas de solution viable pour faire varier les propriétés CSS d'un conteneur selon l'espace à sa disposition (on est censé prévoir tous les contextes où un composant réutilisable va s'afficher, puis qu'on ne peut le faire varier que selon une taille de fenêtre), on n'a pas de brique native pour créer des animations utilisant des propriétés physique performantes (les applications natives mobiles parviennent avec elles à créer des animations logiques, aidant à la compréhension des interfaces). Ces problèmes ne sont pas nouveaux, certains sont identifiés depuis plus de 15 ans, et <strong>de l'extérieur il ne semble pas qu'il s'agisse d'une priorité</strong> (même si certains sont en cours de développement, ça aura quand même mis le temps).</p>
<p>Quitte à laisser la communauté développer ses alternatives, autant lui offrir de <strong>meilleures briques de base</strong> (au hasard, un système natif de liste virtualisée), une <strong>meilleure accessibilité par défaut</strong>, <strong>des arguments pour ramener sur le web des produits s'étant tournés vers les stores</strong> mobiles pour y délivrer de meilleures expériences : tout le monde y gagne.</p>
<p>Plus on fera comme si les usages tels que ceux qui poussent les gens à utiliser CSS-in-JS n'existent pas, ou pire, qu'ils ne sont pas légitimes, plus la scission dans la communauté sera grande et <strong>moins le web y gagnera</strong>.</p>
<p>Aliéner la communauté en expliquant avec dédain qu'une partie <strong>fait de la merde</strong>, qu'elle <strong>ne sait pas se servir des outils qu'on lui met à disposition</strong>, ça ne mènera nulle part. <strong>Le narratif du <em>dev JS qui comprend rien à CSS et donc fait du CSS-in-JS</em> n'a jamais tenu</strong>, et la plupart des adeptes de CSS-in-JS ont utilisé (voire aimé) CSS avant d'y trouver des limites pratiques.</p>
<p>Au motif d'une doctrine ou d'une préférence esthétique, ne pas chercher à comprendre <strong>pourquoi</strong> on se tourne vers de telles solutions, à comprendre les <strong>limites structurelles</strong> que pose le modèle qu'offre et promeut CSS, c'est retarder indéfiniment le moment où on pourra se poser autour d'une table pour parler de ces limites et y <strong>trouver des solutions</strong>.</p>
<p>Quand la majorité des application devra utiliser <a href="https://developer.mozilla.org/fr/docs/WebAssembly">WebAssembly</a> pour contourner les limites de la plateforme et être en mesure de délivrer <strong>de meilleurs produits pour leurs utilisateur·rice·s</strong>, on pourra pas dire que ce sera sorti de nulle part.</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Retour%20sur%20plusieurs%20ann%C3%A9es%20de%20CSS-in-JS%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fretour-sur-plusieurs-annees-de-css-in-js" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"retour-sur-plusieurs-annees-de-css-in-js","v":{"_0":{"TAG":0,"_0":{"slug":"retour-sur-plusieurs-annees-de-css-in-js","filename":"2021-02-08-retour-sur-plusieurs-annees-de-css-in-js","title":"Retour sur plusieurs années de CSS-in-JS","date":"Mon, 08 Feb 2021 00:00:00 GMT","draft":false,"meta":{"title":"Retour sur plusieurs années de CSS-in-JS","date":"2021-02-08T00:00:00.000Z","author":"bloodyowl","slug":"retour-sur-plusieurs-annees-de-css-in-js"},"body":"<p>Voilà maintenant plus de 4 ans, je vous partageais <a href=\"/articles/pourquoi-j-ai-arrete-d-utiliser-css/\">les raisons me poussant à me détourner de mon amour initial pour CSS</a>, alors que je m'en allais vers des alternatives qui proposaient des solutions aux problèmes que je rencontrais quotidiennement.</p>\n<p>L'article original, écrit dans la fougue de la jeunesse, utilisait un ton dit de &quot;petit merdeux&quot;. J'ai bien conscience que ça n'avait à l'époque pas aidé à faire passer le message souhaité, comme peuvent <a href=\"http://www.glazman.org/weblog/dotclear/index.php?post/2016/06/18/Pourquoi-il-n-aurait-pas-du-arrêter-d-utiliser-CSS\">en témoigner</a> <a href=\"/articles/pourquoi-j-ai-arrete-d-utiliser-css/#disqus_thread\">les différents retours</a>. Je vais donc profiter de cette rétrospective pour résumer son propos un peu plus finement.</p>\n<h2>Arrêter de sacraliser CSS</h2>\n<p>Au départ, CSS était de loin mon langage préféré de la stack web. J'ai adoré bidouiller avec ce langage pendant des années, faire le malin avec des hacks qui me permettaient de faire les rendus que je voulais. <strong>J'ai adoré CSS</strong>. Je trouvais ça chouette d'utiliser des pseudo-éléments pour faire des bords arrondis, de fabriquer mes sprites et de factoriser mes styles en commun derrière des sélecteurs.</p>\n<p>Puis vint le travail en équipe et les projets plus gros. Chacun notre tour on casse quelque chose, quelque part dans le projet. On change le style appliqué à un sélecteur et ça applique ces styles à un endroit auquel on ne pensait pas. On corrige, ça pète quelque chose ailleurs. Le problème, c'est que <strong>les sélecteurs s'appliquent globalement sur l'intégralité du projet</strong>. Qui plus est, l'application d'un style est un calcul savant: il dépend non seulement d'un sélecteur, de l'<strong>endroit où il est défini</strong> dans la feuille de style (les derniers écrasent les premiers), mais aussi de ce qu'on appelle <strong>sa spécificité</strong> (une sorte de score de précision, qui fait que plus un sélecteur est considéré comme &quot;fin&quot; par le système, plus il prendra la précédence). Si cette complexité n'était pas suffisante, ce ne sont pas des déclarations de style indivisibles qui s'écrasent les unes les autres, mais les <strong>propriétés individuelles</strong> qu'elles contiennent, comme un gros <code>merge</code> complexe dont l'ordre varie selon tous les paramètres cités au dessus pour chaque élément. Il faut donc inspecter minutieusement ce qui s'applique déjà à un élément pour savoir quoi écraser ou non.</p>\n<p>Naturellement, la feuille de style devient rapidement une course à la spécificité et on se retrouve avec des styles de plus en plus compliqués à annuler lorsqu'on veut appliquer une exception. Ça devient rapidement un <strong>cauchemar de maintenabilité</strong> : à chaque étape du projet on peut casser des éléments sans avoir voulu les changer, on doit <strong>tout</strong> revérifier à chaque changement.</p>\n<p>On peut ceci dit y remédier, en se mettant d'accord sur des <strong>méthodologies</strong> qui feront en sorte d'éviter ce genre d'effets de bord, mieux vaut prévenir que guérir. C'est <strong>BEM</strong> (Block Element Modifier) qui retiendra mon attention, avec une logique plus simple à aborder que la majorité des autres méthodologies : on utilise des sélecteurs avec <strong>la même spécificité</strong>, des attributs <code>class</code>, qu'on nomme tous d'une certaine façon. Ce nommage indiquant clairement la nature et le rôle de chaque élément, on isole chaque bloc réutilisable derrière son <strong>namespace</strong>.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;UserProfile&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;UserProfile-avatar&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;UserProfile-username&quot;</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Dès lors, on change de modèle mental : en pratique les sélecteurs ne sont plus des instructions complexes pour trouver des élements de notre page selon leur contexte, mais un <strong>simple clé-valeur</strong>. HTML et CSS <strong>partagent désormais cette clé</strong>, et ça simplifie le travail de tout le monde : une approche unifiée pour toute l'équipe, <strong>moins de conflits</strong> dans l'application des styles, <strong>moins de regressions</strong>, et une <strong>meilleure &quot;recherchabilité&quot;</strong> (la clé étant partagée entre le markup et le style). Le seul détail qui fait tiquer c'est que les noms de <code>class</code> sont quand même un poil long et répétitifs.</p>\n<p>La communauté réclame depuis des années un standard donnant la possibilité de créer des <strong>styles &quot;scopés&quot;</strong>, c'est à dire <strong>limités dans leur porté</strong>, ce qui résoudrait notre problème de noms trop longs. Et c'est une solution technique, hors standards, qui va apporter une solution : les <strong>CSS modules</strong>. C'est une technique d'injection des styles qui transforme les sélecteurs en les <strong>préfixant de clés uniques, correspondant au scope</strong>. Là où BEM nous forçait à maintenir notre namespace à la main, on a désormais un système capable de s'en charger, et ce système est moins faillible que nous.</p>\n<p>À mon sens, <strong>les CSS modules sont la première occurence de CSS-in-JS</strong>. Probablement une question de syntaxe, mais cette technique est relativement bien acceptée. Suite à la popularisation de ce système, les idées fusent et les solutions CSS-in-JS se multiplient, chacune avec son approche sur le sujet.</p>\n<p>Qu'est-ce qu'on peut tirer de ça ? Que oui, comme le disent ses défenseurs, CSS est puissant, son système d'application des styles l'est très certainement. Ce n'est pas pour autant qu'il est <strong>pratique</strong> et <strong>adapté</strong> à de gros projets qu'on doit maintenir dans le temps. La complexité qui en découle <strong>impose aux devs une forme de rigueur</strong>, faute de quoi les regressions sont inévitables. <strong>Ça a un coût, en temps passé et en énergie mentale déployée</strong>.  Si cette rigueur peut être déléguée à une machine, quelle raison aurait-on de s'en priver ?</p>\n<p>CSS a beau n'être qu'un <strong>langage informatique</strong>, on a parfois l'impression qu'il est considéré comme une <strong>doctrine religieuse</strong>, et on m'a souvent reproché de promouvoir des approches qui délèguent la charge mentale induite à une machine, avec l'argument que je ne savais pas faire de CSS. Parce que CSS, par sa volonté propre, voulait qu'il en soit autrement.</p>\n<p>Non, CSS n'a pas été originalement prévu pour être utilisé comme ça. Et c'est pas grave, c'était il y a 25 ans (environ un millénaire en années tech). Les usages, les besoins, tout ça a évolué. <strong>Il y a 25 ans il était inimaginable que le web puisse devenir ce qu'il est aujourd'hui</strong>, avec des interfaces incroyablement riches, permettant de faire à peu près ce qu'on veut depuis un navigateur. Pourquoi cette vision originale devrait nous freiner dans nos idées ? Pourquoi devrait-elle nous imposer une difficulté ? On ne parle pas d'un problème éthique complexe : qu'on délègue ou pas, qu'on automatise ou pas, ça ne change rien à personne. Il s'agit juste d'un attachement profond à une doctrine.</p>\n<p>Je pense qu'il est temps d'<strong>arrêter de sacraliser tous les aspects de CSS</strong>. Je suis admiratif de son modèle de boite, de styling, et je pense honnêtement que c'est un des outils permettant l'expression du style de la manière la plus simple possible. En revanche, je trouve sa façon de résoudre les styles complètement obsolète et risquée dans les contextes où je l'utilise.</p>\n<p>J'utilise les parties de CSS qui me permettent de faire ce que je veux (pour simplifier, tout ce qu'on trouve entre des accolades), et je délègue la gestion des autres parties à une machine.</p>\n<h2>CSS-in-JS, qu'est-ce que ça apporte ?</h2>\n<p>Alors maintenant, au bout de 4/5 ans, qu'est-ce que ça donne, CSS-in-JS ? Est-ce que c'était une immense connerie ? Est-ce que c'est finalement une bonne idée ?</p>\n<p>Pour expliquer un peu mon usage: je travaille sur une <strong>web app dont je maîtrise le markup</strong> (si ce n'est pas votre cas, il y a fort à parier que CSS-in-JS vous pose plus de problèmes que de solutions ⚠️).</p>\n<p>J'utilise deux &quot;genres&quot; de CSS-in-JS. Mon application se divise en deux parties: un widget dans une iframe-sourceless et un dashboard. Le widget utilise pour des raisons pratiques des styles inline (l'attribut style, oui oui 😱) et le dashboard la bibliothèque <a href=\"https://emotion.sh/docs/introduction\">emotion</a>.</p>\n<p>Eh bien je suis très content des deux. <strong>Je n'ai pas eu la moindre régression liée à de l'application de style depuis que j'utilise CSS-in-JS</strong>.</p>\n<p>Ma manière de définir et d'appliquer un style à un élément ressemble à ça (attention, c'est du <a href=\"https://rescript-lang.org\">ReScript</a>):</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span> on stocke la spécification dans une variable\n<span class=\"hljs-keyword\">module</span> <span class=\"hljs-module-identifier\">Styles</span> = {\n  <span class=\"hljs-keyword\">open</span> <span class=\"hljs-module-identifier\">Css</span>;\n  <span class=\"hljs-keyword\">let</span> callToAction =\n    style(<span class=\"hljs-literal\">[</span>\n      backgroundColor(<span class=\"hljs-module-identifier\">BeOpTheme</span>.mainGreen<span class=\"hljs-operator\">-&gt;</span>hex),\n      fontSize(<span class=\"hljs-number\">16</span><span class=\"hljs-operator\">-&gt;</span>px),\n      padding4(~left=<span class=\"hljs-number\">40</span><span class=\"hljs-operator\">-&gt;</span>px, ~right=<span class=\"hljs-number\">40</span><span class=\"hljs-operator\">-&gt;</span>px, ~top=<span class=\"hljs-number\">13</span><span class=\"hljs-operator\">-&gt;</span>px, ~bottom=<span class=\"hljs-number\">16</span><span class=\"hljs-operator\">-&gt;</span>px),\n      borderRadius(<span class=\"hljs-number\">26</span><span class=\"hljs-operator\">-&gt;</span>px),\n      color(<span class=\"hljs-string\">&quot;fff&quot;</span><span class=\"hljs-operator\">-&gt;</span>hex),\n      textAlign(center),\n    <span class=\"hljs-literal\">]</span>)\n}\n<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span> on passe cette variable à l&#x27;élément souhaité\n&lt;<span class=\"hljs-module-identifier\">TouchableOpacity</span> onPress&gt;\n  &lt;div className=<span class=\"hljs-module-identifier\">Styles</span>.callToAction&gt;\n    title\n  &lt;/div&gt;\n&lt;/<span class=\"hljs-module-identifier\">TouchableOpacity</span>&gt;\n</code></pre>\n<p>Que vous trouviez ça <strong>joli ou moche, là n'est pas le sujet</strong>. La machine fait ce qu'on lui dit. Elle génère un nom de <code>class</code> en faisant un hash des styles, cette <code>class</code> <strong>ne pourra déclencher aucun effet de bord</strong> ailleurs dans l'application.</p>\n<p>Ça m'a rendu la gestion des styles tellement <strong>bête et simple</strong> qu'il n'y a pas grand chose à dire dessus. <strong>J'assigne à une variable une spécification de style</strong>, et <strong>je donne cette variable à l'élément</strong> sur lequel je la veux appliquée, et ce sera le seul style appliqué à mon élément. <em>That's it</em>. Ça élimine une catégorie entière de problèmes, me laissant l'occasion de me concentrer sur d'autres choses. Vu que j'utilise une bibliothèque typée qui s'assure qu'une propriété reçoit une valeur d'un type attendu : <strong>j'écris du CSS avec des petites roues</strong>, ça m'évite même de laisser passer des fautes de frappe.</p>\n<p>Et ce qui étaient autrefois des casse-têtes immenses sont gérés automatiquement : <strong>ça élimine les styles morts</strong> facilement, ce qui est virtuellement infaisable à grande échelle (ici, c'est simplement une variable, et on sait très facilement détecter les variables inutilisées). C'est même capable d'<strong>extraire les styles critiques au rendu de la page</strong>, automatiquement !</p>\n<p>Quand je reviens à l'occasion sur des trucs nécessitant des sélecteurs CSS (pour des choses où je ne maîtrise pas le markup, et c'est un cas d'usage très légitime), je réalise à quel point j'avais accepté une complexité incroyable parce que c'était la seule façon. Quand j'y réfléchis bien, pour styliser des éléments, j'étais obligé de me <strong>créer une cartographie mouvante dépendant d'un algorithme de résolution dont je n'avais pas forcément les paramètres à tout instant donné</strong>.</p>\n<p>Les sélecteurs représentent une charge mentale énorme qui est <strong>évitable</strong>. C'est ça, la killer feature de CSS-in-JS.</p>\n<p>La puissance des sélecteurs complexes CSS ne <strong>valent pas le coup pour moi</strong> tant que leur <a href=\"/articles/tradeoffs\">balance bénéfice/risque</a> est plus faible que l'alternative. <strong>Si exprimer la même chose que le sélecteur CSS avec du JS est plus lisible et maintenable, je ne vais pas hésiter</strong>.</p>\n<p>C'est bien d'avoir un système ultra-puissant qui impose de déployer une énergie folle. Je préfère être capable de retourner dans mon code au quotidien <a href=\"/articles/introduction-a-rud\">sans avoir à me faire des nœuds au cerveau</a>.</p>\n<h2>Mais ça casse le web !</h2>\n<p>C'est un des nombreux arguments d'autorité qu'on a entendu au fil des années. Les technologies telles que CSS-in-JS, <strong>ça casserait le web</strong>.</p>\n<p>Le blog que vous êtes en train de lire est <a href=\"/articles/comment-on-a-fait-ce-site\"><strong>une application web qui utilise CSS-in-JS</strong></a>. Est-ce qu'il casse le web ? Est-ce ça vous empêche de lire son contenu avec les styles désactivés ? Est-ce que ça vous empêche de parcourir le site sans JavaScript ? Essayez !</p>\n<p><strong>Ce que le navigateur reçoit, il est parfaitement capable de l'interpréter</strong>.</p>\n<p><strong>Ça ne change rien au résultat final</strong>, et ça facilite la vie des gens qui travaillent dessus au quotidien. <a href=\"/articles/2021-01-29-ecrivez-du-code-stupide\">Pourquoi on s'en priverait ?</a> À l'heure où l'immense majorité du code qu'on écrit à destination d'un navigateur passe par une étape de compilation (que ce soit un préprocesseur, un minifier…), pourquoi ne pas aller au bout et considérer la plateforme web comme une &quot;compilation target&quot; ? Pourquoi ne pas s'autoriser une abstraction qui nous permet de travailler plus confortablement pour <strong>un résultat équivalent, sinon meilleur</strong> ?</p>\n<h2>Pourquoi des réactions si épidermiques face à CSS-in-JS ?</h2>\n<p>Je pense qu'il est difficile d'envisager que <strong>nos connaissances puissent devenir obsolètes</strong>, particulièrement quand la connaissance a été difficile à acquérir. Tous les hacks CSS de mes débuts n'ont plus cours aujourd'hui, mes vieilles techniques ECMAScript3 sont inutiles depuis les mises à jour du langage, mes façons de gérer les interfaces en manipulant scrupuleusement le DOM me paraissent complètement archaïques maintenant que j'ai à disposition <strong>des outils gérant toute cette complexité</strong> pour moi.</p>\n<p>Ça n'a pourtant pas servi à rien : ça a forgé la vision du développement que j'ai aujourd'hui par la somme de mes expériences. <strong>Chacun·e d'entre nous a une vision singulière grâce à son parcours et c'est une excellente chose</strong>, parce que ça multiplie les points de vue et rend notre communauté plus riche.</p>\n<p>Mais il faut être capable d'<strong>archiver son savoir</strong>, particulièrement dans les domaines technologiques où l'évolution est rapide, il faut toujours partir du principe que <strong>l'utilité de nos connaissances n'est pas intemporelle</strong>.</p>\n<p>Demain, avec l'expérience collective accumulée et les progrès qu'elle induira, <strong>ce qui a toujours été vrai ne le sera plus</strong>. Certaines limites se poussent, d'autres se rapprochent. Dans l'immense majorité des cas, c'est pour le mieux : les applications qu'on est capable de produire aujourd'hui étaient encore impensables il y a quelques années. La vitesse à laquelle on est capable de les produire l'était encore plus.</p>\n<h2>Qu'est-ce qu'on peut souhaiter maintenant ?</h2>\n<p>Ce que je souhaite pour les années à venir, c'est que les groupes de travail spécifiant les standards web parviennent à <strong>mettre le doigt sur les problèmes décrits ici</strong>, que je suis loin d'être le seul à exprimer.</p>\n<p>Qu'on arrête de se concentrer sur des nouveaux sélecteurs, des nouveaux systèmes de layout ne faisant rien de plus que ce qu'on pouvait déjà faire avant ou des raccourcis pour des propriétés de transformation qui de toute façon dépendent de l'ordre dans lequel on les applique. Je ne dis pas que ce sont des propositions inutiles dans l'absolu, mais ça me semble être très superficiel au regard des <strong>transformations structurelles</strong> que des outils maintenus par la communauté proposent.</p>\n<p>J'aimerais qu'on déploie notre énergie à <strong>rendre la plateforme meilleure</strong>, <strong>plus accessible</strong> et <strong>plus maintenable</strong>. Aujourd'hui on est encore forcés de gérer nous-mêmes des &quot;pièges à focus&quot; pour nos modales, on n'a toujours pas de solution viable pour faire varier les propriétés CSS d'un conteneur selon l'espace à sa disposition (on est censé prévoir tous les contextes où un composant réutilisable va s'afficher, puis qu'on ne peut le faire varier que selon une taille de fenêtre), on n'a pas de brique native pour créer des animations utilisant des propriétés physique performantes (les applications natives mobiles parviennent avec elles à créer des animations logiques, aidant à la compréhension des interfaces). Ces problèmes ne sont pas nouveaux, certains sont identifiés depuis plus de 15 ans, et <strong>de l'extérieur il ne semble pas qu'il s'agisse d'une priorité</strong> (même si certains sont en cours de développement, ça aura quand même mis le temps).</p>\n<p>Quitte à laisser la communauté développer ses alternatives, autant lui offrir de <strong>meilleures briques de base</strong> (au hasard, un système natif de liste virtualisée), une <strong>meilleure accessibilité par défaut</strong>, <strong>des arguments pour ramener sur le web des produits s'étant tournés vers les stores</strong> mobiles pour y délivrer de meilleures expériences : tout le monde y gagne.</p>\n<p>Plus on fera comme si les usages tels que ceux qui poussent les gens à utiliser CSS-in-JS n'existent pas, ou pire, qu'ils ne sont pas légitimes, plus la scission dans la communauté sera grande et <strong>moins le web y gagnera</strong>.</p>\n<p>Aliéner la communauté en expliquant avec dédain qu'une partie <strong>fait de la merde</strong>, qu'elle <strong>ne sait pas se servir des outils qu'on lui met à disposition</strong>, ça ne mènera nulle part. <strong>Le narratif du <em>dev JS qui comprend rien à CSS et donc fait du CSS-in-JS</em> n'a jamais tenu</strong>, et la plupart des adeptes de CSS-in-JS ont utilisé (voire aimé) CSS avant d'y trouver des limites pratiques.</p>\n<p>Au motif d'une doctrine ou d'une préférence esthétique, ne pas chercher à comprendre <strong>pourquoi</strong> on se tourne vers de telles solutions, à comprendre les <strong>limites structurelles</strong> que pose le modèle qu'offre et promeut CSS, c'est retarder indéfiniment le moment où on pourra se poser autour d'une table pour parler de ces limites et y <strong>trouver des solutions</strong>.</p>\n<p>Quand la majorité des application devra utiliser <a href=\"https://developer.mozilla.org/fr/docs/WebAssembly\">WebAssembly</a> pour contourner les limites de la plateforme et être en mesure de délivrer <strong>de meilleurs produits pour leurs utilisateur·rice·s</strong>, on pourra pas dire que ce sera sorti de nulle part.</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>