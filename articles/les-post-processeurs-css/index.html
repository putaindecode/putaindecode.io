<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">Les post-processeurs CSS | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="Les post-processeurs CSS | Putain de code" property="og:title"/><meta data-react-helmet="true" content="Les post-processeurs CSS | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par MoOx" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/les-post-processeurs-css" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(136, 100%, 35%), hsl(113, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">Les post-processeurs CSS</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/MoOx"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="MoOx" src="https://avatars.githubusercontent.com/MoOx?size=64"/><div>MoOx<!-- --> <!-- -->•<!-- --> <!-- -->2014/04/08</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Vous avez surement entendu parler des
<a href="http://iamvdo.me/blog/les-postprocesseurs-css"><em>post-processeurs CSS</em></a>. J'ai
personnellement pas mal fait référence à <del>ce concept</del> cette expression ces
derniers temps. Que ce soit lorsque je vous racontais
<a href="/fr/articles/css/autoprefixer">comment se passer des préfixes CSS</a>
ou lors <a href="/fr/articles/css/preprocesseurs/">d'un point sur les
pré-processeurs CSS</a>. N'y a-t-il rien qui vous a fait tiquer ?</p>
<h2>Du post-processing ?</h2>
<p>Bon on va pas jouer sur les mots mais quand même un peu. <em>Post</em> ça veut dire
après. Mais après quoi ? Après du <em>processing</em>. Donc en théorie après que la
feuille de style ait été traitée.</p>
<p>Si on revient sur <em>pré-processeurs</em>, on a quelques choses de sensé. On travaille
sur la feuille de style avant qu'elle n'ait été traitée. Traitée par qui ? Je
dirais le navigateur pas vous ? Dans ce cas le pré-processing est tout à fait
logique.</p>
<p>Mais le post-processing ? Du vrai post-processing ça existe ? Oui et ça
ressemblerait à ça par exemple :
<a href="http://jsfiddle.net/yyx990803/B5JTg/">Interpolation de CSS avec
Vue.js</a> (enfin je crois). Ici on a un process sur du CSS existant, déjà
traité par le navigateur.</p>
<p>Bon ok j'avoue que je pinaille un peu. On pourrait considérer que le &quot;process&quot;,
c'est le fait d'améliorer sa feuille de style et dans ce cas, on pourrait
accepter pré- et post-process. Mais ça reste pas super exact de mon point de
vue.</p>
<p>Du coup on appelle ça comment les post-processeurs ? Devrait-on appeler ça du
<em>post-pré-processing</em> ? Je vous le demande.</p>
<p>Assez plaisanté, passons donc à l'explication de ce qu'on appelera le
<em>post-processing.</em></p>
<h2>Le post-processing</h2>
<p>Quel est la différence avec du pré-processing ? Pour répondre à cette question,
il faut bien définir ce qu'est le pré-processing dans notre contexte.</p>
<h3>Le pré-processing CSS</h3>
<p>Le pré-processing est un pré-traitement avant le traitment final. Dans le cas de
feuille de style, on travaille donc sur des pré-feuilles de style. Ce ne sont
donc pas des feuilles de style. Comment les différencie-t-on ? La syntaxe.</p>
<p>Hola hola, calmez-vous. J'en entends déjà chouiner qu'avec Sass, Less et Stylus,
on peut coller du CSS valide et Ça Marche™. Oui ça marche. Mais seulement dans
ce sens. Si on essaye de faire parser un <code>@foreach</code>, <code>@include</code> ou ce genre de
nouveautés apportés par un pré-processeur, votre navigateur il va faire la
gueule.</p>
<p>En effet un pré-processeur n'est rien d'autre qu'un langage. Un nouveau. Il
ajoute des éléments à ce langage, et change même éventuellement la syntaxe.
Certes il peut s'appuyer sur un langage existant (par exemple la syntaxe Scss de
Sass, ou la syntaxe Less ) mais ça n'est pas obligé (exemple avec l'ancienne
syntaxe Sass, ou encore pour changer de registre, CoffeeScript pour du
JavaScript).</p>
<h3>Différence entre post-processing et pré-processing</h3>
<p>Avant de parler des différences il nous faut un cas concret pour y voir plus
clair. Autoprefixer est un très bon exemple, mais je vais vous en montrer un
encore plus pertinent: les fallbacks REM. J'espère que vous connaissez le REM
(root EM), cette unité CSS très utile qui permet d'avoir la souplesse de l'unité
EM, en se basant non sur l'élement parent, mais l'élement root (donc le
document). Cette unité CSS n'est par exemple pas compatible avec IE8, et certain
d'entre vous doivent encore le supporter.</p>
<p>On a donc vu pas mal de mixins genre <code>rem2px()</code> pour ajouter un fallback, via
des pré-processeurs CSS. Sauf que là, il semble beaucoup plus pertinent de ne
pas alourdir son code (car on y ajoute rien d'intéressant), surtout lorsque
c'est pour supporter de vieux navigateurs. Et si on pouvait ajouter un petit
coup de peinture magique, je dirais même automatique, afin d'avoir ce fallback ?</p>
<p>Et bien, on peut. Ça prend 20 secondes, et ça fera les choses bien, sans oubli.
Exemple avec
<a href="https://github.com/ctalkington/rework-rem-fallback">rework-rem-fallback</a></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// il faudrait installer les dépendances de la façon suivante</span>
<span class="hljs-comment">// $ npm i rework rework-rem-fallback</span>

<span class="hljs-keyword">var</span> rework = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;rework&quot;</span>); <span class="hljs-comment">// le moteur rework, je reviens dessus après</span>
<span class="hljs-keyword">var</span> remFallback = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;rework-rem-fallback&quot;</span>); <span class="hljs-comment">// le plugin rework</span>

<span class="hljs-comment">// lecture du fichier css</span>
<span class="hljs-keyword">var</span> css = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)
  .readFileSync(<span class="hljs-string">&quot;dist/index.css&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>)
  .toString();

<span class="hljs-comment">// on traite le CSS en indiquant à rework la source, et le plugin à utiliser</span>
<span class="hljs-keyword">var</span> out = rework(css)
  .use(remFallback())
  .toString();

<span class="hljs-comment">// ici on fait la même chose, mais comme si la font de base était en 14px</span>
<span class="hljs-keyword">var</span> out14 = rework(css)
  .use(remFallback(<span class="hljs-number">14</span>))
  .toString();
</code></pre>
<p>Avec l'exemple d'avant, et ce bout de CSS:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.main-header</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">5rem</span>;
}
</code></pre>
<p>... On obtiendra le résultat suivant:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.main-header</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">5rem</span>;
}
</code></pre>
<p>Notre exemple n'est pas intégré dans un
<a href="http://www.24joursdeweb.fr/2013/automatisez-votre-workflow-front-end/">workflow automatisé</a>,
mais c'est juste pour vous montrer que c'est l'histoire de 5 lignes de code et
pas autant de lignes que de fois où l'on a <code>rem</code> dans sa feuille de style.</p>
<p>Sexy n'est-ce pas ?</p>
<p>L'autre grosse différence entre le pré- et le post-processing, c'est le langage.
Ce post-processing s'effectue après du pré-processing. Donc après que le
pré-processeur, cet autre langage, ait fait son boulot.</p>
<p><strong>Le post-processing s'effectue sur du CSS de manière transparente.</strong></p>
<p><em>Ce processing s'effectue sur du vrai CSS (disons la syntaxe CSS).</em></p>
<p>Cette syntaxe étant très simple (se résumant principalement à
<code>selecteur { prop: value }</code> - oui y'a les règles <code>@*</code> en plus je sais),
<a href="https://github.com/reworkcss/css-parse#performance">c'est très rapide à parser</a>.</p>
<h2>Pourquoi du post-processing ?</h2>
<p>Comme on vient de le voir avec les 2 points précédents, on a déjà 3 bonnes
raisons :</p>
<ul>
<li>la simplicité (pour certains cas de figures, c'est plus pertinent, ça évite
trop de code et des oublis)</li>
<li>la vitesse</li>
<li>le fait de pouvoir brancher ses propres plugins</li>
</ul>
<p>Je sais pas vous mais moi ça me suffit. Et en cherchant mieux, on pourrait
sûrement trouver d'autres arguments. (<em>Rappel : d'ailleurs n'hésitez pas à
modifier cet article si vous en avez</em>).</p>
<h2>Avec quoi doit-on post-processer ces CSS ?</h2>
<p>Comme vous avez pu le voir tout à l'heure j'ai pris dans un exemple Rework, mais
il existe aussi PostCSS, plus récent.</p>
<h3><a href="https://github.com/reworkcss/rework">Rework</a></h3>
<p>Rework a été initié par le grand
<a href="https://github.com/visionmedia">TJ Holowaychuck</a>, cette machine de guerre
(<a href="http://www.quora.com/TJ-Holowaychuk-1/How-is-TJ-Holowaychuk-so-insanely-productive">que certains ne pensent même pas humain</a>
pour vous dire). TJ était il fut un temps utilisateur de Sass, il avait donc
même commencé le portage de <a href="https://github.com/stunti/sass.js">Sass en Node</a>.
Il a dû se rendre compte bien avant nous que ce n'était finalement pas forcément
la meilleure option. Il a donc développé
<a href="https://github.com/LearnBoost/stylus/">Stylus</a> (si, si, c'est bien lui), le
temps de comprendre qu'une autre approche était possible (pour info, il ne
maintient maintenant plus Stylus).</p>
<p>C'est donc
<a href="https://github.com/reworkcss/rework/commit/0a7be255bfe753d03f93c7072351266fa636e80a">le 1er Septembre 2012 qu'il pousse la première version de Rework</a>.</p>
<p>L'objectif de Rework n'est pas spécialement de gérer du post-process. Rework se
place comme un manipulateur de CSS, permettant (entre autres) :</p>
<ul>
<li>l'automatisation d'ajout des préfixes</li>
<li>la création de nouvelles propriétés</li>
<li>l'intégration d'images inline</li>
</ul>
<p>Vous me direz que ça ressemble vachement à un pré-processeur n'est-ce pas ? Vu
l'historique que je viens de vous conter et
<a href="https://github.com/reworkcss/rework#plugins">les plugins par défaut</a>, vous
aurez bien compris que c'est l'idée : faire un moteur de pré-processeur où l'on
y branche des plugins pour ajouter nos propres fonctionnalités. C'est grâce à ce
projet qu'Autoprefixer a initialement vu le jour d'ailleurs.</p>
<h3><a href="https://github.com/ai/postcss">PostCSS</a></h3>
<p>Beaucoup plus récent, PostCSS a été écrit par l'auteur d'Autoprefixer.</p>
<blockquote>
<p>Heu mais quoi ? Tu viens de nous dire que Autoprefixer utilisait Rework ?!</p>
</blockquote>
<p>Oui <em>c'était</em> le cas. <em>Utilisait</em>. L'auteur de PostCSS s'explique dans
<a href="https://github.com/ai/postcss#rework">son README</a>. Il y indique que, bien que
très similaire, Rework et PostCSS n'ont pas été développé pour les mêmes
raisons. C'est ce qui explique les différences au niveau des moteurs. PostCSS se
veut plus préservateur par rapport à votre source d'origine, et gère donc mieux
sourcemap, peut conserver votre espacement et indentation, parse de manière plus
sécurisé (vu que ça se veut mieux gérer le code legacy).</p>
<p>Dans la pratique je n'ai jamais eu de problème avec Rework, me souciant peu de
la mise en forme de la sortie CSS. Mais PostCSS semble avoir une API plus haut
niveau et plus souple pour mieux travailler les feuilles de styles.</p>
<h3>Rework ou PostCSS ?</h3>
<p>Tout dépend ce que vous voulez faire. Si vous avez en tête l'idée de développer
un outil, je pencherais plus vers PostCSS. Mais en temps qu'utilisateur, pour
l'instant, définitivement Rework.</p>
<p>Ce dernier a clairement beaucoup plus de plugins existants. Voyez par vous-mêmes
:</p>
<ul>
<li><a href="https://www.npmjs.org/search?q=rework">npmjs.org/search?q=rework</a></li>
<li><a href="https://www.npmjs.org/search?q=postcss">npmjs.org/search?q=postcss</a></li>
</ul>
<h2>Rework ce n'est pas <em>que</em> du post-processing ?</h2>
<p>Oui en effet, comme je le disais avant, c'est pas le but. C'est du &quot;processing&quot;.
Pré-, post-... Qu'est-ce que ça change dans le fond hein ?</p>
<p>L'idée, en temps que développeur, est d'améliorer le confort d'écriture sans
contrainte. Comme je l'ai indiqué
<a href="/fr/articles/css/preprocesseurs/#mon-avis-sur-les-pr-processeurs">précédemment</a>,
j'ai laché les pré-processeurs &quot;classiques&quot; ayant l'impression d'utiliser un
tank pour tuer une mouche. Car au fond pour 90% (si ce n'est plus) d'entres
nous, que nous faut-il pour bien développer des feuilles de styles ? Un peu
d'organisation, des variables et un poil de math ? Personnellement je me
contente de ça. Pour l'organisation, je suis devenu fan de BEM (on vous en parle
bientôt).</p>
<p><strong>Et en attendant de vraiment pouvoir utiliser les variables CSS associé à
<code>calc()</code>, je reste sur du <em>custom pré-processing</em> via Rework avec lequel je peux
coder avec la syntaxe des specs (même si c'est en draft), plus future-proof.</strong></p>
<p>J'aime conserver la syntaxe CSS et avoir un process ultra-rapide et transparent.</p>
<h3>Prochaine étape: faire son propre pré/post-processeur CSS, c'est simple</h3>
<p>Rework ayant un bon petit paquet de plugins déjà existants, c'est assez simple
de
<a href="/fr/articles/css/preprocesseurs/a-la-carte/">réaliser son propre pré-processeur</a>
via quelques lignes de code seulement.</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Les%20post-processeurs%20CSS%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fles-post-processeurs-css" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"les-post-processeurs-css","v":{"_0":{"TAG":0,"_0":{"slug":"les-post-processeurs-css","filename":"2014-04-08-les-post-processeurs-css","title":"Les post-processeurs CSS","date":"Tue, 08 Apr 2014 00:00:00 GMT","draft":false,"meta":{"date":"2014-04-08T00:00:00.000Z","title":"Les post-processeurs CSS","author":"MoOx","oldSlug":"css/preprocesseurs/post-processeurs","slug":"les-post-processeurs-css"},"body":"<p>Vous avez surement entendu parler des\n<a href=\"http://iamvdo.me/blog/les-postprocesseurs-css\"><em>post-processeurs CSS</em></a>. J'ai\npersonnellement pas mal fait référence à <del>ce concept</del> cette expression ces\nderniers temps. Que ce soit lorsque je vous racontais\n<a href=\"/fr/articles/css/autoprefixer\">comment se passer des préfixes CSS</a>\nou lors <a href=\"/fr/articles/css/preprocesseurs/\">d'un point sur les\npré-processeurs CSS</a>. N'y a-t-il rien qui vous a fait tiquer ?</p>\n<h2>Du post-processing ?</h2>\n<p>Bon on va pas jouer sur les mots mais quand même un peu. <em>Post</em> ça veut dire\naprès. Mais après quoi ? Après du <em>processing</em>. Donc en théorie après que la\nfeuille de style ait été traitée.</p>\n<p>Si on revient sur <em>pré-processeurs</em>, on a quelques choses de sensé. On travaille\nsur la feuille de style avant qu'elle n'ait été traitée. Traitée par qui ? Je\ndirais le navigateur pas vous ? Dans ce cas le pré-processing est tout à fait\nlogique.</p>\n<p>Mais le post-processing ? Du vrai post-processing ça existe ? Oui et ça\nressemblerait à ça par exemple :\n<a href=\"http://jsfiddle.net/yyx990803/B5JTg/\">Interpolation de CSS avec\nVue.js</a> (enfin je crois). Ici on a un process sur du CSS existant, déjà\ntraité par le navigateur.</p>\n<p>Bon ok j'avoue que je pinaille un peu. On pourrait considérer que le &quot;process&quot;,\nc'est le fait d'améliorer sa feuille de style et dans ce cas, on pourrait\naccepter pré- et post-process. Mais ça reste pas super exact de mon point de\nvue.</p>\n<p>Du coup on appelle ça comment les post-processeurs ? Devrait-on appeler ça du\n<em>post-pré-processing</em> ? Je vous le demande.</p>\n<p>Assez plaisanté, passons donc à l'explication de ce qu'on appelera le\n<em>post-processing.</em></p>\n<h2>Le post-processing</h2>\n<p>Quel est la différence avec du pré-processing ? Pour répondre à cette question,\nil faut bien définir ce qu'est le pré-processing dans notre contexte.</p>\n<h3>Le pré-processing CSS</h3>\n<p>Le pré-processing est un pré-traitement avant le traitment final. Dans le cas de\nfeuille de style, on travaille donc sur des pré-feuilles de style. Ce ne sont\ndonc pas des feuilles de style. Comment les différencie-t-on ? La syntaxe.</p>\n<p>Hola hola, calmez-vous. J'en entends déjà chouiner qu'avec Sass, Less et Stylus,\non peut coller du CSS valide et Ça Marche™. Oui ça marche. Mais seulement dans\nce sens. Si on essaye de faire parser un <code>@foreach</code>, <code>@include</code> ou ce genre de\nnouveautés apportés par un pré-processeur, votre navigateur il va faire la\ngueule.</p>\n<p>En effet un pré-processeur n'est rien d'autre qu'un langage. Un nouveau. Il\najoute des éléments à ce langage, et change même éventuellement la syntaxe.\nCertes il peut s'appuyer sur un langage existant (par exemple la syntaxe Scss de\nSass, ou la syntaxe Less ) mais ça n'est pas obligé (exemple avec l'ancienne\nsyntaxe Sass, ou encore pour changer de registre, CoffeeScript pour du\nJavaScript).</p>\n<h3>Différence entre post-processing et pré-processing</h3>\n<p>Avant de parler des différences il nous faut un cas concret pour y voir plus\nclair. Autoprefixer est un très bon exemple, mais je vais vous en montrer un\nencore plus pertinent: les fallbacks REM. J'espère que vous connaissez le REM\n(root EM), cette unité CSS très utile qui permet d'avoir la souplesse de l'unité\nEM, en se basant non sur l'élement parent, mais l'élement root (donc le\ndocument). Cette unité CSS n'est par exemple pas compatible avec IE8, et certain\nd'entre vous doivent encore le supporter.</p>\n<p>On a donc vu pas mal de mixins genre <code>rem2px()</code> pour ajouter un fallback, via\ndes pré-processeurs CSS. Sauf que là, il semble beaucoup plus pertinent de ne\npas alourdir son code (car on y ajoute rien d'intéressant), surtout lorsque\nc'est pour supporter de vieux navigateurs. Et si on pouvait ajouter un petit\ncoup de peinture magique, je dirais même automatique, afin d'avoir ce fallback ?</p>\n<p>Et bien, on peut. Ça prend 20 secondes, et ça fera les choses bien, sans oubli.\nExemple avec\n<a href=\"https://github.com/ctalkington/rework-rem-fallback\">rework-rem-fallback</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// il faudrait installer les dépendances de la façon suivante</span>\n<span class=\"hljs-comment\">// $ npm i rework rework-rem-fallback</span>\n\n<span class=\"hljs-keyword\">var</span> rework = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;rework&quot;</span>); <span class=\"hljs-comment\">// le moteur rework, je reviens dessus après</span>\n<span class=\"hljs-keyword\">var</span> remFallback = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;rework-rem-fallback&quot;</span>); <span class=\"hljs-comment\">// le plugin rework</span>\n\n<span class=\"hljs-comment\">// lecture du fichier css</span>\n<span class=\"hljs-keyword\">var</span> css = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;fs&quot;</span>)\n  .readFileSync(<span class=\"hljs-string\">&quot;dist/index.css&quot;</span>, <span class=\"hljs-string\">&quot;utf8&quot;</span>)\n  .toString();\n\n<span class=\"hljs-comment\">// on traite le CSS en indiquant à rework la source, et le plugin à utiliser</span>\n<span class=\"hljs-keyword\">var</span> out = rework(css)\n  .use(remFallback())\n  .toString();\n\n<span class=\"hljs-comment\">// ici on fait la même chose, mais comme si la font de base était en 14px</span>\n<span class=\"hljs-keyword\">var</span> out14 = rework(css)\n  .use(remFallback(<span class=\"hljs-number\">14</span>))\n  .toString();\n</code></pre>\n<p>Avec l'exemple d'avant, et ce bout de CSS:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.main-header</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">5rem</span>;\n}\n</code></pre>\n<p>... On obtiendra le résultat suivant:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.main-header</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80px</span>;\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">5rem</span>;\n}\n</code></pre>\n<p>Notre exemple n'est pas intégré dans un\n<a href=\"http://www.24joursdeweb.fr/2013/automatisez-votre-workflow-front-end/\">workflow automatisé</a>,\nmais c'est juste pour vous montrer que c'est l'histoire de 5 lignes de code et\npas autant de lignes que de fois où l'on a <code>rem</code> dans sa feuille de style.</p>\n<p>Sexy n'est-ce pas ?</p>\n<p>L'autre grosse différence entre le pré- et le post-processing, c'est le langage.\nCe post-processing s'effectue après du pré-processing. Donc après que le\npré-processeur, cet autre langage, ait fait son boulot.</p>\n<p><strong>Le post-processing s'effectue sur du CSS de manière transparente.</strong></p>\n<p><em>Ce processing s'effectue sur du vrai CSS (disons la syntaxe CSS).</em></p>\n<p>Cette syntaxe étant très simple (se résumant principalement à\n<code>selecteur { prop: value }</code> - oui y'a les règles <code>@*</code> en plus je sais),\n<a href=\"https://github.com/reworkcss/css-parse#performance\">c'est très rapide à parser</a>.</p>\n<h2>Pourquoi du post-processing ?</h2>\n<p>Comme on vient de le voir avec les 2 points précédents, on a déjà 3 bonnes\nraisons :</p>\n<ul>\n<li>la simplicité (pour certains cas de figures, c'est plus pertinent, ça évite\ntrop de code et des oublis)</li>\n<li>la vitesse</li>\n<li>le fait de pouvoir brancher ses propres plugins</li>\n</ul>\n<p>Je sais pas vous mais moi ça me suffit. Et en cherchant mieux, on pourrait\nsûrement trouver d'autres arguments. (<em>Rappel : d'ailleurs n'hésitez pas à\nmodifier cet article si vous en avez</em>).</p>\n<h2>Avec quoi doit-on post-processer ces CSS ?</h2>\n<p>Comme vous avez pu le voir tout à l'heure j'ai pris dans un exemple Rework, mais\nil existe aussi PostCSS, plus récent.</p>\n<h3><a href=\"https://github.com/reworkcss/rework\">Rework</a></h3>\n<p>Rework a été initié par le grand\n<a href=\"https://github.com/visionmedia\">TJ Holowaychuck</a>, cette machine de guerre\n(<a href=\"http://www.quora.com/TJ-Holowaychuk-1/How-is-TJ-Holowaychuk-so-insanely-productive\">que certains ne pensent même pas humain</a>\npour vous dire). TJ était il fut un temps utilisateur de Sass, il avait donc\nmême commencé le portage de <a href=\"https://github.com/stunti/sass.js\">Sass en Node</a>.\nIl a dû se rendre compte bien avant nous que ce n'était finalement pas forcément\nla meilleure option. Il a donc développé\n<a href=\"https://github.com/LearnBoost/stylus/\">Stylus</a> (si, si, c'est bien lui), le\ntemps de comprendre qu'une autre approche était possible (pour info, il ne\nmaintient maintenant plus Stylus).</p>\n<p>C'est donc\n<a href=\"https://github.com/reworkcss/rework/commit/0a7be255bfe753d03f93c7072351266fa636e80a\">le 1er Septembre 2012 qu'il pousse la première version de Rework</a>.</p>\n<p>L'objectif de Rework n'est pas spécialement de gérer du post-process. Rework se\nplace comme un manipulateur de CSS, permettant (entre autres) :</p>\n<ul>\n<li>l'automatisation d'ajout des préfixes</li>\n<li>la création de nouvelles propriétés</li>\n<li>l'intégration d'images inline</li>\n</ul>\n<p>Vous me direz que ça ressemble vachement à un pré-processeur n'est-ce pas ? Vu\nl'historique que je viens de vous conter et\n<a href=\"https://github.com/reworkcss/rework#plugins\">les plugins par défaut</a>, vous\naurez bien compris que c'est l'idée : faire un moteur de pré-processeur où l'on\ny branche des plugins pour ajouter nos propres fonctionnalités. C'est grâce à ce\nprojet qu'Autoprefixer a initialement vu le jour d'ailleurs.</p>\n<h3><a href=\"https://github.com/ai/postcss\">PostCSS</a></h3>\n<p>Beaucoup plus récent, PostCSS a été écrit par l'auteur d'Autoprefixer.</p>\n<blockquote>\n<p>Heu mais quoi ? Tu viens de nous dire que Autoprefixer utilisait Rework ?!</p>\n</blockquote>\n<p>Oui <em>c'était</em> le cas. <em>Utilisait</em>. L'auteur de PostCSS s'explique dans\n<a href=\"https://github.com/ai/postcss#rework\">son README</a>. Il y indique que, bien que\ntrès similaire, Rework et PostCSS n'ont pas été développé pour les mêmes\nraisons. C'est ce qui explique les différences au niveau des moteurs. PostCSS se\nveut plus préservateur par rapport à votre source d'origine, et gère donc mieux\nsourcemap, peut conserver votre espacement et indentation, parse de manière plus\nsécurisé (vu que ça se veut mieux gérer le code legacy).</p>\n<p>Dans la pratique je n'ai jamais eu de problème avec Rework, me souciant peu de\nla mise en forme de la sortie CSS. Mais PostCSS semble avoir une API plus haut\nniveau et plus souple pour mieux travailler les feuilles de styles.</p>\n<h3>Rework ou PostCSS ?</h3>\n<p>Tout dépend ce que vous voulez faire. Si vous avez en tête l'idée de développer\nun outil, je pencherais plus vers PostCSS. Mais en temps qu'utilisateur, pour\nl'instant, définitivement Rework.</p>\n<p>Ce dernier a clairement beaucoup plus de plugins existants. Voyez par vous-mêmes\n:</p>\n<ul>\n<li><a href=\"https://www.npmjs.org/search?q=rework\">npmjs.org/search?q=rework</a></li>\n<li><a href=\"https://www.npmjs.org/search?q=postcss\">npmjs.org/search?q=postcss</a></li>\n</ul>\n<h2>Rework ce n'est pas <em>que</em> du post-processing ?</h2>\n<p>Oui en effet, comme je le disais avant, c'est pas le but. C'est du &quot;processing&quot;.\nPré-, post-... Qu'est-ce que ça change dans le fond hein ?</p>\n<p>L'idée, en temps que développeur, est d'améliorer le confort d'écriture sans\ncontrainte. Comme je l'ai indiqué\n<a href=\"/fr/articles/css/preprocesseurs/#mon-avis-sur-les-pr-processeurs\">précédemment</a>,\nj'ai laché les pré-processeurs &quot;classiques&quot; ayant l'impression d'utiliser un\ntank pour tuer une mouche. Car au fond pour 90% (si ce n'est plus) d'entres\nnous, que nous faut-il pour bien développer des feuilles de styles ? Un peu\nd'organisation, des variables et un poil de math ? Personnellement je me\ncontente de ça. Pour l'organisation, je suis devenu fan de BEM (on vous en parle\nbientôt).</p>\n<p><strong>Et en attendant de vraiment pouvoir utiliser les variables CSS associé à\n<code>calc()</code>, je reste sur du <em>custom pré-processing</em> via Rework avec lequel je peux\ncoder avec la syntaxe des specs (même si c'est en draft), plus future-proof.</strong></p>\n<p>J'aime conserver la syntaxe CSS et avoir un process ultra-rapide et transparent.</p>\n<h3>Prochaine étape: faire son propre pré/post-processeur CSS, c'est simple</h3>\n<p>Rework ayant un bon petit paquet de plugins déjà existants, c'est assez simple\nde\n<a href=\"/fr/articles/css/preprocesseurs/a-la-carte/\">réaliser son propre pré-processeur</a>\nvia quelques lignes de code seulement.</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>