<!DOCTYPE html><html lang="fr"><head><title data-react-helmet="true">Comprendre le CSS in JS par l&#x27;exemple | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><meta data-react-helmet="true" content="Comprendre le CSS in JS par l&#x27;exemple | Putain de code" property="og:title"/><meta data-react-helmet="true" content="Comprendre le CSS in JS par l&#x27;exemple | Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="Un article proposé par zoontek" name="description"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/comprendre-le-css-in-js-par-l-exemple" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion="rpcss zx73cm 1lc6tyj 28v1b4">@-webkit-keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-zx73cm{from{opacity:0;-webkit-transform:translateY(20px);-moz-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}:root{--page-background-color:#fff;--page-slightly-accented-background-color:#F9F6F6;--page-accented-background-color:#E4EBEE;--page-text-color:#46515B;--link-text-color:#E51D58;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#FAF3E1;--one-percent-contrast-color:rgba(0, 0, 0, 0.1);--half-percent-contrast-color:rgba(0, 0, 0, 0.05);}@media (prefers-color-scheme: dark){:root{--page-background-color:#222;--page-slightly-accented-background-color:#171717;--page-accented-background-color:#111;--page-text-color:#ddd;--link-text-color:#F87098;--gradient-red-top:#E51D58;--gradient-red-bottom:#CC0613;--code-background-color:#4F3804;--one-percent-contrast-color:rgba(255, 255, 255, 0.1);--half-percent-contrast-color:rgba(255, 255, 255, 0.05);}}body{padding:0;margin:0;background-color:var(--page-background-color);color:var(--page-text-color);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}html{font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}a{color:var(--link-text-color);-webkit-text-decoration:underline;text-decoration:underline;}a:hover{-webkit-text-decoration:none;text-decoration:none;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}*,*:before,*:after{box-sizing:border-box;}pre,.hljs{color:#adbac7;background:#22272e;}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#f47067;}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#dcbdfb;}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#6cb6ff;}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#96d0ff;}.hljs-built_in,.hljs-symbol{color:#f69d50;}.hljs-comment,.hljs-code,.hljs-formula{color:#768390;}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#8ddb8c;}.hljs-subst{color:#adbac7;}.hljs-section{color:#316dca;font-weight:bold;}.hljs-bullet{color:#eac55f;}.hljs-emphasis{color:#adbac7;font-style:italic;}.hljs-strong{color:#adbac7;font-weight:bold;}.hljs-addition{color:#b4f1b4;background-color:#1b4721;}.hljs-deletion{color:#ffd8d3;background-color:#78191b;}</style><style data-emotion="rpcss 9vhaby">.rpcss-9vhaby{background-color:var(--gradient-red-bottom);background-image:linear-gradient(to bottom right, var(--gradient-red-top), var(--gradient-red-bottom));}</style><header class="rpcss-9vhaby" style="background-image:linear-gradient(to bottom right, hsl(334, 100%, 35%), hsl(278, 100%, 30%))"><style data-emotion="rpcss 1qqk0tr">.rpcss-1qqk0tr{padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);}</style><div class="rpcss-1qqk0tr"><style data-emotion="rpcss qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion="rpcss 7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion="rpcss gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion="rpcss 1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion="rpcss 13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion="rpcss 4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion="rpcss u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion="rpcss 1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255, 255, 255, 0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></div></header><style data-emotion="rpcss a4ric9">.rpcss-a4ric9{background-color:var(--page-slightly-accented-background-color);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-a4ric9"><style data-emotion="rpcss oeugsb">.rpcss-oeugsb{-webkit-animation:500ms ease-out animation-zx73cm;animation:500ms ease-out animation-zx73cm;}</style><div class="rpcss-oeugsb"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">Comprendre le CSS in JS par l&#x27;exemple</h1><style data-emotion="rpcss obg2kr">.rpcss-obg2kr{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:var(--page-text-color);-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-obg2kr" href="https://github.com/zoontek"><style data-emotion="rpcss uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="zoontek" src="https://avatars.githubusercontent.com/zoontek?size=64"/><div>zoontek<!-- --> <!-- -->•<!-- --> <!-- -->2019/01/22</div></a><style data-emotion="rpcss 15kxmi0">.rpcss-15kxmi0{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-15kxmi0 h2,.rpcss-15kxmi0 h3,.rpcss-15kxmi0 h4,.rpcss-15kxmi0 h5,.rpcss-15kxmi0 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-15kxmi0 img{max-width:100%;background-color:rgba(255, 255, 255, 0.75);}.rpcss-15kxmi0 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:var(--code-background-color);margin:0 0.2em;}.rpcss-15kxmi0 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid var(--one-percent-contrast-color);-webkit-overflow-scrolling:touch;}.rpcss-15kxmi0 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-15kxmi0 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid var(--one-percent-contrast-color);font-style:italic;}.rpcss-15kxmi0 table{width:100%;text-align:center;}.rpcss-15kxmi0 figure{padding:20px 0;}.rpcss-15kxmi0 figcaption{text-align:center;}.rpcss-15kxmi0 a{word-wrap:break-word;}.rpcss-15kxmi0 table thead th{background-color:var(--page-accented-background-color);padding:10px 0;}</style><div class="rpcss-15kxmi0"><p>Il se peut que vous entendiez beaucoup parler de CSS-in-JS dernièrement. C'est
un sujet de polémique bien connu dans le milieu du front-end actuel : les
argumentaires tournent en boucle, souvent biaisés par les habitudes et / ou les
conditions de travail de chaque partie.</p>
<p>Afin de mieux comprendre ce qu'est le CSS-in-JS, nous allons créer une librairie
similaire à <a href="https://emotion.sh/">Emotion</a> ou
<a href="https://github.com/threepointone/glamor">Glamor</a>. Au fur et à mesure de la
réalisation, nous pourrons nous apercevoir qu'il est parfois possible d'améliorer
l'expérience de développement en prévenant certaines erreurs humaines et en
automatisant certaines choses.</p>
<p>Notre librairie nous permettra d'insérer des styles de façon sûre, de gérer les
pseudo-classes et les pseudo-éléments et de fournir un moyen de gérer le
responsive.</p>
<h2>Initialisation du projet</h2>
<p>Pour plus de sécurité et de confort, nous allons utiliser
<a href="http://www.typescriptlang.org">TypeScript</a>. Copiez / collez la commande
suivante pour créer et lancer un nouveau projet sobrement intitulé
<code>putain-de-css</code>.</p>
<pre><code class="hljs language-sh">npx create-react-app putain-de-css \
  &amp;&amp; <span class="hljs-built_in">cd</span> putain-de-css \
  &amp;&amp; npm i -D typescript \
  &amp;&amp; npm i -S @types/node @types/react-dom @types/react \
  &amp;&amp; rm -rf src &amp;&amp; mkdir src \
  &amp;&amp; <span class="hljs-built_in">echo</span> \
<span class="hljs-string">&#x27;import * as React from &quot;react&quot;;
import { render } from &quot;react-dom&quot;;

const App = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;
render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));&#x27;</span> \
&gt; src/index.tsx \
  &amp;&amp; npm start
</code></pre>
<p>Ouvrez votre éditeur de code préféré, on attaque directement en créant un
nouveau fichier <code>src/css.ts</code>.</p>
<h2>Insertion de style sous la forme de string</h2>
<p>La première chose à faire pour pouvoir insérer des styles au sein du CSSOM,
c'est de créer un élément DOM <code>&lt;style&gt;</code> dans le <code>&lt;head&gt;</code> de notre document, puis
de récupérer l'objet de type <code>CSSStyleSheet</code> qui lui est attaché.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>

<span class="hljs-keyword">const</span> styleEl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;style&quot;</span>);
styleEl.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&quot;&quot;</span>));
<span class="hljs-built_in">document</span>.head.appendChild(styleEl);

<span class="hljs-keyword">const</span> sheet = styleEl.sheet <span class="hljs-keyword">as</span> CSSStyleSheet;
</code></pre>
<p>À la suite, nous allons créer une fonction simple qui insère une règle CSS et
nous prévient des règles malformées en développement. Pour rappel, une règle est
constituée de la façon suivante :
<code>selector { property: value; property: value; … }</code>).</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertRule</span>(<span class="hljs-params">rule: string</span>) </span>{
  <span class="hljs-keyword">try</span> {
    sheet.insertRule(rule);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&quot;production&quot;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Malformated CSS: &quot;<span class="hljs-subst">${rule}</span>&quot;`</span>);
    }
  }
}
</code></pre>
<p>Nous pouvons dès à présent importer cette fonction au sein de notre fichier
<code>index.tsx</code> et tenter plusieurs essais.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> { insertRule } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;

<span class="hljs-comment">// testons d&#x27;abord:</span>
insertRule(<span class="hljs-string">&quot;h1 { color: hotpink }&quot;</span>);
<span class="hljs-comment">// puis:</span>
insertRule(<span class="hljs-string">&quot;1nvalid! { color: red }&quot;</span>);

<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

<span class="hljs-comment">// …</span>
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/1.png" alt="résultat avec un style objet" />
  <figcaption>Quand tout va bien</figcaption>
</figure>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/2.png" alt="résultat avec un style objet" />
  <figcaption>Quand tu tapes n'importe quoi</figcaption>
</figure>
<h2>Insertion de style sous la forme d'objets</h2>
<p>Écrire nos règles sous la forme de string est plutôt risqué : la chaîne de
caractère sera complexe à parser et à analyser. Nous nous exposons donc à
certains risques si nous ne pensons pas à prévoir certains cas.</p>
<p>De plus, si une équipe de développeurs peut insérer absolument tout ce qu'elle
souhaite dans la feuille de style, elle pourra donc utiliser l'intégralité des
sélecteurs CSS. Il faudrait donc faire appel à beaucoup de rigueur ou se reposer
sur plusieurs outils supplémentaires (extensions IDE, linter, etc.).</p>
<p>Nous allons donc créer une fonction supplémentaire pour transformer un objet en
règle insérable et dont le sélecteur sera un nom de classe généré et unique.</p>
<p>Nous allons également créer quelques types assez basiques en haut de notre
fichier.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>

<span class="hljs-comment">// &quot;Value&quot; peut être de type string OU number</span>
type Value = string | number;

<span class="hljs-comment">// &quot;Style&quot; est un objet dont les valeurs sont de type Value</span>
<span class="hljs-keyword">export</span> type Style = {
  [name: string]: Value,
};

<span class="hljs-comment">// …</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertStyle</span>(<span class="hljs-params">style: Style</span>) </span>{
  <span class="hljs-keyword">const</span> content = <span class="hljs-built_in">Object</span>.keys(style)
    .map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${style[name]}</span>`</span>)
    .join(<span class="hljs-string">&quot;; &quot;</span>);

  insertRule(<span class="hljs-string">`h1 { <span class="hljs-subst">${content}</span> }`</span>);
}
</code></pre>
<p>À ce point, vous pouvez importer <code>insertStyle</code> et vous en servir, vous
constaterez que cela a l'effet escompté… sur notre <code>h1</code> pour le moment.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> { insertStyle } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;

insertStyle({
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
  <span class="hljs-string">&quot;text-decoration&quot;</span>: <span class="hljs-string">&quot;underline&quot;</span>,
});

<span class="hljs-comment">// …</span>
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/3.png" alt="résultat avec un style objet" />
</figure>
<p>Afin de créer un nom de classe unique, il nous faut hacher notre règle CSS. Cela
consiste à transformer la donnée entrée en &quot;empreinte&quot; permettant d'identifier
celle-ci. Ainsi, deux objets au contenu identique et ordonnés de la même façon
auront tous deux la même empreinte. L'objectif étant que si plusieurs objets de
style possèdent un contenu identique, celui-ci ne sera inséré d'une seule fois.</p>
<p>Une fonction de hashage qui nous conviendrait est le <code>murmurhash2</code> disponible
sur <code>npm</code>.</p>
<pre><code class="hljs language-sh">npm i -S murmurhash @types/murmurhash
</code></pre>
<p>Nous pouvons dès à présent générer un nom de classe en fonction du contenu de
notre règle CSS.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>

<span class="hljs-keyword">import</span> murmurhash <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;murmurhash&quot;</span>;

<span class="hljs-comment">// …</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params">str: string</span>) </span>{
  <span class="hljs-comment">// on retourne un string encodé en base 36</span>
  <span class="hljs-keyword">return</span> murmurhash.v2(str, <span class="hljs-number">1</span>).toString(<span class="hljs-number">36</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertStyle</span>(<span class="hljs-params">style: Style</span>) </span>{
  <span class="hljs-keyword">const</span> content = <span class="hljs-built_in">Object</span>.keys(style)
    .map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${style[name]}</span>`</span>)
    .join(<span class="hljs-string">&quot;; &quot;</span>);

  <span class="hljs-keyword">const</span> className = <span class="hljs-string">&quot;css-&quot;</span> + hash(content);
  insertRule(<span class="hljs-string">`.<span class="hljs-subst">${className}</span> { <span class="hljs-subst">${content}</span> }`</span>);

  <span class="hljs-keyword">return</span> className;
}
</code></pre>
<p>Et même l'appliquer sur notre composant React / élément HTML / ce que vous
voulez !</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> { insertStyle } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;

<span class="hljs-keyword">const</span> className = insertStyle({
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
  <span class="hljs-string">&quot;text-decoration&quot;</span>: <span class="hljs-string">&quot;underline&quot;</span>,
});

<span class="hljs-comment">// on applique la classe créée</span>
<span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>&gt;</span>Hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/4.png" alt="résultat avec nom de classe généré" />
</figure>
<h2>Propriétés en lowerCamelCase</h2>
<p>Créons une nouvelle fonction juste avant <code>insertStyle</code>. Celle-ci va remplacer
toutes les majuscules de notre paramètre de type <code>string</code> par un hyphen + sa
minuscule.</p>
<p>Elle gère également le cas un peu spécial des préfixes Microsoft (qui ne
commencent pas par une majuscule, contrairement à ceux de Mozilla / WebKit).</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>
<span class="hljs-comment">// …</span>

<span class="hljs-comment">// expected outputs:</span>
<span class="hljs-comment">// fontFamily -&gt; font-family</span>
<span class="hljs-comment">// MozTransform -&gt; -moz-transform</span>
<span class="hljs-comment">// msTransform -&gt; -ms-transform</span>
<span class="hljs-comment">// WebkitTransform -&gt; -webkit-transform</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hyphenateName</span>(<span class="hljs-params">name: string</span>) </span>{
  <span class="hljs-keyword">return</span> name
    .replace(<span class="hljs-regexp">/([A-Z])/g</span>, <span class="hljs-function">(<span class="hljs-params">_, letter</span>) =&gt;</span> <span class="hljs-string">`-<span class="hljs-subst">${letter.toLowerCase()}</span>`</span>)
    .replace(<span class="hljs-regexp">/^ms-/</span>, <span class="hljs-string">&quot;-ms-&quot;</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertStyle</span>(<span class="hljs-params">style: Style</span>) </span>{
  <span class="hljs-keyword">const</span> content = <span class="hljs-built_in">Object</span>.keys(style)
    <span class="hljs-comment">// on ajoute l&#x27;hyphenation du nom ici</span>
    .map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${hyphenateName(name.trim())}</span>: <span class="hljs-subst">${style[name]}</span>`</span>)
    .join(<span class="hljs-string">&quot;; &quot;</span>);

  <span class="hljs-keyword">const</span> className = <span class="hljs-string">&quot;css-&quot;</span> + hash(content);
  insertRule(<span class="hljs-string">`.<span class="hljs-subst">${className}</span> { <span class="hljs-subst">${content}</span> }`</span>);

  <span class="hljs-keyword">return</span> className;
}
</code></pre>
<p>En modifiant notre appel à <code>insertStyle</code> dans <code>index.tsx</code>, on s'aperçoit que
tout fonctionne comme espéré.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">const</span> className = insertStyle({
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
  <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>, <span class="hljs-comment">// plus d&#x27;hyphens!</span>
});

<span class="hljs-comment">//…</span>
</code></pre>
<h2>Gestion des valeurs de fallback</h2>
<p>Parce qu'en CSS il est possible de faire:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">-webkit-flex</span>;
<span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">-moz-flex</span>;
<span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">flex</span>;
</code></pre>
<p>Mais que la nature des objets JavaScript ne nous le permet pas (impossible
d'avoir plusieurs clés identiques), il nous faut pouvoir prendre un tableau en
valeur.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>
<span class="hljs-comment">//…</span>

<span class="hljs-comment">// on commence par modifier le type Value</span>
type Value = string | number | <span class="hljs-built_in">Array</span>&lt;string | number&gt;;

<span class="hljs-comment">// …</span>

<span class="hljs-comment">// on externalise la &quot;cssification&quot; en 2 fonctions</span>

<span class="hljs-comment">// cssifyDeclaration retourne &quot;nom: valeur&quot; si la valeur est correcte</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cssifyDeclaration</span>(<span class="hljs-params">name: string, value: any</span>) </span>{
  <span class="hljs-keyword">if</span> (
    (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;string&quot;</span> &amp;&amp; value !== <span class="hljs-string">&quot;&quot;</span>) ||
    (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; <span class="hljs-built_in">isFinite</span>(value))
  ) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${(value + <span class="hljs-string">&quot;&quot;</span>).trim()}</span>`</span>;
  }
}

<span class="hljs-comment">// compactDeclarations filtre les falsy values et compacte le reste avec &quot;; &quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compactDeclarations</span>(<span class="hljs-params">declarations: (string | <span class="hljs-literal">undefined</span>)[]</span>) </span>{
  <span class="hljs-keyword">return</span> declarations.filter(<span class="hljs-function"><span class="hljs-params">declaration</span> =&gt;</span> !!declaration).join(<span class="hljs-string">&quot;; &quot;</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertStyle</span>(<span class="hljs-params">style: Style</span>) </span>{
  <span class="hljs-keyword">const</span> declarations = <span class="hljs-built_in">Object</span>.keys(style).map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> hName = hyphenateName(name).trim();
    <span class="hljs-keyword">const</span> value = style[name];

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(value)
      ? compactDeclarations(value.map(<span class="hljs-function"><span class="hljs-params">fbv</span> =&gt;</span> cssifyDeclaration(hName, fbv)))
      : cssifyDeclaration(hName, value);
  });

  <span class="hljs-keyword">const</span> content = compactDeclarations(declarations);
  <span class="hljs-keyword">const</span> className = <span class="hljs-string">&quot;css-&quot;</span> + hash(content);
  insertRule(<span class="hljs-string">`.<span class="hljs-subst">${className}</span> { <span class="hljs-subst">${content}</span> }`</span>);

  <span class="hljs-keyword">return</span> className;
}
</code></pre>
<p>Si on modifie le style appliqué sur notre <code>&lt;h1&gt;</code> de cette façon :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">const</span> className = insertStyle({
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
  <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>,
  <span class="hljs-attr">display</span>: [<span class="hljs-string">&quot;-webkit-flex&quot;</span>, <span class="hljs-string">&quot;-moz-flex&quot;</span>, <span class="hljs-string">&quot;flex&quot;</span>],
});

<span class="hljs-comment">// …</span>
</code></pre>
<p>On constate que le navigateur ne nous indique pas que 3 valeurs ont été insérées
(en barrant celles qui ne sont pas appliquées).</p>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/5.png" alt="inspection des styles préfixés" />
</figure>
<p>En effet, lorsque vous utilisez <code>insertRule</code>, seule la dernière valeur comprise
par le navigateur est réellement insérée. Ainsi, si on change la valeur de
<code>display</code> pour <code>[&quot;flex&quot;, &quot;-webkit-flex&quot;, &quot;-moz-flex&quot;]</code>, vous verrez que seul
<code>-webkit-flex</code> sera appliqué (si bien sûr vous utilisez un navigateur qui
comprend les préfixes WebKit mais pas les préfixes Mozilla).</p>
<h2>Gestion des pseudo-classes / éléments</h2>
<p>L'idée c'est de les déclarer directement au sein de notre déclaration de style,
si possible de façon infiniment nestés.</p>
<p>On modifie donc l'exemple pour visualiser le but à atteindre :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">const</span> className = insertStyle({
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
  <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>,

  <span class="hljs-string">&quot;:hover&quot;</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;rebeccapurple&quot;</span>,

    <span class="hljs-string">&quot;::first-letter&quot;</span>: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;cyan&quot;</span>,
    },
  },
});

<span class="hljs-comment">// …</span>
</code></pre>
<p>Idéalement, il nous faudrait une fonction qui aplatisse ce style par suffixe
appliqué à notre classe, de cette façon :</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-string">&quot;color: pink; text-decoration: underline&quot;</span>,
  <span class="hljs-string">&quot;:hover&quot;</span>: <span class="hljs-string">&quot;color: rebeccapurple&quot;</span>,
  <span class="hljs-string">&quot;:hover::first-letter&quot;</span>: <span class="hljs-string">&quot;color: cyan&quot;</span>,
};
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>
<span class="hljs-comment">// …</span>

<span class="hljs-comment">// on modifie le type Style</span>
<span class="hljs-keyword">export</span> type Style = {
  [name: string]: Value | Style,
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlainObject</span>(<span class="hljs-params">value: any</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value) === <span class="hljs-string">&quot;[object Object]&quot;</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenStyle</span>(<span class="hljs-params">style: Style, suffix: string = <span class="hljs-string">&quot;&quot;</span></span>) </span>{
  <span class="hljs-keyword">let</span> result: { [suffix: string]: string | <span class="hljs-literal">undefined</span> } = {
    <span class="hljs-comment">// on s&#x27;assure que le sélecteur &quot;racine&quot; est le premier inséré</span>
    [suffix]: <span class="hljs-literal">undefined</span>,
  };

  <span class="hljs-comment">// on extrait la logique qui était précedemment dans insertStyle</span>
  <span class="hljs-keyword">const</span> declarations = <span class="hljs-built_in">Object</span>.keys(style).map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> value = style[name];

    <span class="hljs-keyword">if</span> (isPlainObject(value)) {
      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&quot;production&quot;</span>) {
        <span class="hljs-comment">// on peaufine un peu la DX (et on évite quelques edge-cases)</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^::?(-webkit-|-moz-|-ms-)?[a-z][a-z-]+(\(.+\))?$/</span>.test(name)) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid pseudo class / element: &quot;<span class="hljs-subst">${name}</span>&quot;`</span>);
        }
      }

      <span class="hljs-keyword">const</span> nested = flattenStyle(value <span class="hljs-keyword">as</span> Style, <span class="hljs-string">`<span class="hljs-subst">${suffix}</span><span class="hljs-subst">${name}</span>`</span>);

      <span class="hljs-built_in">Object</span>.keys(nested).forEach(<span class="hljs-function"><span class="hljs-params">nName</span> =&gt;</span> {
        result[nName] = nested[nName];
      });
    } <span class="hljs-keyword">else</span> {

      <span class="hljs-keyword">const</span> hName = hyphenateName(name).trim();

      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(value)
        ? compactDeclarations(value.map(<span class="hljs-function"><span class="hljs-params">fbv</span> =&gt;</span> cssifyDeclaration(hName, fbv)))
        : cssifyDeclaration(hName, value);
    }
  });

  result[suffix] = compactDeclarations(declarations);
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>Si on passe notre style dans cette fonction <code>flattenStyle</code> afin d'en analyser la
sortie, on constate qu'elle fait exactement ce que l'on souhaite.</p>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/6.png" alt="valeur retournée par la fonction flattenStyle" />
</figure>
<p>Il ne nous reste qu'à hasher la représentation de cet objet et insérer les
règles une par une.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertStyle</span>(<span class="hljs-params">style: Style</span>) </span>{
  <span class="hljs-keyword">const</span> flattened = flattenStyle(style);
  <span class="hljs-keyword">const</span> className = <span class="hljs-string">&quot;css-&quot;</span> + hash(<span class="hljs-built_in">JSON</span>.stringify(flattened));

  <span class="hljs-built_in">Object</span>.keys(flattened).forEach(<span class="hljs-function"><span class="hljs-params">suffix</span> =&gt;</span> {
    insertRule(<span class="hljs-string">`.<span class="hljs-subst">${className}</span><span class="hljs-subst">${suffix}</span> { <span class="hljs-subst">${flattened[suffix]}</span> }`</span>);
  });

  <span class="hljs-keyword">return</span> className;
}
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/7.png" alt="résultat avec gestion du hover" />
</figure>
<h2>Concaténation de styles</h2>
<p>Une pratique assez répandue est d'appliquer conditionnellement plusieurs objets
styles en fonction de l'état de nos composants.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ce genre de chose</span>
css(styles.base, <span class="hljs-built_in">this</span>.props.disabled &amp;&amp; styles.disabled);
</code></pre>
<p>Supprimez tous les exports de fonction du fichier <code>css.ts</code>, nous n'allons en
garder qu'un seul, celui par défaut : cette fameuse fonction <code>css</code> !</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">export</span> type MaybeStyle = Style | <span class="hljs-literal">false</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;

<span class="hljs-comment">// …</span>

<span class="hljs-comment">// renommez la fonction ìnsertStyle</span>
<span class="hljs-comment">// elle accepte à présent des styles, mais aussi des &quot;falsy values&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">css</span>(<span class="hljs-params">...styles: MaybeStyle[]</span>) </span>{
  <span class="hljs-keyword">const</span> flattened = styles
    <span class="hljs-comment">// on ne garde que les objets</span>
    .filter(<span class="hljs-function"><span class="hljs-params">style</span> =&gt;</span> isPlainObject(style))
    .map(<span class="hljs-function"><span class="hljs-params">style</span> =&gt;</span> flattenStyle(style))
    .reduce(<span class="hljs-function">(<span class="hljs-params">flat, style</span>) =&gt;</span> {
      <span class="hljs-built_in">Object</span>.keys(style).forEach(<span class="hljs-function"><span class="hljs-params">suffix</span> =&gt;</span> {
        flat[suffix] = flat[suffix]
          ? <span class="hljs-string">`<span class="hljs-subst">${flat[suffix]}</span>; <span class="hljs-subst">${style[suffix]}</span>`</span>
          : style[suffix];
      });
      <span class="hljs-keyword">return</span> flat;
    }, {});

  <span class="hljs-keyword">const</span> className = <span class="hljs-string">&quot;css-&quot;</span> + hash(<span class="hljs-built_in">JSON</span>.stringify(flattened));

  <span class="hljs-built_in">Object</span>.keys(flattened).forEach(<span class="hljs-function"><span class="hljs-params">suffix</span> =&gt;</span> {
    insertRule(<span class="hljs-string">`.<span class="hljs-subst">${className}</span><span class="hljs-subst">${suffix}</span> { <span class="hljs-subst">${flattened[suffix]}</span> }`</span>);
  });

  <span class="hljs-keyword">return</span> className;
}
</code></pre>
<p>Je vous laisse ça afin de faire un test rapide:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> css <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;

<span class="hljs-keyword">const</span> className = css(
  {
    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
    <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>,

    <span class="hljs-string">&quot;:hover&quot;</span>: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;rebeccapurple&quot;</span>,
    },
  },
  {
    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,

    <span class="hljs-string">&quot;:hover&quot;</span>: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;blue&quot;</span>,
    },
  },
);

<span class="hljs-comment">// …</span>
</code></pre>
<h2>Autoprefixing</h2>
<p>Il est temps de peaufiner un peu l'expérience de développement. Si je vous dit
qu'on a implémenté toutes les features nécessaires pour utiliser l'équivalent
d'un autoprefixer (qui préfixe automatiquatiquement les propriétés pour un
meilleur support navigateur)?</p>
<p>Il s'agit d'<a href="https://inline-style-prefixer.js.org">inline-style-prefixer</a>.</p>
<pre><code class="hljs language-sh">npm i -S inline-style-prefixer @types/inline-style-prefixer
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>

<span class="hljs-keyword">import</span> { prefix } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;inline-style-prefixer&quot;</span>;

<span class="hljs-comment">// …</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">css</span>(<span class="hljs-params">...styles: Style[]</span>) </span>{
  <span class="hljs-keyword">const</span> flattened = styles
    .filter(<span class="hljs-function"><span class="hljs-params">style</span> =&gt;</span> isPlainObject(style))
    <span class="hljs-comment">// on ajoute l&#x27;appel ici</span>
    .map(<span class="hljs-function"><span class="hljs-params">style</span> =&gt;</span> flattenStyle(prefix(style) <span class="hljs-keyword">as</span> Style))
    <span class="hljs-comment">// …</span>
</code></pre>
<p>Et c'est tout! 😀</p>
<h2>Autocomplétion</h2>
<p>Le CSS-in-JS, ça peut vous rebuter quand on voit le tooling actuellement
disponible pour le CSS. L'autocomplétion dans les éditeurs de texte est quali,
ça serait bien d'avoir quelque chose de similaire… Ça tombe bien, nous utilisons
un langage typé.</p>
<pre><code class="hljs language-sh">npm i -S csstype
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>

<span class="hljs-keyword">import</span> { PropertiesFallback, SimplePseudos } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;csstype&quot;</span>;

<span class="hljs-comment">//…</span>

<span class="hljs-comment">// remplacez Style par ceci</span>
<span class="hljs-keyword">export</span> type Style = PropertiesFallback &amp;
  { [pseudo <span class="hljs-keyword">in</span> SimplePseudos]?: PropertiesFallback };

<span class="hljs-comment">// on en profite pour ajouter un type StyleSheet</span>
<span class="hljs-keyword">export</span> type StyleSheet = { [key: string]: Style };

<span class="hljs-comment">// …</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenStyle</span>(<span class="hljs-params">style: Style, suffix: string = <span class="hljs-string">&quot;&quot;</span></span>) </span>{
  <span class="hljs-keyword">let</span> result: { [suffix: string]: string | <span class="hljs-literal">undefined</span> } = {
    [suffix]: <span class="hljs-literal">undefined</span>,
  };

  <span class="hljs-keyword">const</span> declarations = <span class="hljs-built_in">Object</span>.keys(style).map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> value = (style <span class="hljs-keyword">as</span> any)[name] <span class="hljs-keyword">as</span> Value; <span class="hljs-comment">// on force le type ici</span>
    <span class="hljs-comment">// …</span>
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/8.png" alt="démo de l'autocomplétion" />
</figure>
<h2>Performances</h2>
<p>Comme vous vous en doutez, pour le moment notre lib n'est pas un foudre de
guerre : aucun système de cache n'est présent. Comme on désire tout de même
briller dans les benchmarks, tâchons d'optimiser ça.</p>
<p>Pour cela on va utiliser la mémoïsation (on utilise lodash par commodité, mais
on peut faire plus léger).</p>
<p>Pour ceux qui ne sont pas familiers avec le concept, cela nous permet de wrapper
une fonction. Lors du premier appel, la fonction est appelée normalement, son
résultat est stocké dans un objet. Lors des appels suivants, les calculs ne
seront plus effectués, le résultat en cache sera directement retourné.</p>
<pre><code class="hljs language-sh">npm i -S lodash.memoize @types/lodash.memoize
</code></pre>
<p>Trève de bavardages, on importe ça dans notre fichier <code>css.ts</code> et on optimise 😄</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/css.ts</span>

<span class="hljs-keyword">import</span> memoize <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash.memoize&quot;</span>;

<span class="hljs-comment">// …</span>

<span class="hljs-comment">// on peut mémoïser la fonction hyphenateName de façon à</span>
<span class="hljs-comment">// ce que chaque règle ne soit convertie qu&#x27;une seule fois</span>
<span class="hljs-keyword">const</span> hyphenateName = memoize(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> name
    .replace(<span class="hljs-regexp">/([A-Z])/g</span>, <span class="hljs-function">(<span class="hljs-params">_, letter</span>) =&gt;</span> <span class="hljs-string">`-<span class="hljs-subst">${letter.toLowerCase()}</span>`</span>)
    .replace(<span class="hljs-regexp">/^ms-/</span>, <span class="hljs-string">&quot;-ms-&quot;</span>);
});

<span class="hljs-comment">// …</span>

<span class="hljs-comment">// on retire le export default</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">css</span>(<span class="hljs-params">...styles: Style[]</span>) </span>{
  <span class="hljs-comment">// …</span>
}

<span class="hljs-comment">// on exporte par défaut la fonction mémoïsée</span>
<span class="hljs-comment">// le deuxième argument sert à générer une clé pour l&#x27;élément en cache</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> memoize(css, <span class="hljs-function">(<span class="hljs-params">...styles</span>) =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(styles));
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/9.png" alt="benchmark avant optimisation" />
  <figcaption>Avant mémoïsation</figcaption>
</figure>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/10.png" alt="benchmark après optimisation" />
  <figcaption>Après mémoïsation</figcaption>
</figure>
<p>À savoir qu'il existe d'autres techniques de caching, notamment à base de
<code>WeakMap</code>.</p>
<h1>Intégration avec React</h1>
<p>Parce qu'on adore React chez P!, je ne peux m'empêcher de conclure sans vous
montrer comment utiliser au mieux cette lib avec React. Créez un fichier
<code>react.tsx</code>, c'est parti !</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/react.tsx</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> cssFn, { MaybeStyle } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;

<span class="hljs-comment">// on augmente les types des éléments DOM</span>
declare <span class="hljs-built_in">module</span> <span class="hljs-string">&quot;react&quot;</span> {
  interface HTMLAttributes&lt;T&gt; {
    css?: MaybeStyle | MaybeStyle[];
  }

  interface SVGAttributes&lt;T&gt; {
    css?: MaybeStyle | MaybeStyle[];
  }
}

<span class="hljs-comment">// on override la fonction createElement de React</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>&lt;
  <span class="hljs-title">P</span> <span class="hljs-title">extends</span> </span>{
    css?: MaybeStyle | MaybeStyle[];
    className?: string;
  }
&gt;(
  Component: React.ComponentType&lt;P&gt; | string,
  <span class="hljs-attr">props</span>: P,
  ...children: React.ReactElement&lt;any&gt;[]
) {
  <span class="hljs-comment">// si le composant n&#x27;est pas un tag HTML ou qu&#x27;il</span>
  <span class="hljs-comment">// ne possède pas de prop CSS, on ne fait rien</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Component !== <span class="hljs-string">&quot;string&quot;</span> || !props.css) {
    <span class="hljs-keyword">return</span> React.createElement(Component, props, ...children);
  }

  <span class="hljs-keyword">const</span> { css, className, ...rest } = props;

  <span class="hljs-comment">// on transforme notre style en className, on l&#x27;ajoute</span>
  <span class="hljs-comment">// à la suite du className existant (si il existe)</span>
  <span class="hljs-keyword">const</span> newClassName =
    (className ? <span class="hljs-string">`<span class="hljs-subst">${className}</span> `</span> : <span class="hljs-string">&quot;&quot;</span>) +
    (<span class="hljs-built_in">Array</span>.isArray(css) ? cssFn(...css) : cssFn(css));

  <span class="hljs-keyword">return</span> React.createElement(
    Component,
    { ...rest, <span class="hljs-attr">className</span>: newClassName },
    ...children,
  );
}
</code></pre>
<p>Comment on se sert de tout ça ? Facile : on retourne dans le fichier
<code>index.tsx</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> { StyleSheet } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;
<span class="hljs-keyword">import</span> { createElement } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./react&quot;</span>;
<span class="hljs-comment">/* @jsx createElement */</span>

<span class="hljs-comment">// puisque TS supprime l&#x27;import s&#x27;il ne sert que pour le pragma JSX,</span>
<span class="hljs-comment">// on laisse trainer la valeur. Pas idéal, mais ça fait le taf.</span>
<span class="hljs-comment">// voir https://github.com/babel/babel/issues/8958</span>
createElement;

<span class="hljs-keyword">const</span> styles: StyleSheet = {
  <span class="hljs-attr">base</span>: {
    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
    <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>,
  },
  <span class="hljs-attr">fancy</span>: {
    <span class="hljs-string">&quot;::first-letter&quot;</span>: {
      <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;2em&quot;</span>,
    },
  },
};

type State = {
  <span class="hljs-attr">isFancy</span>: boolean,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;</span>{}, State&gt; {
  state = {
    <span class="hljs-attr">isFancy</span>: <span class="hljs-literal">false</span>,
  };

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">css</span>=<span class="hljs-string">{[styles.base,</span> <span class="hljs-attr">this.state.isFancy</span> &amp;&amp; <span class="hljs-attr">styles.fancy</span>]}&gt;</span>
          Hello world
        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
            this.setState(prevState =&gt; ({ isFancy: !prevState.isFancy }));
          }}
        &gt;
          Toggle fancy mode
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span></span>
    );
  }
}

<span class="hljs-comment">// …</span>
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/11.gif" alt="résultat de l'exemple" />
</figure>
<p>Si vous êtes fan de <code>styled-components</code> (personnellement je déteste ça, mais
chacun son truc), il est extrêmement simple de recréer une API similaire :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/react.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">styled</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">P</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">
  Component: T,
  style: Style | ((props: P) =&gt; Style),
</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props: P &amp; React.HTMLProps&lt;T&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { children, ...rest } = props;
    <span class="hljs-keyword">const</span> css = <span class="hljs-keyword">typeof</span> style === <span class="hljs-string">&quot;function&quot;</span> ? style(props) : style;

    <span class="hljs-keyword">return</span> createElement(
      Component,
      { ...rest, css },
      ...(children <span class="hljs-keyword">as</span> React.ReactElement&lt;any&gt;[]),
    );
  };
}
</code></pre>
<p>(Oui, c'est tout 🤭)</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> { styled } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./react&quot;</span>;

<span class="hljs-comment">// notre typage de props est mergé avec le typage de l&#x27;élément h1</span>
<span class="hljs-keyword">const</span> Title = styled(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-function">(<span class="hljs-params">props: { fancy?: boolean }</span>) =&gt;</span> ({
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
  <span class="hljs-attr">textDecoration</span>: <span class="hljs-string">&quot;underline&quot;</span>,

  ...(props.fancy &amp;&amp; {
    <span class="hljs-string">&quot;::first-letter&quot;</span>: {
      <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;2em&quot;</span>,
    },
  }),
}));

type State = {
  <span class="hljs-attr">isFancy</span>: boolean,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;</span>{}, State&gt; {
  state = {
    <span class="hljs-attr">isFancy</span>: <span class="hljs-literal">false</span>,
  };

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Title</span> <span class="hljs-attr">fancy</span>=<span class="hljs-string">{this.state.isFancy}</span>&gt;</span>Hello world<span class="hljs-tag">&lt;/<span class="hljs-name">Title</span>&gt;</span>
        {/* … */}
</span></code></pre>
<h2>Gérer le responsive</h2>
<p>Les media-queries c'est pas mal, mais au sein d'une approche composant,
appliquer des styles par rapport aux dimensions de la totalité du viewport,
c'est fort dommage.</p>
<p>Nous allons donc utiliser
<a href="https://developers.google.com/web/updates/2016/10/resizeobserver"><code>ResizeObserver</code></a>.
Le support n'est pas fou (uniquement Chrome à l'heure où j'écris ces lignes),
mais heureusement un polyfill existe.</p>
<pre><code class="hljs language-sh">npm i -S resize-observer-polyfill
</code></pre>
<p>On retourne dans le fichier <code>react.tsx</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/react.tsx</span>

<span class="hljs-keyword">import</span> ResizeObserver <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;resize-observer-polyfill&quot;</span>;

<span class="hljs-comment">// …</span>

type OnResizeCallBack = <span class="hljs-function">(<span class="hljs-params">
  dimensions: {
    height: number;
    width: number;
  },
</span>) =&gt;</span> <span class="hljs-keyword">void</span>;

declare <span class="hljs-built_in">module</span> <span class="hljs-string">&quot;react&quot;</span> {
  interface HTMLAttributes&lt;T&gt; {
    css?: MaybeStyle | MaybeStyle[];
    onResize?: OnResizeCallBack; <span class="hljs-comment">// on ajoute le callback en prop</span>
  }

  interface SVGAttributes&lt;T&gt; {
    css?: MaybeStyle | MaybeStyle[];
    onResize?: OnResizeCallBack;
  }
}

<span class="hljs-comment">// on va stocker les callbacks par élément HTML</span>
<span class="hljs-keyword">const</span> callbacks: <span class="hljs-built_in">Map</span>&lt;Element, OnResizeCallBack&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> ResizeObserver(<span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) {
    <span class="hljs-keyword">const</span> callback = callbacks.get(entry.target);

    <span class="hljs-keyword">if</span> (callback) {
      <span class="hljs-keyword">const</span> { height, width } = entry.contentRect;
      callback({ height, width });
    }
  }
});

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resizable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;</span>{
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">ref: React.RefObject&lt;Element&gt;</span>) =&gt;</span> React.ReactElement&lt;any&gt;;
  onResize: OnResizeCallBack;
}&gt; {
   <span class="hljs-comment">// il est aussi possible d&#x27;utiliser forwardRef</span>
  <span class="hljs-attr">ref</span>: React.RefObject&lt;Element&gt; = React.createRef();

  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ref.current) {
      callbacks.set(<span class="hljs-built_in">this</span>.ref.current, <span class="hljs-built_in">this</span>.props.onResize);
      observer.observe(<span class="hljs-built_in">this</span>.ref.current);
    }
  }

  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ref.current &amp;&amp; callbacks.has(<span class="hljs-built_in">this</span>.ref.current)) {
      callbacks.delete(<span class="hljs-built_in">this</span>.ref.current);
      observer.unobserve(<span class="hljs-built_in">this</span>.ref.current);
    }
  }

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.render(<span class="hljs-built_in">this</span>.ref);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>&lt;
  <span class="hljs-title">P</span> <span class="hljs-title">extends</span> </span>{
    css?: MaybeStyle | MaybeStyle[];
    className?: string;
    onResize?: OnResizeCallBack;
  }
&gt;(
  Component: React.ComponentType&lt;P&gt; | string,
  <span class="hljs-attr">props</span>: P,
  ...children: React.ReactElement&lt;any&gt;[]
) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Component !== <span class="hljs-string">&quot;string&quot;</span> || !props.css) {
    <span class="hljs-keyword">return</span> React.createElement(Component <span class="hljs-keyword">as</span> any, props, ...children);
  }

  <span class="hljs-keyword">const</span> { css, className, onResize, ...rest } = props;

  <span class="hljs-keyword">const</span> newClassName =
    (className ? <span class="hljs-string">`<span class="hljs-subst">${className}</span> `</span> : <span class="hljs-string">&quot;&quot;</span>) +
    (<span class="hljs-built_in">Array</span>.isArray(css) ? cssFn(...css) : cssFn(css));

  <span class="hljs-keyword">if</span> (onResize) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Resizable</span>
        <span class="hljs-attr">onResize</span>=<span class="hljs-string">{onResize}</span>
        <span class="hljs-attr">render</span>=<span class="hljs-string">{ref</span> =&gt;</span>
          React.createElement(
            Component,
            { ...rest, ref, className: newClassName },
            ...children,
          )
        }
      /&gt;</span>
    );
  }

  <span class="hljs-keyword">return</span> React.createElement(
    Component,
    { ...rest, <span class="hljs-attr">className</span>: newClassName },
    ...children,
  );
}
</code></pre>
<p>Et pour ce qui est de l'usage:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.tsx</span>
<span class="hljs-comment">// …</span>

<span class="hljs-keyword">import</span> { StyleSheet } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css&quot;</span>;
<span class="hljs-keyword">import</span> { createElement } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./react&quot;</span>;
<span class="hljs-comment">/* @jsx createElement */</span>
createElement; <span class="hljs-comment">// fix pour TS</span>

<span class="hljs-keyword">const</span> styles: StyleSheet = {
  <span class="hljs-attr">base</span>: {
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;hotpink&quot;</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-string">&quot;300px&quot;</span>,
    <span class="hljs-attr">maxWidth</span>: <span class="hljs-string">&quot;300px&quot;</span>,
  },
  <span class="hljs-attr">small</span>: {
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;rebeccapurple&quot;</span>,
  },
};

type State = {
  <span class="hljs-attr">width</span>: number | <span class="hljs-literal">null</span>,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;</span>{}, State&gt; {
  state = { <span class="hljs-attr">width</span>: <span class="hljs-literal">null</span> };

  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> { width } = <span class="hljs-built_in">this</span>.state;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">css</span>=<span class="hljs-string">{[</span>
          <span class="hljs-attr">styles.base</span>,
          // <span class="hljs-attr">on</span> <span class="hljs-attr">cache</span> <span class="hljs-attr">l</span>&#x27;é<span class="hljs-attr">l</span>é<span class="hljs-attr">ment</span> <span class="hljs-attr">tant</span> <span class="hljs-attr">que</span> <span class="hljs-attr">ses</span> <span class="hljs-attr">dimensions</span> <span class="hljs-attr">ne</span> <span class="hljs-attr">sont</span> <span class="hljs-attr">pas</span> <span class="hljs-attr">dispos</span>
          <span class="hljs-attr">width</span> ? <span class="hljs-attr">width</span> &lt; <span class="hljs-attr">200</span> &amp;&amp; <span class="hljs-attr">styles.small</span> <span class="hljs-attr">:</span> { <span class="hljs-attr">visibility:</span> &quot;<span class="hljs-attr">hidden</span>&quot; },
        ]}
        <span class="hljs-attr">onResize</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">width</span> }) =&gt;</span> {
          this.setState({ width });
        }}
      /&gt;</span>
    );
  }
}

<span class="hljs-comment">// …</span>
</code></pre>
<figure>
  <img src="/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/12.gif" alt="résultat responsive" />
</figure>
<p>Il est temps de conclure ! Comme vous avez pu le constater, notre errance dans
le CSSOM nous a permis de créer une abstraction qui :</p>
<ul>
<li>est déterministe (le nom de la classe est généré en fonction du style),</li>
<li>nous évite de nous soucier de la spécificité des sélecteurs CSS,</li>
<li>isole le style par composant et empêche un tas de comportements inattendus,</li>
<li>nous permet de gérer le responsive sans se soucier du contexte.</li>
</ul>
<p>Si vous ne comprenez pas certains points ou si vous avez des questions supplémentaires,
n'hésitez pas à poster un commentaire, je me ferai une joie d'y répondre.</p>
<p>La bise 😘</p>
</div><style data-emotion="rpcss unyj6i">.rpcss-unyj6i{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;margin:20px auto;padding:20px;background-color:var(--page-background-color);border-radius:10px;box-shadow:0 15px 15px -5px rgba(0, 0, 0, 0.2);}@media (max-width: 540px){.rpcss-unyj6i{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-unyj6i"><style data-emotion="rpcss ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion="rpcss klacsp">.rpcss-klacsp{width:0;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-klacsp"></div><style data-emotion="rpcss 1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Comprendre%20le%20CSS%20in%20JS%20par%20l&#x27;exemple%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fcomprendre-le-css-in-js-par-l-exemple" target="_blank">Le partager sur Twitter</a></div><style data-emotion="rpcss x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion="rpcss gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion="rpcss 8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div></div><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 1vau6rl">.rpcss-1vau6rl{margin:20px 0;background-color:var(--page-accented-background-color);border-radius:10px;padding:20px;}</style><div class="rpcss-1vau6rl"><style data-emotion="rpcss 1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion="rpcss 1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion="rpcss 1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div></div><style data-emotion="rpcss zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-1qqk0tr"><div class="rpcss-qx7dny"><style data-emotion="rpcss 79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion="rpcss 1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion="rpcss lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion="rpcss um3i31">@media (max-width: 400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion="rpcss 12cp4l7">.rpcss-12cp4l7{color:rgba(255, 255, 255, 0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2021 Putain de code !</div><style data-emotion="rpcss 1w98uy3">.rpcss-1w98uy3{position:absolute;right:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1w98uy3" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"comprendre-le-css-in-js-par-l-exemple","v":{"_0":{"TAG":0,"_0":{"slug":"comprendre-le-css-in-js-par-l-exemple","filename":"2019-01-22-comprendre-le-css-in-js-par-l-exemple","title":"Comprendre le CSS in JS par l'exemple","date":"Tue, 22 Jan 2019 00:00:00 GMT","draft":false,"meta":{"date":"2019-01-22T00:00:00.000Z","title":"Comprendre le CSS in JS par l'exemple","author":"zoontek","oldSlug":"js/css-in-js","slug":"comprendre-le-css-in-js-par-l-exemple"},"body":"<p>Il se peut que vous entendiez beaucoup parler de CSS-in-JS dernièrement. C'est\nun sujet de polémique bien connu dans le milieu du front-end actuel : les\nargumentaires tournent en boucle, souvent biaisés par les habitudes et / ou les\nconditions de travail de chaque partie.</p>\n<p>Afin de mieux comprendre ce qu'est le CSS-in-JS, nous allons créer une librairie\nsimilaire à <a href=\"https://emotion.sh/\">Emotion</a> ou\n<a href=\"https://github.com/threepointone/glamor\">Glamor</a>. Au fur et à mesure de la\nréalisation, nous pourrons nous apercevoir qu'il est parfois possible d'améliorer\nl'expérience de développement en prévenant certaines erreurs humaines et en\nautomatisant certaines choses.</p>\n<p>Notre librairie nous permettra d'insérer des styles de façon sûre, de gérer les\npseudo-classes et les pseudo-éléments et de fournir un moyen de gérer le\nresponsive.</p>\n<h2>Initialisation du projet</h2>\n<p>Pour plus de sécurité et de confort, nous allons utiliser\n<a href=\"http://www.typescriptlang.org\">TypeScript</a>. Copiez / collez la commande\nsuivante pour créer et lancer un nouveau projet sobrement intitulé\n<code>putain-de-css</code>.</p>\n<pre><code class=\"hljs language-sh\">npx create-react-app putain-de-css \\\n  &amp;&amp; <span class=\"hljs-built_in\">cd</span> putain-de-css \\\n  &amp;&amp; npm i -D typescript \\\n  &amp;&amp; npm i -S @types/node @types/react-dom @types/react \\\n  &amp;&amp; rm -rf src &amp;&amp; mkdir src \\\n  &amp;&amp; <span class=\"hljs-built_in\">echo</span> \\\n<span class=\"hljs-string\">&#x27;import * as React from &quot;react&quot;;\nimport { render } from &quot;react-dom&quot;;\n\nconst App = () =&gt; &lt;h1&gt;Hello world&lt;/h1&gt;;\nrender(&lt;App /&gt;, document.getElementById(&quot;root&quot;));&#x27;</span> \\\n&gt; src/index.tsx \\\n  &amp;&amp; npm start\n</code></pre>\n<p>Ouvrez votre éditeur de code préféré, on attaque directement en créant un\nnouveau fichier <code>src/css.ts</code>.</p>\n<h2>Insertion de style sous la forme de string</h2>\n<p>La première chose à faire pour pouvoir insérer des styles au sein du CSSOM,\nc'est de créer un élément DOM <code>&lt;style&gt;</code> dans le <code>&lt;head&gt;</code> de notre document, puis\nde récupérer l'objet de type <code>CSSStyleSheet</code> qui lui est attaché.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">const</span> styleEl = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&quot;style&quot;</span>);\nstyleEl.appendChild(<span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-string\">&quot;&quot;</span>));\n<span class=\"hljs-built_in\">document</span>.head.appendChild(styleEl);\n\n<span class=\"hljs-keyword\">const</span> sheet = styleEl.sheet <span class=\"hljs-keyword\">as</span> CSSStyleSheet;\n</code></pre>\n<p>À la suite, nous allons créer une fonction simple qui insère une règle CSS et\nnous prévient des règles malformées en développement. Pour rappel, une règle est\nconstituée de la façon suivante :\n<code>selector { property: value; property: value; … }</code>).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertRule</span>(<span class=\"hljs-params\">rule: string</span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    sheet.insertRule(rule);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Malformated CSS: &quot;<span class=\"hljs-subst\">${rule}</span>&quot;`</span>);\n    }\n  }\n}\n</code></pre>\n<p>Nous pouvons dès à présent importer cette fonction au sein de notre fichier\n<code>index.tsx</code> et tenter plusieurs essais.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { insertRule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-comment\">// testons d&#x27;abord:</span>\ninsertRule(<span class=\"hljs-string\">&quot;h1 { color: hotpink }&quot;</span>);\n<span class=\"hljs-comment\">// puis:</span>\ninsertRule(<span class=\"hljs-string\">&quot;1nvalid! { color: red }&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/1.png\" alt=\"résultat avec un style objet\" />\n  <figcaption>Quand tout va bien</figcaption>\n</figure>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/2.png\" alt=\"résultat avec un style objet\" />\n  <figcaption>Quand tu tapes n'importe quoi</figcaption>\n</figure>\n<h2>Insertion de style sous la forme d'objets</h2>\n<p>Écrire nos règles sous la forme de string est plutôt risqué : la chaîne de\ncaractère sera complexe à parser et à analyser. Nous nous exposons donc à\ncertains risques si nous ne pensons pas à prévoir certains cas.</p>\n<p>De plus, si une équipe de développeurs peut insérer absolument tout ce qu'elle\nsouhaite dans la feuille de style, elle pourra donc utiliser l'intégralité des\nsélecteurs CSS. Il faudrait donc faire appel à beaucoup de rigueur ou se reposer\nsur plusieurs outils supplémentaires (extensions IDE, linter, etc.).</p>\n<p>Nous allons donc créer une fonction supplémentaire pour transformer un objet en\nrègle insérable et dont le sélecteur sera un nom de classe généré et unique.</p>\n<p>Nous allons également créer quelques types assez basiques en haut de notre\nfichier.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-comment\">// &quot;Value&quot; peut être de type string OU number</span>\ntype Value = string | number;\n\n<span class=\"hljs-comment\">// &quot;Style&quot; est un objet dont les valeurs sont de type Value</span>\n<span class=\"hljs-keyword\">export</span> type Style = {\n  [name: string]: Value,\n};\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-built_in\">Object</span>.keys(style)\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>: <span class=\"hljs-subst\">${style[name]}</span>`</span>)\n    .join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n\n  insertRule(<span class=\"hljs-string\">`h1 { <span class=\"hljs-subst\">${content}</span> }`</span>);\n}\n</code></pre>\n<p>À ce point, vous pouvez importer <code>insertStyle</code> et vous en servir, vous\nconstaterez que cela a l'effet escompté… sur notre <code>h1</code> pour le moment.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { insertStyle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\ninsertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-string\">&quot;text-decoration&quot;</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n});\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/3.png\" alt=\"résultat avec un style objet\" />\n</figure>\n<p>Afin de créer un nom de classe unique, il nous faut hacher notre règle CSS. Cela\nconsiste à transformer la donnée entrée en &quot;empreinte&quot; permettant d'identifier\ncelle-ci. Ainsi, deux objets au contenu identique et ordonnés de la même façon\nauront tous deux la même empreinte. L'objectif étant que si plusieurs objets de\nstyle possèdent un contenu identique, celui-ci ne sera inséré d'une seule fois.</p>\n<p>Une fonction de hashage qui nous conviendrait est le <code>murmurhash2</code> disponible\nsur <code>npm</code>.</p>\n<pre><code class=\"hljs language-sh\">npm i -S murmurhash @types/murmurhash\n</code></pre>\n<p>Nous pouvons dès à présent générer un nom de classe en fonction du contenu de\nnotre règle CSS.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> murmurhash <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;murmurhash&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hash</span>(<span class=\"hljs-params\">str: string</span>) </span>{\n  <span class=\"hljs-comment\">// on retourne un string encodé en base 36</span>\n  <span class=\"hljs-keyword\">return</span> murmurhash.v2(str, <span class=\"hljs-number\">1</span>).toString(<span class=\"hljs-number\">36</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-built_in\">Object</span>.keys(style)\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>: <span class=\"hljs-subst\">${style[name]}</span>`</span>)\n    .join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(content);\n  insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span> { <span class=\"hljs-subst\">${content}</span> }`</span>);\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>Et même l'appliquer sur notre composant React / élément HTML / ce que vous\nvoulez !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { insertStyle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-string\">&quot;text-decoration&quot;</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n});\n\n<span class=\"hljs-comment\">// on applique la classe créée</span>\n<span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{className}</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/4.png\" alt=\"résultat avec nom de classe généré\" />\n</figure>\n<h2>Propriétés en lowerCamelCase</h2>\n<p>Créons une nouvelle fonction juste avant <code>insertStyle</code>. Celle-ci va remplacer\ntoutes les majuscules de notre paramètre de type <code>string</code> par un hyphen + sa\nminuscule.</p>\n<p>Elle gère également le cas un peu spécial des préfixes Microsoft (qui ne\ncommencent pas par une majuscule, contrairement à ceux de Mozilla / WebKit).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// expected outputs:</span>\n<span class=\"hljs-comment\">// fontFamily -&gt; font-family</span>\n<span class=\"hljs-comment\">// MozTransform -&gt; -moz-transform</span>\n<span class=\"hljs-comment\">// msTransform -&gt; -ms-transform</span>\n<span class=\"hljs-comment\">// WebkitTransform -&gt; -webkit-transform</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hyphenateName</span>(<span class=\"hljs-params\">name: string</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> name\n    .replace(<span class=\"hljs-regexp\">/([A-Z])/g</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">_, letter</span>) =&gt;</span> <span class=\"hljs-string\">`-<span class=\"hljs-subst\">${letter.toLowerCase()}</span>`</span>)\n    .replace(<span class=\"hljs-regexp\">/^ms-/</span>, <span class=\"hljs-string\">&quot;-ms-&quot;</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> content = <span class=\"hljs-built_in\">Object</span>.keys(style)\n    <span class=\"hljs-comment\">// on ajoute l&#x27;hyphenation du nom ici</span>\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${hyphenateName(name.trim())}</span>: <span class=\"hljs-subst\">${style[name]}</span>`</span>)\n    .join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(content);\n  insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span> { <span class=\"hljs-subst\">${content}</span> }`</span>);\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>En modifiant notre appel à <code>insertStyle</code> dans <code>index.tsx</code>, on s'aperçoit que\ntout fonctionne comme espéré.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>, <span class=\"hljs-comment\">// plus d&#x27;hyphens!</span>\n});\n\n<span class=\"hljs-comment\">//…</span>\n</code></pre>\n<h2>Gestion des valeurs de fallback</h2>\n<p>Parce qu'en CSS il est possible de faire:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">display</span>: <span class=\"hljs-selector-tag\">-webkit-flex</span>;\n<span class=\"hljs-selector-tag\">display</span>: <span class=\"hljs-selector-tag\">-moz-flex</span>;\n<span class=\"hljs-selector-tag\">display</span>: <span class=\"hljs-selector-tag\">flex</span>;\n</code></pre>\n<p>Mais que la nature des objets JavaScript ne nous le permet pas (impossible\nd'avoir plusieurs clés identiques), il nous faut pouvoir prendre un tableau en\nvaleur.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">//…</span>\n\n<span class=\"hljs-comment\">// on commence par modifier le type Value</span>\ntype Value = string | number | <span class=\"hljs-built_in\">Array</span>&lt;string | number&gt;;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on externalise la &quot;cssification&quot; en 2 fonctions</span>\n\n<span class=\"hljs-comment\">// cssifyDeclaration retourne &quot;nom: valeur&quot; si la valeur est correcte</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">cssifyDeclaration</span>(<span class=\"hljs-params\">name: string, value: any</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (\n    (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&quot;string&quot;</span> &amp;&amp; value !== <span class=\"hljs-string\">&quot;&quot;</span>) ||\n    (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&quot;number&quot;</span> &amp;&amp; <span class=\"hljs-built_in\">isFinite</span>(value))\n  ) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>: <span class=\"hljs-subst\">${(value + <span class=\"hljs-string\">&quot;&quot;</span>).trim()}</span>`</span>;\n  }\n}\n\n<span class=\"hljs-comment\">// compactDeclarations filtre les falsy values et compacte le reste avec &quot;; &quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">compactDeclarations</span>(<span class=\"hljs-params\">declarations: (string | <span class=\"hljs-literal\">undefined</span>)[]</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> declarations.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">declaration</span> =&gt;</span> !!declaration).join(<span class=\"hljs-string\">&quot;; &quot;</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> declarations = <span class=\"hljs-built_in\">Object</span>.keys(style).map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> hName = hyphenateName(name).trim();\n    <span class=\"hljs-keyword\">const</span> value = style[name];\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.isArray(value)\n      ? compactDeclarations(value.map(<span class=\"hljs-function\"><span class=\"hljs-params\">fbv</span> =&gt;</span> cssifyDeclaration(hName, fbv)))\n      : cssifyDeclaration(hName, value);\n  });\n\n  <span class=\"hljs-keyword\">const</span> content = compactDeclarations(declarations);\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(content);\n  insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span> { <span class=\"hljs-subst\">${content}</span> }`</span>);\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>Si on modifie le style appliqué sur notre <code>&lt;h1&gt;</code> de cette façon :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n  <span class=\"hljs-attr\">display</span>: [<span class=\"hljs-string\">&quot;-webkit-flex&quot;</span>, <span class=\"hljs-string\">&quot;-moz-flex&quot;</span>, <span class=\"hljs-string\">&quot;flex&quot;</span>],\n});\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<p>On constate que le navigateur ne nous indique pas que 3 valeurs ont été insérées\n(en barrant celles qui ne sont pas appliquées).</p>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/5.png\" alt=\"inspection des styles préfixés\" />\n</figure>\n<p>En effet, lorsque vous utilisez <code>insertRule</code>, seule la dernière valeur comprise\npar le navigateur est réellement insérée. Ainsi, si on change la valeur de\n<code>display</code> pour <code>[&quot;flex&quot;, &quot;-webkit-flex&quot;, &quot;-moz-flex&quot;]</code>, vous verrez que seul\n<code>-webkit-flex</code> sera appliqué (si bien sûr vous utilisez un navigateur qui\ncomprend les préfixes WebKit mais pas les préfixes Mozilla).</p>\n<h2>Gestion des pseudo-classes / éléments</h2>\n<p>L'idée c'est de les déclarer directement au sein de notre déclaration de style,\nsi possible de façon infiniment nestés.</p>\n<p>On modifie donc l'exemple pour visualiser le but à atteindre :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">const</span> className = insertStyle({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n\n  <span class=\"hljs-string\">&quot;:hover&quot;</span>: {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;rebeccapurple&quot;</span>,\n\n    <span class=\"hljs-string\">&quot;::first-letter&quot;</span>: {\n      <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;cyan&quot;</span>,\n    },\n  },\n});\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<p>Idéalement, il nous faudrait une fonction qui aplatisse ce style par suffixe\nappliqué à notre classe, de cette façon :</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">&quot;&quot;</span>: <span class=\"hljs-string\">&quot;color: pink; text-decoration: underline&quot;</span>,\n  <span class=\"hljs-string\">&quot;:hover&quot;</span>: <span class=\"hljs-string\">&quot;color: rebeccapurple&quot;</span>,\n  <span class=\"hljs-string\">&quot;:hover::first-letter&quot;</span>: <span class=\"hljs-string\">&quot;color: cyan&quot;</span>,\n};\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on modifie le type Style</span>\n<span class=\"hljs-keyword\">export</span> type Style = {\n  [name: string]: Value | Style,\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isPlainObject</span>(<span class=\"hljs-params\">value: any</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(value) === <span class=\"hljs-string\">&quot;[object Object]&quot;</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flattenStyle</span>(<span class=\"hljs-params\">style: Style, suffix: string = <span class=\"hljs-string\">&quot;&quot;</span></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> result: { [suffix: string]: string | <span class=\"hljs-literal\">undefined</span> } = {\n    <span class=\"hljs-comment\">// on s&#x27;assure que le sélecteur &quot;racine&quot; est le premier inséré</span>\n    [suffix]: <span class=\"hljs-literal\">undefined</span>,\n  };\n\n  <span class=\"hljs-comment\">// on extrait la logique qui était précedemment dans insertStyle</span>\n  <span class=\"hljs-keyword\">const</span> declarations = <span class=\"hljs-built_in\">Object</span>.keys(style).map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> value = style[name];\n\n    <span class=\"hljs-keyword\">if</span> (isPlainObject(value)) {\n      <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n        <span class=\"hljs-comment\">// on peaufine un peu la DX (et on évite quelques edge-cases)</span>\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-regexp\">/^::?(-webkit-|-moz-|-ms-)?[a-z][a-z-]+(\\(.+\\))?$/</span>.test(name)) {\n          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">`Invalid pseudo class / element: &quot;<span class=\"hljs-subst\">${name}</span>&quot;`</span>);\n        }\n      }\n\n      <span class=\"hljs-keyword\">const</span> nested = flattenStyle(value <span class=\"hljs-keyword\">as</span> Style, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${suffix}</span><span class=\"hljs-subst\">${name}</span>`</span>);\n\n      <span class=\"hljs-built_in\">Object</span>.keys(nested).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">nName</span> =&gt;</span> {\n        result[nName] = nested[nName];\n      });\n    } <span class=\"hljs-keyword\">else</span> {\n\n      <span class=\"hljs-keyword\">const</span> hName = hyphenateName(name).trim();\n\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>.isArray(value)\n        ? compactDeclarations(value.map(<span class=\"hljs-function\"><span class=\"hljs-params\">fbv</span> =&gt;</span> cssifyDeclaration(hName, fbv)))\n        : cssifyDeclaration(hName, value);\n    }\n  });\n\n  result[suffix] = compactDeclarations(declarations);\n  <span class=\"hljs-keyword\">return</span> result;\n}\n</code></pre>\n<p>Si on passe notre style dans cette fonction <code>flattenStyle</code> afin d'en analyser la\nsortie, on constate qu'elle fait exactement ce que l'on souhaite.</p>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/6.png\" alt=\"valeur retournée par la fonction flattenStyle\" />\n</figure>\n<p>Il ne nous reste qu'à hasher la représentation de cet objet et insérer les\nrègles une par une.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertStyle</span>(<span class=\"hljs-params\">style: Style</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flattened = flattenStyle(style);\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(<span class=\"hljs-built_in\">JSON</span>.stringify(flattened));\n\n  <span class=\"hljs-built_in\">Object</span>.keys(flattened).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">suffix</span> =&gt;</span> {\n    insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span><span class=\"hljs-subst\">${suffix}</span> { <span class=\"hljs-subst\">${flattened[suffix]}</span> }`</span>);\n  });\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/7.png\" alt=\"résultat avec gestion du hover\" />\n</figure>\n<h2>Concaténation de styles</h2>\n<p>Une pratique assez répandue est d'appliquer conditionnellement plusieurs objets\nstyles en fonction de l'état de nos composants.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ce genre de chose</span>\ncss(styles.base, <span class=\"hljs-built_in\">this</span>.props.disabled &amp;&amp; styles.disabled);\n</code></pre>\n<p>Supprimez tous les exports de fonction du fichier <code>css.ts</code>, nous n'allons en\ngarder qu'un seul, celui par défaut : cette fameuse fonction <code>css</code> !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> type MaybeStyle = Style | <span class=\"hljs-literal\">false</span> | <span class=\"hljs-literal\">null</span> | <span class=\"hljs-literal\">undefined</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// renommez la fonction ìnsertStyle</span>\n<span class=\"hljs-comment\">// elle accepte à présent des styles, mais aussi des &quot;falsy values&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">css</span>(<span class=\"hljs-params\">...styles: MaybeStyle[]</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flattened = styles\n    <span class=\"hljs-comment\">// on ne garde que les objets</span>\n    .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> isPlainObject(style))\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> flattenStyle(style))\n    .reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">flat, style</span>) =&gt;</span> {\n      <span class=\"hljs-built_in\">Object</span>.keys(style).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">suffix</span> =&gt;</span> {\n        flat[suffix] = flat[suffix]\n          ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${flat[suffix]}</span>; <span class=\"hljs-subst\">${style[suffix]}</span>`</span>\n          : style[suffix];\n      });\n      <span class=\"hljs-keyword\">return</span> flat;\n    }, {});\n\n  <span class=\"hljs-keyword\">const</span> className = <span class=\"hljs-string\">&quot;css-&quot;</span> + hash(<span class=\"hljs-built_in\">JSON</span>.stringify(flattened));\n\n  <span class=\"hljs-built_in\">Object</span>.keys(flattened).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">suffix</span> =&gt;</span> {\n    insertRule(<span class=\"hljs-string\">`.<span class=\"hljs-subst\">${className}</span><span class=\"hljs-subst\">${suffix}</span> { <span class=\"hljs-subst\">${flattened[suffix]}</span> }`</span>);\n  });\n\n  <span class=\"hljs-keyword\">return</span> className;\n}\n</code></pre>\n<p>Je vous laisse ça afin de faire un test rapide:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> css <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> className = css(\n  {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n    <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n\n    <span class=\"hljs-string\">&quot;:hover&quot;</span>: {\n      <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;rebeccapurple&quot;</span>,\n    },\n  },\n  {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;red&quot;</span>,\n\n    <span class=\"hljs-string\">&quot;:hover&quot;</span>: {\n      <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;blue&quot;</span>,\n    },\n  },\n);\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<h2>Autoprefixing</h2>\n<p>Il est temps de peaufiner un peu l'expérience de développement. Si je vous dit\nqu'on a implémenté toutes les features nécessaires pour utiliser l'équivalent\nd'un autoprefixer (qui préfixe automatiquatiquement les propriétés pour un\nmeilleur support navigateur)?</p>\n<p>Il s'agit d'<a href=\"https://inline-style-prefixer.js.org\">inline-style-prefixer</a>.</p>\n<pre><code class=\"hljs language-sh\">npm i -S inline-style-prefixer @types/inline-style-prefixer\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { prefix } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;inline-style-prefixer&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">css</span>(<span class=\"hljs-params\">...styles: Style[]</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> flattened = styles\n    .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> isPlainObject(style))\n    <span class=\"hljs-comment\">// on ajoute l&#x27;appel ici</span>\n    .map(<span class=\"hljs-function\"><span class=\"hljs-params\">style</span> =&gt;</span> flattenStyle(prefix(style) <span class=\"hljs-keyword\">as</span> Style))\n    <span class=\"hljs-comment\">// …</span>\n</code></pre>\n<p>Et c'est tout! 😀</p>\n<h2>Autocomplétion</h2>\n<p>Le CSS-in-JS, ça peut vous rebuter quand on voit le tooling actuellement\ndisponible pour le CSS. L'autocomplétion dans les éditeurs de texte est quali,\nça serait bien d'avoir quelque chose de similaire… Ça tombe bien, nous utilisons\nun langage typé.</p>\n<pre><code class=\"hljs language-sh\">npm i -S csstype\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { PropertiesFallback, SimplePseudos } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;csstype&quot;</span>;\n\n<span class=\"hljs-comment\">//…</span>\n\n<span class=\"hljs-comment\">// remplacez Style par ceci</span>\n<span class=\"hljs-keyword\">export</span> type Style = PropertiesFallback &amp;\n  { [pseudo <span class=\"hljs-keyword\">in</span> SimplePseudos]?: PropertiesFallback };\n\n<span class=\"hljs-comment\">// on en profite pour ajouter un type StyleSheet</span>\n<span class=\"hljs-keyword\">export</span> type StyleSheet = { [key: string]: Style };\n\n<span class=\"hljs-comment\">// …</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flattenStyle</span>(<span class=\"hljs-params\">style: Style, suffix: string = <span class=\"hljs-string\">&quot;&quot;</span></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> result: { [suffix: string]: string | <span class=\"hljs-literal\">undefined</span> } = {\n    [suffix]: <span class=\"hljs-literal\">undefined</span>,\n  };\n\n  <span class=\"hljs-keyword\">const</span> declarations = <span class=\"hljs-built_in\">Object</span>.keys(style).map(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> value = (style <span class=\"hljs-keyword\">as</span> any)[name] <span class=\"hljs-keyword\">as</span> Value; <span class=\"hljs-comment\">// on force le type ici</span>\n    <span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/8.png\" alt=\"démo de l'autocomplétion\" />\n</figure>\n<h2>Performances</h2>\n<p>Comme vous vous en doutez, pour le moment notre lib n'est pas un foudre de\nguerre : aucun système de cache n'est présent. Comme on désire tout de même\nbriller dans les benchmarks, tâchons d'optimiser ça.</p>\n<p>Pour cela on va utiliser la mémoïsation (on utilise lodash par commodité, mais\non peut faire plus léger).</p>\n<p>Pour ceux qui ne sont pas familiers avec le concept, cela nous permet de wrapper\nune fonction. Lors du premier appel, la fonction est appelée normalement, son\nrésultat est stocké dans un objet. Lors des appels suivants, les calculs ne\nseront plus effectués, le résultat en cache sera directement retourné.</p>\n<pre><code class=\"hljs language-sh\">npm i -S lodash.memoize @types/lodash.memoize\n</code></pre>\n<p>Trève de bavardages, on importe ça dans notre fichier <code>css.ts</code> et on optimise 😄</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/css.ts</span>\n\n<span class=\"hljs-keyword\">import</span> memoize <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;lodash.memoize&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on peut mémoïser la fonction hyphenateName de façon à</span>\n<span class=\"hljs-comment\">// ce que chaque règle ne soit convertie qu&#x27;une seule fois</span>\n<span class=\"hljs-keyword\">const</span> hyphenateName = memoize(<span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> name\n    .replace(<span class=\"hljs-regexp\">/([A-Z])/g</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">_, letter</span>) =&gt;</span> <span class=\"hljs-string\">`-<span class=\"hljs-subst\">${letter.toLowerCase()}</span>`</span>)\n    .replace(<span class=\"hljs-regexp\">/^ms-/</span>, <span class=\"hljs-string\">&quot;-ms-&quot;</span>);\n});\n\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-comment\">// on retire le export default</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">css</span>(<span class=\"hljs-params\">...styles: Style[]</span>) </span>{\n  <span class=\"hljs-comment\">// …</span>\n}\n\n<span class=\"hljs-comment\">// on exporte par défaut la fonction mémoïsée</span>\n<span class=\"hljs-comment\">// le deuxième argument sert à générer une clé pour l&#x27;élément en cache</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> memoize(css, <span class=\"hljs-function\">(<span class=\"hljs-params\">...styles</span>) =&gt;</span> <span class=\"hljs-built_in\">JSON</span>.stringify(styles));\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/9.png\" alt=\"benchmark avant optimisation\" />\n  <figcaption>Avant mémoïsation</figcaption>\n</figure>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/10.png\" alt=\"benchmark après optimisation\" />\n  <figcaption>Après mémoïsation</figcaption>\n</figure>\n<p>À savoir qu'il existe d'autres techniques de caching, notamment à base de\n<code>WeakMap</code>.</p>\n<h1>Intégration avec React</h1>\n<p>Parce qu'on adore React chez P!, je ne peux m'empêcher de conclure sans vous\nmontrer comment utiliser au mieux cette lib avec React. Créez un fichier\n<code>react.tsx</code>, c'est parti !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/react.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> cssFn, { MaybeStyle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n\n<span class=\"hljs-comment\">// on augmente les types des éléments DOM</span>\ndeclare <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&quot;react&quot;</span> {\n  interface HTMLAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n  }\n\n  interface SVGAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n  }\n}\n\n<span class=\"hljs-comment\">// on override la fonction createElement de React</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>&lt;\n  <span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> </span>{\n    css?: MaybeStyle | MaybeStyle[];\n    className?: string;\n  }\n&gt;(\n  Component: React.ComponentType&lt;P&gt; | string,\n  <span class=\"hljs-attr\">props</span>: P,\n  ...children: React.ReactElement&lt;any&gt;[]\n) {\n  <span class=\"hljs-comment\">// si le composant n&#x27;est pas un tag HTML ou qu&#x27;il</span>\n  <span class=\"hljs-comment\">// ne possède pas de prop CSS, on ne fait rien</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Component !== <span class=\"hljs-string\">&quot;string&quot;</span> || !props.css) {\n    <span class=\"hljs-keyword\">return</span> React.createElement(Component, props, ...children);\n  }\n\n  <span class=\"hljs-keyword\">const</span> { css, className, ...rest } = props;\n\n  <span class=\"hljs-comment\">// on transforme notre style en className, on l&#x27;ajoute</span>\n  <span class=\"hljs-comment\">// à la suite du className existant (si il existe)</span>\n  <span class=\"hljs-keyword\">const</span> newClassName =\n    (className ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${className}</span> `</span> : <span class=\"hljs-string\">&quot;&quot;</span>) +\n    (<span class=\"hljs-built_in\">Array</span>.isArray(css) ? cssFn(...css) : cssFn(css));\n\n  <span class=\"hljs-keyword\">return</span> React.createElement(\n    Component,\n    { ...rest, <span class=\"hljs-attr\">className</span>: newClassName },\n    ...children,\n  );\n}\n</code></pre>\n<p>Comment on se sert de tout ça ? Facile : on retourne dans le fichier\n<code>index.tsx</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { StyleSheet } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createElement } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./react&quot;</span>;\n<span class=\"hljs-comment\">/* @jsx createElement */</span>\n\n<span class=\"hljs-comment\">// puisque TS supprime l&#x27;import s&#x27;il ne sert que pour le pragma JSX,</span>\n<span class=\"hljs-comment\">// on laisse trainer la valeur. Pas idéal, mais ça fait le taf.</span>\n<span class=\"hljs-comment\">// voir https://github.com/babel/babel/issues/8958</span>\ncreateElement;\n\n<span class=\"hljs-keyword\">const</span> styles: StyleSheet = {\n  <span class=\"hljs-attr\">base</span>: {\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n    <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n  },\n  <span class=\"hljs-attr\">fancy</span>: {\n    <span class=\"hljs-string\">&quot;::first-letter&quot;</span>: {\n      <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">&quot;2em&quot;</span>,\n    },\n  },\n};\n\ntype State = {\n  <span class=\"hljs-attr\">isFancy</span>: boolean,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{}, State&gt; {\n  state = {\n    <span class=\"hljs-attr\">isFancy</span>: <span class=\"hljs-literal\">false</span>,\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">css</span>=<span class=\"hljs-string\">{[styles.base,</span> <span class=\"hljs-attr\">this.state.isFancy</span> &amp;&amp; <span class=\"hljs-attr\">styles.fancy</span>]}&gt;</span>\n          Hello world\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n            this.setState(prevState =&gt; ({ isFancy: !prevState.isFancy }));\n          }}\n        &gt;\n          Toggle fancy mode\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/11.gif\" alt=\"résultat de l'exemple\" />\n</figure>\n<p>Si vous êtes fan de <code>styled-components</code> (personnellement je déteste ça, mais\nchacun son truc), il est extrêmement simple de recréer une API similaire :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/react.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">styled</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">string</span>, <span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>&gt;(<span class=\"hljs-params\">\n  Component: T,\n  style: Style | ((props: P) =&gt; Style),\n</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: P &amp; React.HTMLProps&lt;T&gt;</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { children, ...rest } = props;\n    <span class=\"hljs-keyword\">const</span> css = <span class=\"hljs-keyword\">typeof</span> style === <span class=\"hljs-string\">&quot;function&quot;</span> ? style(props) : style;\n\n    <span class=\"hljs-keyword\">return</span> createElement(\n      Component,\n      { ...rest, css },\n      ...(children <span class=\"hljs-keyword\">as</span> React.ReactElement&lt;any&gt;[]),\n    );\n  };\n}\n</code></pre>\n<p>(Oui, c'est tout 🤭)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { styled } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./react&quot;</span>;\n\n<span class=\"hljs-comment\">// notre typage de props est mergé avec le typage de l&#x27;élément h1</span>\n<span class=\"hljs-keyword\">const</span> Title = styled(<span class=\"hljs-string\">&quot;h1&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">props: { fancy?: boolean }</span>) =&gt;</span> ({\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n  <span class=\"hljs-attr\">textDecoration</span>: <span class=\"hljs-string\">&quot;underline&quot;</span>,\n\n  ...(props.fancy &amp;&amp; {\n    <span class=\"hljs-string\">&quot;::first-letter&quot;</span>: {\n      <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">&quot;2em&quot;</span>,\n    },\n  }),\n}));\n\ntype State = {\n  <span class=\"hljs-attr\">isFancy</span>: boolean,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{}, State&gt; {\n  state = {\n    <span class=\"hljs-attr\">isFancy</span>: <span class=\"hljs-literal\">false</span>,\n  };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Title</span> <span class=\"hljs-attr\">fancy</span>=<span class=\"hljs-string\">{this.state.isFancy}</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Title</span>&gt;</span>\n        {/* … */}\n</span></code></pre>\n<h2>Gérer le responsive</h2>\n<p>Les media-queries c'est pas mal, mais au sein d'une approche composant,\nappliquer des styles par rapport aux dimensions de la totalité du viewport,\nc'est fort dommage.</p>\n<p>Nous allons donc utiliser\n<a href=\"https://developers.google.com/web/updates/2016/10/resizeobserver\"><code>ResizeObserver</code></a>.\nLe support n'est pas fou (uniquement Chrome à l'heure où j'écris ces lignes),\nmais heureusement un polyfill existe.</p>\n<pre><code class=\"hljs language-sh\">npm i -S resize-observer-polyfill\n</code></pre>\n<p>On retourne dans le fichier <code>react.tsx</code>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/react.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> ResizeObserver <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;resize-observer-polyfill&quot;</span>;\n\n<span class=\"hljs-comment\">// …</span>\n\ntype OnResizeCallBack = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  dimensions: {\n    height: number;\n    width: number;\n  },\n</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>;\n\ndeclare <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&quot;react&quot;</span> {\n  interface HTMLAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n    onResize?: OnResizeCallBack; <span class=\"hljs-comment\">// on ajoute le callback en prop</span>\n  }\n\n  interface SVGAttributes&lt;T&gt; {\n    css?: MaybeStyle | MaybeStyle[];\n    onResize?: OnResizeCallBack;\n  }\n}\n\n<span class=\"hljs-comment\">// on va stocker les callbacks par élément HTML</span>\n<span class=\"hljs-keyword\">const</span> callbacks: <span class=\"hljs-built_in\">Map</span>&lt;Element, OnResizeCallBack&gt; = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\n\n<span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> ResizeObserver(<span class=\"hljs-function\"><span class=\"hljs-params\">entries</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> entry <span class=\"hljs-keyword\">of</span> entries) {\n    <span class=\"hljs-keyword\">const</span> callback = callbacks.get(entry.target);\n\n    <span class=\"hljs-keyword\">if</span> (callback) {\n      <span class=\"hljs-keyword\">const</span> { height, width } = entry.contentRect;\n      callback({ height, width });\n    }\n  }\n});\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Resizable</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">ref: React.RefObject&lt;Element&gt;</span>) =&gt;</span> React.ReactElement&lt;any&gt;;\n  onResize: OnResizeCallBack;\n}&gt; {\n   <span class=\"hljs-comment\">// il est aussi possible d&#x27;utiliser forwardRef</span>\n  <span class=\"hljs-attr\">ref</span>: React.RefObject&lt;Element&gt; = React.createRef();\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.ref.current) {\n      callbacks.set(<span class=\"hljs-built_in\">this</span>.ref.current, <span class=\"hljs-built_in\">this</span>.props.onResize);\n      observer.observe(<span class=\"hljs-built_in\">this</span>.ref.current);\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.ref.current &amp;&amp; callbacks.has(<span class=\"hljs-built_in\">this</span>.ref.current)) {\n      callbacks.delete(<span class=\"hljs-built_in\">this</span>.ref.current);\n      observer.unobserve(<span class=\"hljs-built_in\">this</span>.ref.current);\n    }\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.render(<span class=\"hljs-built_in\">this</span>.ref);\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createElement</span>&lt;\n  <span class=\"hljs-title\">P</span> <span class=\"hljs-title\">extends</span> </span>{\n    css?: MaybeStyle | MaybeStyle[];\n    className?: string;\n    onResize?: OnResizeCallBack;\n  }\n&gt;(\n  Component: React.ComponentType&lt;P&gt; | string,\n  <span class=\"hljs-attr\">props</span>: P,\n  ...children: React.ReactElement&lt;any&gt;[]\n) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Component !== <span class=\"hljs-string\">&quot;string&quot;</span> || !props.css) {\n    <span class=\"hljs-keyword\">return</span> React.createElement(Component <span class=\"hljs-keyword\">as</span> any, props, ...children);\n  }\n\n  <span class=\"hljs-keyword\">const</span> { css, className, onResize, ...rest } = props;\n\n  <span class=\"hljs-keyword\">const</span> newClassName =\n    (className ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${className}</span> `</span> : <span class=\"hljs-string\">&quot;&quot;</span>) +\n    (<span class=\"hljs-built_in\">Array</span>.isArray(css) ? cssFn(...css) : cssFn(css));\n\n  <span class=\"hljs-keyword\">if</span> (onResize) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Resizable</span>\n        <span class=\"hljs-attr\">onResize</span>=<span class=\"hljs-string\">{onResize}</span>\n        <span class=\"hljs-attr\">render</span>=<span class=\"hljs-string\">{ref</span> =&gt;</span>\n          React.createElement(\n            Component,\n            { ...rest, ref, className: newClassName },\n            ...children,\n          )\n        }\n      /&gt;</span>\n    );\n  }\n\n  <span class=\"hljs-keyword\">return</span> React.createElement(\n    Component,\n    { ...rest, <span class=\"hljs-attr\">className</span>: newClassName },\n    ...children,\n  );\n}\n</code></pre>\n<p>Et pour ce qui est de l'usage:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/index.tsx</span>\n<span class=\"hljs-comment\">// …</span>\n\n<span class=\"hljs-keyword\">import</span> { StyleSheet } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./css&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createElement } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./react&quot;</span>;\n<span class=\"hljs-comment\">/* @jsx createElement */</span>\ncreateElement; <span class=\"hljs-comment\">// fix pour TS</span>\n\n<span class=\"hljs-keyword\">const</span> styles: StyleSheet = {\n  <span class=\"hljs-attr\">base</span>: {\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">&quot;hotpink&quot;</span>,\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-string\">&quot;300px&quot;</span>,\n    <span class=\"hljs-attr\">maxWidth</span>: <span class=\"hljs-string\">&quot;300px&quot;</span>,\n  },\n  <span class=\"hljs-attr\">small</span>: {\n    <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-string\">&quot;rebeccapurple&quot;</span>,\n  },\n};\n\ntype State = {\n  <span class=\"hljs-attr\">width</span>: number | <span class=\"hljs-literal\">null</span>,\n};\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;</span>{}, State&gt; {\n  state = { <span class=\"hljs-attr\">width</span>: <span class=\"hljs-literal\">null</span> };\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> { width } = <span class=\"hljs-built_in\">this</span>.state;\n\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">css</span>=<span class=\"hljs-string\">{[</span>\n          <span class=\"hljs-attr\">styles.base</span>,\n          // <span class=\"hljs-attr\">on</span> <span class=\"hljs-attr\">cache</span> <span class=\"hljs-attr\">l</span>&#x27;é<span class=\"hljs-attr\">l</span>é<span class=\"hljs-attr\">ment</span> <span class=\"hljs-attr\">tant</span> <span class=\"hljs-attr\">que</span> <span class=\"hljs-attr\">ses</span> <span class=\"hljs-attr\">dimensions</span> <span class=\"hljs-attr\">ne</span> <span class=\"hljs-attr\">sont</span> <span class=\"hljs-attr\">pas</span> <span class=\"hljs-attr\">dispos</span>\n          <span class=\"hljs-attr\">width</span> ? <span class=\"hljs-attr\">width</span> &lt; <span class=\"hljs-attr\">200</span> &amp;&amp; <span class=\"hljs-attr\">styles.small</span> <span class=\"hljs-attr\">:</span> { <span class=\"hljs-attr\">visibility:</span> &quot;<span class=\"hljs-attr\">hidden</span>&quot; },\n        ]}\n        <span class=\"hljs-attr\">onResize</span>=<span class=\"hljs-string\">{({</span> <span class=\"hljs-attr\">width</span> }) =&gt;</span> {\n          this.setState({ width });\n        }}\n      /&gt;</span>\n    );\n  }\n}\n\n<span class=\"hljs-comment\">// …</span>\n</code></pre>\n<figure>\n  <img src=\"/public/images/articles/2019-01-22-comprendre-le-css-in-js-par-l-exemple/12.gif\" alt=\"résultat responsive\" />\n</figure>\n<p>Il est temps de conclure ! Comme vous avez pu le constater, notre errance dans\nle CSSOM nous a permis de créer une abstraction qui :</p>\n<ul>\n<li>est déterministe (le nom de la classe est généré en fonction du style),</li>\n<li>nous évite de nous soucier de la spécificité des sélecteurs CSS,</li>\n<li>isole le style par composant et empêche un tas de comportements inattendus,</li>\n<li>nous permet de gérer le responsive sans se soucier du contexte.</li>\n</ul>\n<p>Si vous ne comprenez pas certains points ou si vous avez des questions supplémentaires,\nn'hésitez pas à poster un commentaire, je me ferai une joie d'y répondre.</p>\n<p>La bise 😘</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><head><script defer="defer" src="/public/main.56c69761a03eb0112696.js"></script></head></html>